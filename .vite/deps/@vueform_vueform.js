import {
  computed,
  getCurrentInstance,
  h,
  inject,
  markRaw,
  nextTick,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onMounted,
  onUnmounted,
  onUpdated,
  provide,
  reactive,
  ref,
  toRefs,
  watch
} from "./chunk-XSWAMETM.js";
import {
  __export,
  __require
} from "./chunk-UURD7IY7.js";

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys3 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys3.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys3[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys3 = Object.keys(obj);
  let i = keys3.length;
  let _key;
  while (i-- > 0) {
    _key = keys3[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue2 = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue2);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches2;
  const arr = [];
  while ((matches2 = regExp.exec(str)) !== null) {
    arr.push(matches2);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty3 }) => (obj, prop) => hasOwnProperty3.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    let ret;
    if ((ret = reducer(descriptor, name2, obj)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size2--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config2, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each2(token2, i) {
    token2 = removeBrackets(token2);
    return !dots && i ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option2, source) {
    return !utils_default.isUndefined(source[option2]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each2(el, index2) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each2(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each2(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name2) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys3 = Object.keys(arr);
  let i;
  const len = keys3.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys3[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name2 = path[index2++];
    if (name2 === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index2 >= path.length;
    name2 = !name2 && utils_default.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils_default.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index2);
    if (result && utils_default.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError_default.from(e2, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens2 = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens2[match[1]] = match[2];
  }
  return tokens2;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
  if (utils_default.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils_default.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys3 = Object.keys(this);
    let i = keys3.length;
    let deleted = false;
    while (i--) {
      const key = keys3[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed2 = new this(first);
    targets.forEach((target) => computed2.set(target));
    return computed2;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config2 = this || defaults_default;
  const context = response || config2;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config2, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min4) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head2 = 0;
  let tail = 0;
  let firstSampleTS;
  min4 = min4 !== void 0 ? min4 : 1e3;
  return function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head2] = chunkLength;
    timestamps[head2] = now2;
    let i = tail;
    let bytesCount = 0;
    while (i !== head2) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head2 = (head2 + 1) % samplesCount;
    if (head2 === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min4) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  const threshold = 1e3 / freq;
  let timer = null;
  return function throttled() {
    const force = this === true;
    const now2 = Date.now();
    if (force || now2 - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp = now2;
      return fn.apply(null, arguments);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp = Date.now();
        return fn.apply(null, arguments);
      }, threshold - (now2 - timestamp));
    }
  };
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer_default = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  }, freq);
};

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url2) {
      let href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name2, value, expires, path, domain, secure) {
      const cookie = [name2 + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name2) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge3 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge3(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config2) => {
  const newConfig = mergeConfig({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens2] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens2].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType } = _config;
    let onCanceled;
    function done() {
      if (_config.cancelToken) {
        _config.cancelToken.unsubscribe(onCanceled);
      }
      if (_config.signal) {
        _config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, _config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, _config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        _config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (typeof _config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer_default(_config.onDownloadProgress, true));
    }
    if (typeof _config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer_default(_config.onUploadProgress));
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config2, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  let controller = new AbortController();
  let aborted;
  const onabort = function(cancel) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      const err = cancel instanceof Error ? cancel : this.reason;
      controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
    }
  };
  let timer = timeout && setTimeout(() => {
    onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
  }, timeout);
  const unsubscribe = () => {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach((signal2) => {
        signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
      });
      signals = null;
    }
  };
  signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
  const { signal } = controller;
  signal.unsubscribe = unsubscribe;
  return [signal, () => {
    timer && clearTimeout(timer);
    timer = null;
  }];
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize, encode3) {
  for await (const chunk of iterable) {
    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode3(String(chunk)), chunkSize);
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish, encode3) => {
  const iterator = readBytes(stream, chunkSize, encode3);
  let bytes = 0;
  return new ReadableStream({
    type: "bytes",
    async pull(controller) {
      const { done, value } = await iterator.next();
      if (done) {
        controller.close();
        onFinish();
        return;
      }
      let len = value.byteLength;
      onProgress && onProgress(bytes += len);
      controller.enqueue(new Uint8Array(value));
    },
    cancel(reason) {
      onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var fetchProgressDecorator = (total, fn) => {
  const lengthComputable = total != null;
  return (loaded) => setTimeout(() => fn({
    lengthComputable,
    total,
    loaded
  }));
};
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var supportsRequestStream = isReadableStreamSupported && (() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
})();
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && !!(() => {
  try {
    return utils_default.isReadableStream(new Response("").body);
  } catch (err) {
  }
})();
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_, config2) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config2);
    });
  });
})(new Response());
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    return (await new Request(body).arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length = utils_default.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var fetch_default = isFetchSupported && (async (config2) => {
  let {
    url: url2,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config2);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals_default([signal, cancelToken], timeout) : [];
  let finished, request;
  const onFinish = () => {
    !finished && setTimeout(() => {
      composedSignal && composedSignal.unsubscribe();
    });
    finished = true;
  };
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url2, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(
          requestContentLength,
          progressEventReducer_default(onUploadProgress)
        ), null, encodeText);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "cors" : "omit";
    }
    request = new Request(url2, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      withCredentials
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(
          responseContentLength,
          progressEventReducer_default(onDownloadProgress, true)
        ), isStreamResponse && onFinish, encodeText),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config2);
    !isStreamResponse && onFinish();
    stopTimeout && stopTimeout();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config: config2,
        request
      });
    });
  } catch (err) {
    onFinish();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default.from(err, err && err.code, config2, request);
  }
});

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError_default(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders_default.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config2.adapter || defaults_default.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.7.2";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys3 = Object.keys(options);
  let i = keys3.length;
  while (i-- > 0) {
    const opt = keys3[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url: url2,
      data: (config2 || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners)
        return;
      let i = token2._listeners.length;
      while (i-- > 0) {
        token2._listeners[i](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError_default(message, config2, request);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new _CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token2,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback57) {
  return function wrap(arr) {
    return callback57.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/moment/dist/moment.js
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback57) {
  hookCallback = callback57;
}
function isArray2(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject2(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k;
    for (k in obj) {
      if (hasOwnProp(obj, k)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined2(input) {
  return input === void 0;
}
function isNumber2(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate2(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map(arr, fn) {
  var res = [], i, arrLen = arr.length;
  for (i = 0; i < arrLen; ++i) {
    res.push(fn(arr[i], i));
  }
  return res;
}
function extend2(a, b) {
  for (var i in b) {
    if (hasOwnProp(b, i)) {
      a[i] = b[i];
    }
  }
  if (hasOwnProp(b, "toString")) {
    a.toString = b.toString;
  }
  if (hasOwnProp(b, "valueOf")) {
    a.valueOf = b.valueOf;
  }
  return a;
}
function createUTC(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m) {
  if (m._pf == null) {
    m._pf = defaultParsingFlags();
  }
  return m._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t2 = Object(this), len = t2.length >>> 0, i;
    for (i = 0; i < len; i++) {
      if (i in t2 && fun.call(this, t2[i], i, t2)) {
        return true;
      }
    }
    return false;
  };
}
function isValid(m) {
  var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
  if (isNowValid) {
    flags = getParsingFlags(m);
    parsedParts = some.call(flags.parsedDateParts, function(i) {
      return i != null;
    });
    isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
  }
  if (Object.isFrozen == null || !Object.isFrozen(m)) {
    m._isValid = isNowValid;
  } else {
    return isNowValid;
  }
  return m._isValid;
}
function createInvalid(flags) {
  var m = createUTC(NaN);
  if (flags != null) {
    extend2(getParsingFlags(m), flags);
  } else {
    getParsingFlags(m).userInvalidated = true;
  }
  return m;
}
var momentProperties = hooks.momentProperties = [];
var updateInProgress = false;
function copyConfig(to2, from2) {
  var i, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined2(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined2(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined2(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined2(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined2(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined2(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined2(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined2(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined2(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined2(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i = 0; i < momentPropertiesLen; i++) {
      prop = momentProperties[i];
      val = from2[prop];
      if (!isUndefined2(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config2) {
  copyConfig(this, config2);
  this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = /* @__PURE__ */ new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend2(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i, key, argLen = arguments.length;
      for (i = 0; i < argLen; i++) {
        arg = "";
        if (typeof arguments[i] === "object") {
          arg += "\n[" + i + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
var deprecations = {};
function deprecateSimple(name2, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name2, msg);
  }
  if (!deprecations[name2]) {
    warn(msg);
    deprecations[name2] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction2(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set(config2) {
  var prop, i;
  for (i in config2) {
    if (hasOwnProp(config2, i)) {
      prop = config2[i];
      if (isFunction2(prop)) {
        this[i] = prop;
      } else {
        this["_" + i] = prop;
      }
    }
  }
  this._config = config2;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend2({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
        res[prop] = {};
        extend2(res[prop], parentConfig[prop]);
        extend2(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
      res[prop] = extend2({}, res[prop]);
    }
  }
  return res;
}
function Locale(config2) {
  if (config2 != null) {
    this.set(config2);
  }
}
var keys;
if (Object.keys) {
  keys = Object.keys;
} else {
  keys = function(obj) {
    var i, res = [];
    for (i in obj) {
      if (hasOwnProp(obj, i)) {
        res.push(i);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction2(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
var formatFunctions = {};
var formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback57) {
  var func = callback57;
  if (typeof callback57 === "string") {
    func = function() {
      return this[callback57]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func.apply(this, arguments),
        token2
      );
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array4 = format2.match(formattingTokens), i, length;
  for (i = 0, length = array4.length; i < length; i++) {
    if (formatTokenFunctions[array4[i]]) {
      array4[i] = formatTokenFunctions[array4[i]];
    } else {
      array4[i] = removeFormattingTokens(array4[i]);
    }
  }
  return function(mom) {
    var output = "", i2;
    for (i2 = 0; i2 < length; i2++) {
      output += isFunction2(array4[i2]) ? array4[i2].call(mom, format2) : array4[i2];
    }
    return output;
  };
}
function formatMoment(m, format2) {
  if (!m.isValid()) {
    return m.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m);
}
function expandFormat(format2, locale2) {
  var i = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i -= 1;
  }
  return format2;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d";
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string2, isFuture) {
  var output = this._relativeTime[string2];
  return isFunction2(output) ? output(number, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction2(format2) ? format2(output) : format2.replace(/%s/i, output);
}
var aliases = {
  D: "date",
  dates: "date",
  date: "date",
  d: "day",
  days: "day",
  day: "day",
  e: "weekday",
  weekdays: "weekday",
  weekday: "weekday",
  E: "isoWeekday",
  isoweekdays: "isoWeekday",
  isoweekday: "isoWeekday",
  DDD: "dayOfYear",
  dayofyears: "dayOfYear",
  dayofyear: "dayOfYear",
  h: "hour",
  hours: "hour",
  hour: "hour",
  ms: "millisecond",
  milliseconds: "millisecond",
  millisecond: "millisecond",
  m: "minute",
  minutes: "minute",
  minute: "minute",
  M: "month",
  months: "month",
  month: "month",
  Q: "quarter",
  quarters: "quarter",
  quarter: "quarter",
  s: "second",
  seconds: "second",
  second: "second",
  gg: "weekYear",
  weekyears: "weekYear",
  weekyear: "weekYear",
  GG: "isoWeekYear",
  isoweekyears: "isoWeekYear",
  isoweekyear: "isoWeekYear",
  w: "week",
  weeks: "week",
  week: "week",
  W: "isoWeek",
  isoweeks: "isoWeek",
  isoweek: "isoWeek",
  y: "year",
  years: "year",
  year: "year"
};
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {
  date: 9,
  day: 11,
  weekday: 11,
  isoWeekday: 11,
  dayOfYear: 4,
  hour: 13,
  millisecond: 16,
  minute: 14,
  month: 8,
  quarter: 7,
  second: 15,
  weekYear: 1,
  isoWeekYear: 1,
  week: 5,
  isoWeek: 5,
  year: 1
};
function getPrioritizedUnits(unitsObj) {
  var units = [], u;
  for (u in unitsObj) {
    if (hasOwnProp(unitsObj, u)) {
      units.push({ unit: u, priority: priorities[u] });
    }
  }
  units.sort(function(a, b) {
    return a.priority - b.priority;
  });
  return units;
}
var match1 = /\d/;
var match2 = /\d\d/;
var match3 = /\d{3}/;
var match4 = /\d{4}/;
var match6 = /[+-]?\d{6}/;
var match1to2 = /\d\d?/;
var match3to4 = /\d\d\d\d?/;
var match5to6 = /\d\d\d\d\d\d?/;
var match1to3 = /\d{1,3}/;
var match1to4 = /\d{1,4}/;
var match1to6 = /[+-]?\d{1,6}/;
var matchUnsigned = /\d+/;
var matchSigned = /[+-]?\d+/;
var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
var match1to2NoLeadingZero = /^[1-9]\d?/;
var match1to2HasZero = /^([1-9]\d|\d)/;
var regexes;
regexes = {};
function addRegexToken(token2, regex2, strictRegex) {
  regexes[token2] = isFunction2(regex2) ? regex2 : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex2;
  };
}
function getParseRegexForToken(token2, config2) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config2._strict, config2._locale);
}
function unescapeFormat(s) {
  return regexEscape(
    s.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
var tokens = {};
function addParseToken(token2, callback57) {
  var i, func = callback57, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber2(callback57)) {
    func = function(input, array4) {
      array4[callback57] = toInt(input);
    };
  }
  tokenLen = token2.length;
  for (i = 0; i < tokenLen; i++) {
    tokens[token2[i]] = func;
  }
}
function addWeekParseToken(token2, callback57) {
  addParseToken(token2, function(input, array4, config2, token3) {
    config2._w = config2._w || {};
    callback57(input, config2._w, config2, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config2) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config2._a, config2, token2);
  }
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;
addFormatToken("Y", 0, 0, function() {
  var y = this.year();
  return y <= 9999 ? zeroFill(y, 4) : "+" + y;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array4) {
  array4[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array4) {
  array4[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array4) {
  array4[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get(this, unit);
    }
  };
}
function get(mom, unit) {
  if (!mom.isValid()) {
    return NaN;
  }
  var d = mom._d, isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
    case "Seconds":
      return isUTC ? d.getUTCSeconds() : d.getSeconds();
    case "Minutes":
      return isUTC ? d.getUTCMinutes() : d.getMinutes();
    case "Hours":
      return isUTC ? d.getUTCHours() : d.getHours();
    case "Date":
      return isUTC ? d.getUTCDate() : d.getDate();
    case "Day":
      return isUTC ? d.getUTCDay() : d.getDay();
    case "Month":
      return isUTC ? d.getUTCMonth() : d.getMonth();
    case "FullYear":
      return isUTC ? d.getUTCFullYear() : d.getFullYear();
    default:
      return NaN;
  }
}
function set$1(mom, unit, value) {
  var d, isUTC, year, month, date6;
  if (!mom.isValid() || isNaN(value)) {
    return;
  }
  d = mom._d;
  isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
    case "Seconds":
      return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
    case "Minutes":
      return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
    case "Hours":
      return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
    case "Date":
      return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
    case "FullYear":
      break;
    default:
      return;
  }
  year = value;
  month = mom.month();
  date6 = mom.date();
  date6 = date6 === 29 && month === 1 && !isLeapYear(year) ? 28 : date6;
  void (isUTC ? d.setUTCFullYear(year, month, date6) : d.setFullYear(year, month, date6));
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction2(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
    for (i = 0; i < prioritizedLen; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction2(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
function mod(n2, x) {
  return (n2 % x + x) % x;
}
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o2) {
    var i;
    for (i = 0; i < this.length; ++i) {
      if (this[i] === o2) {
        return i;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format2) {
  return this.localeData().monthsShort(this, format2);
});
addFormatToken("MMMM", 0, 0, function(format2) {
  return this.localeData().months(this, format2);
});
addRegexToken("M", match1to2, match1to2NoLeadingZero);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array4) {
  array4[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array4, config2, token2) {
  var month = config2._locale.monthsParse(input, token2, config2._strict);
  if (month != null) {
    array4[MONTH] = month;
  } else {
    getParsingFlags(config2).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
);
var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultMonthsShortRegex = matchWord;
var defaultMonthsRegex = matchWord;
function localeMonths(m, format2) {
  if (!m) {
    return isArray2(this._months) ? this._months : this._months["standalone"];
  }
  return isArray2(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
}
function localeMonthsShort(m, format2) {
  if (!m) {
    return isArray2(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray2(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i = 0; i < 12; ++i) {
      mom = createUTC([2e3, i]);
      this._shortMonthsParse[i] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i, mom, regex2;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i]) {
      regex2 = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i] = new RegExp(regex2.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}
function setMonth(mom, value) {
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber2(value)) {
        return mom;
      }
    }
  }
  var month = value, date6 = mom.date();
  date6 = date6 < 29 ? date6 : Math.min(date6, daysInMonth(mom.year(), month));
  void (mom._isUTC ? mom._d.setUTCMonth(month, date6) : mom._d.setMonth(month, date6));
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    shortP = regexEscape(this.monthsShort(mom, ""));
    longP = regexEscape(this.months(mom, ""));
    shortPieces.push(shortP);
    longPieces.push(longP);
    mixedPieces.push(longP);
    mixedPieces.push(shortP);
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
function createDate(y, m, d, h2, M, s, ms) {
  var date6;
  if (y < 100 && y >= 0) {
    date6 = new Date(y + 400, m, d, h2, M, s, ms);
    if (isFinite(date6.getFullYear())) {
      date6.setFullYear(y);
    }
  } else {
    date6 = new Date(y, m, d, h2, M, s, ms);
  }
  return date6;
}
function createUTCDate(y) {
  var date6, args;
  if (y < 100 && y >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y + 400;
    date6 = new Date(Date.UTC.apply(null, args));
    if (isFinite(date6.getUTCFullYear())) {
      date6.setUTCFullYear(y);
    }
  } else {
    date6 = new Date(Date.UTC.apply(null, arguments));
  }
  return date6;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addRegexToken("w", match1to2, match1to2NoLeadingZero);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2, match1to2NoLeadingZero);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(
  ["w", "ww", "W", "WW"],
  function(input, week, config2, token2) {
    week[token2.substr(0, 1)] = toInt(input);
  }
);
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format2) {
  return this.localeData().weekdaysMin(this, format2);
});
addFormatToken("ddd", 0, 0, function(format2) {
  return this.localeData().weekdaysShort(this, format2);
});
addFormatToken("dddd", 0, 0, function(format2) {
  return this.localeData().weekdays(this, format2);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config2, token2) {
  var weekday = config2._locale.weekdaysParse(input, token2, config2._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config2).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config2, token2) {
  week[token2] = toInt(input);
});
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n2) {
  return ws.slice(n2, 7).concat(ws.slice(0, n2));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
var defaultWeekdaysRegex = matchWord;
var defaultWeekdaysShortRegex = matchWord;
var defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m, format2) {
  var weekdays = isArray2(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
}
function localeWeekdaysShort(m) {
  return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m) {
  return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i = 0; i < 7; ++i) {
      mom = createUTC([2e3, 1]).day(i);
      this._minWeekdaysParse[i] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i, mom, regex2;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i]) {
      regex2 = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i] = new RegExp(regex2.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = get(this, "Day");
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
meridiem("a", true);
meridiem("A", false);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2, match1to2HasZero);
addRegexToken("h", match1to2, match1to2NoLeadingZero);
addRegexToken("k", match1to2, match1to2NoLeadingZero);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array4, config2) {
  var kInput = toInt(input);
  array4[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array4, config2) {
  config2._isPm = config2._locale.isPM(input);
  config2._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array4, config2) {
  array4[HOUR] = toInt(input);
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmm", function(input, array4, config2) {
  var pos = input.length - 2;
  array4[HOUR] = toInt(input.substr(0, pos));
  array4[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmmss", function(input, array4, config2) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array4[HOUR] = toInt(input.substr(0, pos1));
  array4[MINUTE] = toInt(input.substr(pos1, 2));
  array4[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("Hmm", function(input, array4, config2) {
  var pos = input.length - 2;
  array4[HOUR] = toInt(input.substr(0, pos));
  array4[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array4, config2) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array4[HOUR] = toInt(input.substr(0, pos1));
  array4[MINUTE] = toInt(input.substr(pos1, 2));
  array4[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
var getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {};
var localeFamilies = {};
var globalLocale;
function commonPrefix(arr1, arr2) {
  var i, minl = Math.min(arr1.length, arr2.length);
  for (i = 0; i < minl; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i = 0, j, next, locale2, split;
  while (i < names.length) {
    split = normalizeLocale(names[i]).split("-");
    j = split.length;
    next = normalizeLocale(names[i + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale2 = loadLocale(split.slice(0, j).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
        break;
      }
      j--;
    }
    i++;
  }
  return globalLocale;
}
function isLocaleNameSane(name2) {
  return !!(name2 && name2.match("^[^/\\\\]*$"));
}
function loadLocale(name2) {
  var oldLocale = null, aliasedRequire;
  if (locales[name2] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name2)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = __require;
      aliasedRequire("./locale/" + name2);
      getSetGlobalLocale(oldLocale);
    } catch (e2) {
      locales[name2] = null;
    }
  }
  return locales[name2];
}
function getSetGlobalLocale(key, values2) {
  var data;
  if (key) {
    if (isUndefined2(values2)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values2);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name2, config2) {
  if (config2 !== null) {
    var locale2, parentConfig = baseConfig;
    config2.abbr = name2;
    if (locales[name2] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name2]._config;
    } else if (config2.parentLocale != null) {
      if (locales[config2.parentLocale] != null) {
        parentConfig = locales[config2.parentLocale]._config;
      } else {
        locale2 = loadLocale(config2.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config2.parentLocale]) {
            localeFamilies[config2.parentLocale] = [];
          }
          localeFamilies[config2.parentLocale].push({
            name: name2,
            config: config2
          });
          return null;
        }
      }
    }
    locales[name2] = new Locale(mergeConfigs(parentConfig, config2));
    if (localeFamilies[name2]) {
      localeFamilies[name2].forEach(function(x) {
        defineLocale(x.name, x.config);
      });
    }
    getSetGlobalLocale(name2);
    return locales[name2];
  } else {
    delete locales[name2];
    return null;
  }
}
function updateLocale(name2, config2) {
  if (config2 != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name2] != null && locales[name2].parentLocale != null) {
      locales[name2].set(mergeConfigs(locales[name2]._config, config2));
    } else {
      tmpLocale = loadLocale(name2);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config2 = mergeConfigs(parentConfig, config2);
      if (tmpLocale == null) {
        config2.abbr = name2;
      }
      locale2 = new Locale(config2);
      locale2.parentLocale = locales[name2];
      locales[name2] = locale2;
    }
    getSetGlobalLocale(name2);
  } else {
    if (locales[name2] != null) {
      if (locales[name2].parentLocale != null) {
        locales[name2] = locales[name2].parentLocale;
        if (name2 === getSetGlobalLocale()) {
          getSetGlobalLocale(name2);
        }
      } else if (locales[name2] != null) {
        delete locales[name2];
      }
    }
  }
  return locales[name2];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray2(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m) {
  var overflow, a = m._a;
  if (a && getParsingFlags(m).overflow === -2) {
    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m).overflow = overflow;
  }
  return m;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
var isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
];
var isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
];
var aspNetJsonRegex = /^\/?Date\((-?\d+)/i;
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
var obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config2) {
  var i, l, string2 = config2._i, match = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match) {
    getParsingFlags(config2).iso = true;
    for (i = 0, l = isoDatesLen; i < l; i++) {
      if (isoDates[i][1].exec(match[1])) {
        dateFormat = isoDates[i][0];
        allowTime = isoDates[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config2._isValid = false;
      return;
    }
    if (match[3]) {
      for (i = 0, l = isoTimesLen; i < l; i++) {
        if (isoTimes[i][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes[i][0];
          break;
        }
      }
      if (timeFormat == null) {
        config2._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config2._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config2._isValid = false;
        return;
      }
    }
    config2._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config2);
  } else {
    config2._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s) {
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config2) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config2).weekdayMismatch = true;
      config2._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m = hm % 100, h2 = (hm - m) / 100;
    return h2 * 60 + m;
  }
}
function configFromRFC2822(config2) {
  var match = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
  if (match) {
    parsedArray = extractFromRFC2822Strings(
      match[4],
      match[3],
      match[2],
      match[5],
      match[6],
      match[7]
    );
    if (!checkWeekday(match[1], parsedArray, config2)) {
      return;
    }
    config2._a = parsedArray;
    config2._tzm = calculateOffset(match[8], match[9], match[10]);
    config2._d = createUTCDate.apply(null, config2._a);
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
    getParsingFlags(config2).rfc2822 = true;
  } else {
    config2._isValid = false;
  }
}
function configFromString(config2) {
  var matched = aspNetJsonRegex.exec(config2._i);
  if (matched !== null) {
    config2._d = /* @__PURE__ */ new Date(+matched[1]);
    return;
  }
  configFromISO(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  configFromRFC2822(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  if (config2._strict) {
    config2._isValid = false;
  } else {
    hooks.createFromInputFallback(config2);
  }
}
hooks.createFromInputFallback = deprecate(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(config2) {
    config2._d = /* @__PURE__ */ new Date(config2._i + (config2._useUTC ? " UTC" : ""));
  }
);
function defaults2(a, b, c) {
  if (a != null) {
    return a;
  }
  if (b != null) {
    return b;
  }
  return c;
}
function currentDateArray(config2) {
  var nowValue = new Date(hooks.now());
  if (config2._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config2) {
  var i, date6, input = [], currentDate, expectedWeekday, yearToUse;
  if (config2._d) {
    return;
  }
  currentDate = currentDateArray(config2);
  if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config2);
  }
  if (config2._dayOfYear != null) {
    yearToUse = defaults2(config2._a[YEAR], currentDate[YEAR]);
    if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
      getParsingFlags(config2)._overflowDayOfYear = true;
    }
    date6 = createUTCDate(yearToUse, 0, config2._dayOfYear);
    config2._a[MONTH] = date6.getUTCMonth();
    config2._a[DATE] = date6.getUTCDate();
  }
  for (i = 0; i < 3 && config2._a[i] == null; ++i) {
    config2._a[i] = input[i] = currentDate[i];
  }
  for (; i < 7; i++) {
    config2._a[i] = input[i] = config2._a[i] == null ? i === 2 ? 1 : 0 : config2._a[i];
  }
  if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
    config2._nextDay = true;
    config2._a[HOUR] = 0;
  }
  config2._d = (config2._useUTC ? createUTCDate : createDate).apply(
    null,
    input
  );
  expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
  if (config2._tzm != null) {
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
  }
  if (config2._nextDay) {
    config2._a[HOUR] = 24;
  }
  if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
    getParsingFlags(config2).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config2) {
  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w = config2._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults2(
      w.GG,
      config2._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults2(w.W, 1);
    weekday = defaults2(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config2._locale._week.dow;
    doy = config2._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults2(w.gg, config2._a[YEAR], curWeek.year);
    week = defaults2(w.w, curWeek.week);
    if (w.d != null) {
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config2)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config2)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config2._a[YEAR] = temp.year;
    config2._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config2) {
  if (config2._f === hooks.ISO_8601) {
    configFromISO(config2);
    return;
  }
  if (config2._f === hooks.RFC_2822) {
    configFromRFC2822(config2);
    return;
  }
  config2._a = [];
  getParsingFlags(config2).empty = true;
  var string2 = "" + config2._i, i, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i = 0; i < tokenLen; i++) {
    token2 = tokens2[i];
    parsedInput = (string2.match(getParseRegexForToken(token2, config2)) || [])[0];
    if (parsedInput) {
      skipped = string2.substr(0, string2.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config2).unusedInput.push(skipped);
      }
      string2 = string2.slice(
        string2.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config2).empty = false;
      } else {
        getParsingFlags(config2).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config2);
    } else if (config2._strict && !parsedInput) {
      getParsingFlags(config2).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
  if (string2.length > 0) {
    getParsingFlags(config2).unusedInput.push(string2);
  }
  if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
    getParsingFlags(config2).bigHour = void 0;
  }
  getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
  getParsingFlags(config2).meridiem = config2._meridiem;
  config2._a[HOUR] = meridiemFixWrap(
    config2._locale,
    config2._a[HOUR],
    config2._meridiem
  );
  era = getParsingFlags(config2).era;
  if (era !== null) {
    config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
  }
  configFromArray(config2);
  checkOverflow(config2);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config2) {
  var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config2._f.length;
  if (configfLen === 0) {
    getParsingFlags(config2).invalidFormat = true;
    config2._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (i = 0; i < configfLen; i++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config2);
    if (config2._useUTC != null) {
      tempConfig._useUTC = config2._useUTC;
    }
    tempConfig._f = config2._f[i];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend2(config2, bestMoment || tempConfig);
}
function configFromObject(config2) {
  if (config2._d) {
    return;
  }
  var i = normalizeObjectUnits(config2._i), dayOrDate = i.day === void 0 ? i.date : i.day;
  config2._a = map(
    [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config2);
}
function createFromConfig(config2) {
  var res = new Moment(checkOverflow(prepareConfig(config2)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config2) {
  var input = config2._i, format2 = config2._f;
  config2._locale = config2._locale || getLocale(config2._l);
  if (input === null || format2 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config2._i = input = config2._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate2(input)) {
    config2._d = input;
  } else if (isArray2(format2)) {
    configFromStringAndArray(config2);
  } else if (format2) {
    configFromStringAndFormat(config2);
  } else {
    configFromInput(config2);
  }
  if (!isValid(config2)) {
    config2._d = null;
  }
  return config2;
}
function configFromInput(config2) {
  var input = config2._i;
  if (isUndefined2(input)) {
    config2._d = new Date(hooks.now());
  } else if (isDate2(input)) {
    config2._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config2);
  } else if (isArray2(input)) {
    config2._a = map(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config2);
  } else if (isObject2(input)) {
    configFromObject(config2);
  } else if (isNumber2(input)) {
    config2._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config2);
  }
}
function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
  var c = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject2(input) && isObjectEmpty(input) || isArray2(input) && input.length === 0) {
    input = void 0;
  }
  c._isAMomentObject = true;
  c._useUTC = c._isUTC = isUTC;
  c._l = locale2;
  c._i = input;
  c._f = format2;
  c._strict = strict;
  return createFromConfig(c);
}
function createLocal(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, false);
}
var prototypeMin = deprecate(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
var prototypeMax = deprecate(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
function pickBy(fn, moments) {
  var res, i;
  if (moments.length === 1 && isArray2(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i = 1; i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn](res)) {
      res = moments[i];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
var now = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m) {
  var key, unitHasDecimal = false, i, orderLen = ordering.length;
  for (key in m) {
    if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
      return false;
    }
  }
  for (i = 0; i < orderLen; ++i) {
    if (m[ordering[i]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration2) {
  var normalizedInput = normalizeObjectUnits(duration2), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
  minutes2 * 6e4 + // 1000 * 60
  hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array22, dontConvert) {
  var len = Math.min(array1.length, array22.length), lengthDiff = Math.abs(array1.length - array22.length), diffs = 0, i;
  for (i = 0; i < len; i++) {
    if (dontConvert && array1[i] !== array22[i] || !dontConvert && toInt(array1[i]) !== toInt(array22[i])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array4, config2) {
  config2._useUTC = true;
  config2._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string2) {
  var matches2 = (string2 || "").match(matcher), chunk, parts, minutes2;
  if (matches2 === null) {
    return null;
  }
  chunk = matches2[matches2.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m) {
  return -Math.round(m._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input - offset2, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined2(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c = {}, other;
  copyConfig(c, this);
  c = prepareConfig(c);
  if (c._a) {
    other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/;
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration2 = input, match = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration2 = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber2(input) || !isNaN(+input)) {
    duration2 = {};
    if (key) {
      duration2[key] = +input;
    } else {
      duration2.milliseconds = +input;
    }
  } else if (match = aspNetRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration2 = {
      y: 0,
      d: toInt(match[DATE]) * sign2,
      h: toInt(match[HOUR]) * sign2,
      m: toInt(match[MINUTE]) * sign2,
      s: toInt(match[SECOND]) * sign2,
      ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
      // the millisecond decimal point is included in the match
    };
  } else if (match = isoRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration2 = {
      y: parseIso(match[2], sign2),
      M: parseIso(match[3], sign2),
      w: parseIso(match[4], sign2),
      d: parseIso(match[5], sign2),
      h: parseIso(match[6], sign2),
      m: parseIso(match[7], sign2),
      s: parseIso(match[8], sign2)
    };
  } else if (duration2 == null) {
    duration2 = {};
  } else if (typeof duration2 === "object" && ("from" in duration2 || "to" in duration2)) {
    diffRes = momentsDifference(
      createLocal(duration2.from),
      createLocal(duration2.to)
    );
    duration2 = {};
    duration2.ms = diffRes.milliseconds;
    duration2.M = diffRes.months;
  }
  ret = new Duration(duration2);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base79, other) {
  var res = {};
  res.months = other.month() - base79.month() + (other.year() - base79.year()) * 12;
  if (base79.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base79.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base79, other) {
  var res;
  if (!(base79.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base79);
  if (base79.isBefore(other)) {
    res = positiveMomentsDifference(base79, other);
  } else {
    res = positiveMomentsDifference(other, base79);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name2) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name2,
        "moment()." + name2 + "(period, number) is deprecated. Please use moment()." + name2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration2, isAdding, updateOffset) {
  var milliseconds2 = duration2._milliseconds, days2 = absRound(duration2._days), months2 = absRound(duration2._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add = createAdder(1, "add");
var subtract = createAdder(-1, "subtract");
function isString2(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate2(input) || isString2(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i, property2, propertyLen = properties.length;
  for (i = 0; i < propertyLen; i += 1) {
    property2 = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property2);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray2(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber2(item) && isString2(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i, property2;
  for (i = 0; i < properties.length; i += 1) {
    property2 = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property2);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time2, formats2) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time2 = void 0;
      formats2 = void 0;
    } else if (isMomentInput(arguments[0])) {
      time2 = arguments[0];
      formats2 = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats2 = arguments[0];
      time2 = void 0;
    }
  }
  var now2 = time2 || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats2 && (isFunction2(formats2[format2]) ? formats2[format2].call(this, now2) : formats2[format2]);
  return this.format(
    output || this.localeData().calendar(format2, this, createLocal(now2))
  );
}
function clone() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a, b) {
  if (a.date() < b.date()) {
    return -monthDiff(b, a);
  }
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b - anchor < 0) {
    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString3() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
  if (m.year() < 0 || m.year() > 9999) {
    return formatMoment(
      m,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction2(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
    }
  }
  return formatMoment(
    m,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone2 = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone2 = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone2 + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time2, withoutSuffix) {
  if (this.isValid() && (isMoment(time2) && time2.isValid() || createLocal(time2).isValid())) {
    return createDuration({ to: this, from: time2 }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time2, withoutSuffix) {
  if (this.isValid() && (isMoment(time2) && time2.isValid() || createLocal(time2).isValid())) {
    return createDuration({ from: this, to: time2 }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  }
);
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3;
var MS_PER_MINUTE = 60 * MS_PER_SECOND;
var MS_PER_HOUR = 60 * MS_PER_MINUTE;
var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return new Date(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return new Date(y, m, d).valueOf();
  }
}
function utcStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y, m, d);
  }
}
function startOf(units) {
  var time2, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time2 = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time2 = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time2 = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time2 = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time2 = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time2 = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time2 = this._d.valueOf();
      time2 -= mod$1(
        time2 + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time2 = this._d.valueOf();
      time2 -= mod$1(time2, MS_PER_MINUTE);
      break;
    case "second":
      time2 = this._d.valueOf();
      time2 -= mod$1(time2, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time2);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time2, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time2 = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time2 = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time2 = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time2 = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time2 = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time2 = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time2 = this._d.valueOf();
      time2 += MS_PER_HOUR - mod$1(
        time2 + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time2 = this._d.valueOf();
      time2 += MS_PER_MINUTE - mod$1(time2, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time2 = this._d.valueOf();
      time2 += MS_PER_SECOND - mod$1(time2, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time2);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray2() {
  var m = this;
  return [
    m.year(),
    m.month(),
    m.date(),
    m.hour(),
    m.minute(),
    m.second(),
    m.millisecond()
  ];
}
function toObject() {
  var m = this;
  return {
    years: m.year(),
    months: m.month(),
    date: m.date(),
    hours: m.hours(),
    minutes: m.minutes(),
    seconds: m.seconds(),
    milliseconds: m.milliseconds()
  };
}
function toJSON2() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend2({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(input, array4, config2, token2) {
    var era = config2._locale.erasParse(input, token2, config2._strict);
    if (era) {
      getParsingFlags(config2).era = era;
    } else {
      getParsingFlags(config2).invalidEra = input;
    }
  }
);
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array4, config2, token2) {
  var match;
  if (config2._locale._eraYearOrdinalRegex) {
    match = input.match(config2._locale._eraYearOrdinalRegex);
  }
  if (config2._locale.eraYearOrdinalParse) {
    array4[YEAR] = config2._locale.eraYearOrdinalParse(input, match);
  } else {
    array4[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m, format2) {
  var i, l, date6, eras = this._eras || getLocale("en")._eras;
  for (i = 0, l = eras.length; i < l; ++i) {
    switch (typeof eras[i].since) {
      case "string":
        date6 = hooks(eras[i].since).startOf("day");
        eras[i].since = date6.valueOf();
        break;
    }
    switch (typeof eras[i].until) {
      case "undefined":
        eras[i].until = Infinity;
        break;
      case "string":
        date6 = hooks(eras[i].until).startOf("day").valueOf();
        eras[i].until = date6.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i, l, eras = this.eras(), name2, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i = 0, l = eras.length; i < l; ++i) {
    name2 = eras[i].name.toUpperCase();
    abbr = eras[i].abbr.toUpperCase();
    narrow = eras[i].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i];
          }
          break;
        case "NNNN":
          if (name2 === eraName) {
            return eras[i];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i];
          }
          break;
      }
    } else if ([name2, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].name;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].narrow;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].abbr;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i, l, dir, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    dir = eras[i].since <= eras[i].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
      return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    erasName = regexEscape(eras[i].name);
    erasAbbr = regexEscape(eras[i].abbr);
    erasNarrow = regexEscape(eras[i].narrow);
    namePieces.push(erasName);
    abbrPieces.push(erasAbbr);
    narrowPieces.push(erasNarrow);
    mixedPieces.push(erasName);
    mixedPieces.push(erasAbbr);
    mixedPieces.push(erasNarrow);
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(input, week, config2, token2) {
    week[token2.substr(0, 2)] = toInt(input);
  }
);
addWeekParseToken(["gg", "GG"], function(input, week, config2, token2) {
  week[token2] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.week(),
    this.weekday() + this.localeData()._week.dow,
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date6 = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date6.getUTCFullYear());
  this.month(date6.getUTCMonth());
  this.date(date6.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addRegexToken("Q", match1);
addParseToken("Q", function(input, array4) {
  array4[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addRegexToken("D", match1to2, match1to2NoLeadingZero);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array4) {
  array4[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array4, config2) {
  config2._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addRegexToken("m", match1to2, match1to2HasZero);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addRegexToken("s", match1to2, match1to2HasZero);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token;
var getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array4) {
  array4[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add;
proto.calendar = calendar$1;
proto.clone = clone;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray2;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON2;
proto.toString = toString3;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate(
  "dates accessor is deprecated. Use date instead.",
  getSetDayOfMonth
);
proto.months = deprecate(
  "months accessor is deprecated. Use month instead",
  getSetMonth
);
proto.years = deprecate(
  "years accessor is deprecated. Use year instead",
  getSetYear
);
proto.zone = deprecate(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  getSetZone
);
proto.isDSTShifted = deprecate(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  isDaylightSavingTimeShifted
);
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string2) {
  return string2;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1(format2, index2, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index2);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index2, field) {
  if (isNumber2(format2)) {
    index2 = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index2 != null) {
    return get$1(format2, index2, field, "month");
  }
  var i, out = [];
  for (i = 0; i < 12; i++) {
    out[i] = get$1(format2, i, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index2, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber2(format2)) {
      index2 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index2 = format2;
    localeSorted = false;
    if (isNumber2(format2)) {
      index2 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
  if (index2 != null) {
    return get$1(format2, (index2 + shift) % 7, field, "day");
  }
  for (i = 0; i < 7; i++) {
    out[i] = get$1(format2, (i + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index2) {
  return listMonthsImpl(format2, index2, "months");
}
function listMonthsShort(format2, index2) {
  return listMonthsImpl(format2, index2, "monthsShort");
}
function listWeekdays(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
    return number + output;
  }
});
hooks.lang = deprecate(
  "moment.lang is deprecated. Use moment.locale instead.",
  getSetGlobalLocale
);
hooks.langData = deprecate(
  "moment.langData is deprecated. Use moment.localeData instead.",
  getLocale
);
var mathAbs = Math.abs;
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration2, input, value, direction) {
  var other = createDuration(input, value);
  duration2._milliseconds += direction * other._milliseconds;
  duration2._days += direction * other._days;
  duration2._months += direction * other._months;
  return duration2._bubble();
}
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data.days = days2;
  data.months = months2;
  data.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms");
var asSeconds = makeAs("s");
var asMinutes = makeAs("m");
var asHours = makeAs("h");
var asDays = makeAs("d");
var asWeeks = makeAs("w");
var asMonths = makeAs("M");
var asQuarters = makeAs("Q");
var asYears = makeAs("y");
var valueOf$1 = asMilliseconds;
function clone$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name2) {
  return function() {
    return this.isValid() ? this._data[name2] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds");
var seconds = makeGetter("seconds");
var minutes = makeGetter("minutes");
var hours = makeGetter("hours");
var days = makeGetter("days");
var months = makeGetter("months");
var years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round = Math.round;
var thresholds = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function substituteTimeAgo(string2, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string2, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration2 = createDuration(posNegDuration).abs(), seconds2 = round(duration2.as("s")), minutes2 = round(duration2.as("m")), hours2 = round(duration2.as("h")), days2 = round(duration2.as("d")), months2 = round(duration2.as("M")), weeks2 = round(duration2.as("w")), years2 = round(duration2.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a[2] = withoutSuffix;
  a[3] = +posNegDuration > 0;
  a[4] = locale2;
  return substituteTimeAgo.apply(null, a);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign(x) {
  return (x > 0) - (x < 0) || +x;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  toISOString$1
);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array4, config2) {
  config2._d = new Date(parseFloat(input) * 1e3);
});
addParseToken("x", function(input, array4, config2) {
  config2._d = new Date(toInt(input));
});
hooks.version = "2.30.1";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate2;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
var moment_default = hooks;

// node_modules/@vueform/vueform/dist/index.mjs
function ownKeys$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$2(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != typeof i)
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toPropertyKey(t2) {
  var i = _toPrimitive(t2, "string");
  return "symbol" == typeof i ? i : i + "";
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _defineProperty$2(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var each$1 = { exports: {} };
function arrayEach$2(array4, iteratee) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (iteratee(array4[index2], index2, array4) === false) {
      break;
    }
  }
  return array4;
}
var _arrayEach = arrayEach$2;
function createBaseFor$1(fromRight) {
  return function(object9, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object9), props = keysFunc(object9), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object9;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$2 = createBaseFor();
var _baseFor = baseFor$2;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$8 = freeGlobal || freeSelf || Function("return this")();
var _root = root$8;
var root$7 = _root;
var Symbol$7 = root$7.Symbol;
var _Symbol = Symbol$7;
var Symbol$6 = _Symbol;
var objectProto$g = Object.prototype;
var hasOwnProperty$e = objectProto$g.hasOwnProperty;
var nativeObjectToString$1 = objectProto$g.toString;
var symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$e.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$f = Object.prototype;
var nativeObjectToString = objectProto$f.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$5 = _Symbol;
var getRawTag = _getRawTag;
var objectToString = _objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$7(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$7;
function isObjectLike$a(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$a;
var baseGetTag$6 = _baseGetTag;
var isObjectLike$9 = isObjectLike_1;
var argsTag$3 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$9(value) && baseGetTag$6(value) == argsTag$3;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments;
var isObjectLike$8 = isObjectLike_1;
var objectProto$e = Object.prototype;
var hasOwnProperty$d = objectProto$e.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable;
var isArguments$5 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$8(value) && hasOwnProperty$d.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$5;
var isArray$k = Array.isArray;
var isArray_1 = isArray$k;
var isBuffer$6 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module3, exports2) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module3 && !module3.nodeType && module3;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer3 = nativeIsBuffer || stubFalse2;
  module3.exports = isBuffer3;
})(isBuffer$6, isBuffer$6.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$4(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$4;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$3;
var baseGetTag$5 = _baseGetTag;
var isLength$2 = isLength_1;
var isObjectLike$7 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
var arrayTag$2 = "[object Array]";
var boolTag$3 = "[object Boolean]";
var dateTag$3 = "[object Date]";
var errorTag$2 = "[object Error]";
var funcTag$2 = "[object Function]";
var mapTag$6 = "[object Map]";
var numberTag$3 = "[object Number]";
var objectTag$4 = "[object Object]";
var regexpTag$3 = "[object RegExp]";
var setTag$6 = "[object Set]";
var stringTag$4 = "[object String]";
var weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]";
var dataViewTag$4 = "[object DataView]";
var float32Tag$2 = "[object Float32Array]";
var float64Tag$2 = "[object Float64Array]";
var int8Tag$2 = "[object Int8Array]";
var int16Tag$2 = "[object Int16Array]";
var int32Tag$2 = "[object Int32Array]";
var uint8Tag$2 = "[object Uint8Array]";
var uint8ClampedTag$2 = "[object Uint8ClampedArray]";
var uint16Tag$2 = "[object Uint16Array]";
var uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$7(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$5(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$5(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$5;
var _nodeUtil = { exports: {} };
(function(module3, exports2) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module3 && !module3.nodeType && module3;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module3.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray;
var baseUnary$4 = _baseUnary;
var nodeUtil$2 = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$4 = nodeIsTypedArray ? baseUnary$4(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$4;
var baseTimes = _baseTimes;
var isArguments$4 = isArguments_1;
var isArray$j = isArray_1;
var isBuffer$5 = isBuffer$6.exports;
var isIndex$3 = _isIndex;
var isTypedArray$3 = isTypedArray_1;
var objectProto$d = Object.prototype;
var hasOwnProperty$c = objectProto$d.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$j(value), isArg = !isArr && isArguments$4(value), isBuff = !isArr && !isArg && isBuffer$5(value), isType = !isArr && !isArg && !isBuff && isTypedArray$3(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$c.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$3(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$c = Object.prototype;
function isPrototype$4(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$c;
  return value === proto2;
}
var _isPrototype = isPrototype$4;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$3 = _isPrototype;
var nativeKeys = _nativeKeys;
var objectProto$b = Object.prototype;
var hasOwnProperty$b = objectProto$b.hasOwnProperty;
function baseKeys$2(object9) {
  if (!isPrototype$3(object9)) {
    return nativeKeys(object9);
  }
  var result = [];
  for (var key in Object(object9)) {
    if (hasOwnProperty$b.call(object9, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$2;
function isObject$b(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$b;
var baseGetTag$4 = _baseGetTag;
var isObject$a = isObject_1;
var asyncTag = "[object AsyncFunction]";
var funcTag$1 = "[object Function]";
var genTag$1 = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction$4(value) {
  if (!isObject$a(value)) {
    return false;
  }
  var tag = baseGetTag$4(value);
  return tag == funcTag$1 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$4;
var isFunction$3 = isFunction_1;
var isLength$1 = isLength_1;
function isArrayLike$9(value) {
  return value != null && isLength$1(value.length) && !isFunction$3(value);
}
var isArrayLike_1 = isArrayLike$9;
var arrayLikeKeys$1 = _arrayLikeKeys;
var baseKeys$1 = _baseKeys;
var isArrayLike$8 = isArrayLike_1;
function keys$7(object9) {
  return isArrayLike$8(object9) ? arrayLikeKeys$1(object9) : baseKeys$1(object9);
}
var keys_1 = keys$7;
var baseFor$1 = _baseFor;
var keys$6 = keys_1;
function baseForOwn$2(object9, iteratee) {
  return object9 && baseFor$1(object9, iteratee, keys$6);
}
var _baseForOwn = baseForOwn$2;
var isArrayLike$7 = isArrayLike_1;
function createBaseEach$1(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$7(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach$1;
var baseForOwn$1 = _baseForOwn;
var createBaseEach = _createBaseEach;
var baseEach$5 = createBaseEach(baseForOwn$1);
var _baseEach = baseEach$5;
function identity$5(value) {
  return value;
}
var identity_1 = identity$5;
var identity$4 = identity_1;
function castFunction$1(value) {
  return typeof value == "function" ? value : identity$4;
}
var _castFunction = castFunction$1;
var arrayEach$1 = _arrayEach;
var baseEach$4 = _baseEach;
var castFunction = _castFunction;
var isArray$i = isArray_1;
function forEach2(collection, iteratee) {
  var func = isArray$i(collection) ? arrayEach$1 : baseEach$4;
  return func(collection, castFunction(iteratee));
}
var forEach_1 = forEach2;
(function(module3) {
  module3.exports = forEach_1;
})(each$1);
var each = getDefaultExportFromCjs(each$1.exports);
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$5(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$5;
var eq$4 = eq_1;
function assocIndexOf$4(array4, key) {
  var length = array4.length;
  while (length--) {
    if (eq$4(array4[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear;
var listCacheDelete = _listCacheDelete;
var listCacheGet = _listCacheGet;
var listCacheHas = _listCacheHas;
var listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var root$6 = _root;
var coreJsData$1 = root$6["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1;
var isMasked = _isMasked;
var isObject$9 = isObject_1;
var toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype;
var objectProto$a = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$a = objectProto$a.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$9(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object9, key) {
  return object9 == null ? void 0 : object9[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative;
var getValue = _getValue;
function getNative$7(object9, key) {
  var value = getValue(object9, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var root$5 = _root;
var Map$4 = getNative$6(root$5, "Map");
var _Map = Map$4;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$9 = Object.prototype;
var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$8 = Object.prototype;
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear;
var hashDelete = _hashDelete;
var hashGet = _hashGet;
var hashHas = _hashHas;
var hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash;
var ListCache$2 = _ListCache;
var Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map3, key) {
  var data = map3.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear;
var mapCacheDelete = _mapCacheDelete;
var mapCacheGet = _mapCacheGet;
var mapCacheHas = _mapCacheHas;
var mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var ListCache$1 = _ListCache;
var Map$2 = _Map;
var MapCache$2 = _MapCache;
var LARGE_ARRAY_SIZE$2 = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$2(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache;
var stackClear = _stackClear;
var stackDelete = _stackDelete;
var stackGet = _stackGet;
var stackHas = _stackHas;
var stackSet = _stackSet;
function Stack$4(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$4.prototype.clear = stackClear;
Stack$4.prototype["delete"] = stackDelete;
Stack$4.prototype.get = stackGet;
Stack$4.prototype.has = stackHas;
Stack$4.prototype.set = stackSet;
var _Stack = Stack$4;
var getNative$4 = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty$1 = defineProperty$2;
var defineProperty$1 = _defineProperty$1;
function baseAssignValue$4(object9, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object9, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object9[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$4;
var baseAssignValue$3 = _baseAssignValue;
var eq$3 = eq_1;
function assignMergeValue$2(object9, key, value) {
  if (value !== void 0 && !eq$3(object9[key], value) || value === void 0 && !(key in object9)) {
    baseAssignValue$3(object9, key, value);
  }
}
var _assignMergeValue = assignMergeValue$2;
var _cloneBuffer = { exports: {} };
(function(module3, exports2) {
  var root2 = _root;
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module3 && !module3.nodeType && module3;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module3.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var root$4 = _root;
var Uint8Array$2 = root$4.Uint8Array;
var _Uint8Array = Uint8Array$2;
var Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$2;
function copyArray$3(source, array4) {
  var index2 = -1, length = source.length;
  array4 || (array4 = Array(length));
  while (++index2 < length) {
    array4[index2] = source[index2];
  }
  return array4;
}
var _copyArray = copyArray$3;
var isObject$8 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = /* @__PURE__ */ function() {
  function object9() {
  }
  return function(proto2) {
    if (!isObject$8(proto2)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto2);
    }
    object9.prototype = proto2;
    var result = new object9();
    object9.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
var overArg = _overArg;
var getPrototype$3 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var baseCreate = _baseCreate;
var getPrototype$2 = _getPrototype;
var isPrototype$2 = _isPrototype;
function initCloneObject$2(object9) {
  return typeof object9.constructor == "function" && !isPrototype$2(object9) ? baseCreate(getPrototype$2(object9)) : {};
}
var _initCloneObject = initCloneObject$2;
var isArrayLike$6 = isArrayLike_1;
var isObjectLike$6 = isObjectLike_1;
function isArrayLikeObject$4(value) {
  return isObjectLike$6(value) && isArrayLike$6(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$4;
var baseGetTag$3 = _baseGetTag;
var getPrototype$1 = _getPrototype;
var isObjectLike$5 = isObjectLike_1;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype;
var objectProto$7 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$2(value) {
  if (!isObjectLike$5(value) || baseGetTag$3(value) != objectTag$3) {
    return false;
  }
  var proto2 = getPrototype$1(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty$7.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$2;
function safeGet$2(object9, key) {
  if (key === "constructor" && typeof object9[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object9[key];
}
var _safeGet = safeGet$2;
var baseAssignValue$2 = _baseAssignValue;
var eq$2 = eq_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function assignValue$3(object9, key, value) {
  var objValue = object9[key];
  if (!(hasOwnProperty$6.call(object9, key) && eq$2(objValue, value)) || value === void 0 && !(key in object9)) {
    baseAssignValue$2(object9, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue;
var baseAssignValue$1 = _baseAssignValue;
function copyObject$6(source, props, object9, customizer) {
  var isNew = !object9;
  object9 || (object9 = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object9[key], source[key], key, object9, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$1(object9, key, newValue);
    } else {
      assignValue$2(object9, key, newValue);
    }
  }
  return object9;
}
var _copyObject = copyObject$6;
function nativeKeysIn$1(object9) {
  var result = [];
  if (object9 != null) {
    for (var key in Object(object9)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$7 = isObject_1;
var isPrototype$1 = _isPrototype;
var nativeKeysIn = _nativeKeysIn;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function baseKeysIn$1(object9) {
  if (!isObject$7(object9)) {
    return nativeKeysIn(object9);
  }
  var isProto = isPrototype$1(object9), result = [];
  for (var key in object9) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object9, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys;
var baseKeysIn = _baseKeysIn;
var isArrayLike$5 = isArrayLike_1;
function keysIn$5(object9) {
  return isArrayLike$5(object9) ? arrayLikeKeys(object9, true) : baseKeysIn(object9);
}
var keysIn_1 = keysIn$5;
var copyObject$5 = _copyObject;
var keysIn$4 = keysIn_1;
function toPlainObject$1(value) {
  return copyObject$5(value, keysIn$4(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue;
var cloneBuffer$1 = _cloneBuffer.exports;
var cloneTypedArray$1 = _cloneTypedArray;
var copyArray$2 = _copyArray;
var initCloneObject$1 = _initCloneObject;
var isArguments$3 = isArguments_1;
var isArray$h = isArray_1;
var isArrayLikeObject$3 = isArrayLikeObject_1;
var isBuffer$4 = isBuffer$6.exports;
var isFunction$1 = isFunction_1;
var isObject$6 = isObject_1;
var isPlainObject$1 = isPlainObject_1;
var isTypedArray$2 = isTypedArray_1;
var safeGet$1 = _safeGet;
var toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object9, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object9, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object9, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object9, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$h(srcValue), isBuff = !isArr && isBuffer$4(srcValue), isTyped = !isArr && !isBuff && isTypedArray$2(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$h(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject$3(objValue)) {
        newValue = copyArray$2(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer$1(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray$1(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject$1(srcValue) || isArguments$3(srcValue)) {
      newValue = objValue;
      if (isArguments$3(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$6(objValue) || isFunction$1(objValue)) {
        newValue = initCloneObject$1(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object9, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack$3 = _Stack;
var assignMergeValue = _assignMergeValue;
var baseFor = _baseFor;
var baseMergeDeep = _baseMergeDeep;
var isObject$5 = isObject_1;
var keysIn$3 = keysIn_1;
var safeGet = _safeGet;
function baseMerge$1(object9, source, srcIndex, customizer, stack) {
  if (object9 === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack$3());
    if (isObject$5(srcValue)) {
      baseMergeDeep(object9, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object9, key), srcValue, key + "", object9, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object9, key, newValue);
    }
  }, keysIn$3);
}
var _baseMerge = baseMerge$1;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax$3 = Math.max;
function overRest$2(func, start, transform) {
  start = nativeMax$3(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$3(args.length - start, 0), array4 = Array(length);
    while (++index2 < length) {
      array4[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform(array4);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$2;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var constant = constant_1;
var defineProperty = _defineProperty$1;
var identity$3 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$3 : function(func, string2) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string2),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString;
var shortOut = _shortOut;
var setToString$2 = shortOut(baseSetToString);
var _setToString = setToString$2;
var identity$2 = identity_1;
var overRest$1 = _overRest;
var setToString$1 = _setToString;
function baseRest$5(func, start) {
  return setToString$1(overRest$1(func, start, identity$2), func + "");
}
var _baseRest = baseRest$5;
var eq$1 = eq_1;
var isArrayLike$4 = isArrayLike_1;
var isIndex$2 = _isIndex;
var isObject$4 = isObject_1;
function isIterateeCall$3(value, index2, object9) {
  if (!isObject$4(object9)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike$4(object9) && isIndex$2(index2, object9.length) : type == "string" && index2 in object9) {
    return eq$1(object9[index2], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$3;
var baseRest$4 = _baseRest;
var isIterateeCall$2 = _isIterateeCall;
function createAssigner$1(assigner) {
  return baseRest$4(function(object9, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall$2(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object9 = Object(object9);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object9, source, index2, customizer);
      }
    }
    return object9;
  });
}
var _createAssigner = createAssigner$1;
var baseMerge = _baseMerge;
var createAssigner = _createAssigner;
var merge2 = createAssigner(function(object9, source, srcIndex) {
  baseMerge(object9, source, srcIndex);
});
var merge_1 = merge2;
function arraySome$2(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (predicate(array4[index2], index2, array4)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache$1 = _MapCache;
var setCacheAdd = _setCacheAdd;
var setCacheHas = _setCacheHas;
function SetCache$3(values2) {
  var index2 = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache$1();
  while (++index2 < length) {
    this.add(values2[index2]);
  }
}
SetCache$3.prototype.add = SetCache$3.prototype.push = setCacheAdd;
SetCache$3.prototype.has = setCacheHas;
var _SetCache = SetCache$3;
function cacheHas$3(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$3;
var SetCache$2 = _SetCache;
var arraySome$1 = _arraySome;
var cacheHas$2 = _cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1;
var COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(array4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array4.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array4);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array4;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache$2() : void 0;
  stack.set(array4, other);
  stack.set(other, array4);
  while (++index2 < arrLength) {
    var arrValue = array4[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack) : customizer(arrValue, othValue, index2, array4, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome$1(other, function(othValue2, othIndex) {
        if (!cacheHas$2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array4);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
function mapToArray$1(map3) {
  var index2 = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$3(set3) {
  var index2 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$3;
var Symbol$4 = _Symbol;
var Uint8Array2 = _Uint8Array;
var eq = eq_1;
var equalArrays$1 = _equalArrays;
var mapToArray = _mapToArray;
var setToArray$2 = _setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1;
var COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$2 = "[object Boolean]";
var dateTag$2 = "[object Date]";
var errorTag$1 = "[object Error]";
var mapTag$5 = "[object Map]";
var numberTag$2 = "[object Number]";
var regexpTag$2 = "[object RegExp]";
var setTag$5 = "[object Set]";
var stringTag$3 = "[object String]";
var symbolTag$3 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]";
var dataViewTag$3 = "[object DataView]";
var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0;
var symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function equalByTag$1(object9, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$3:
      if (object9.byteLength != other.byteLength || object9.byteOffset != other.byteOffset) {
        return false;
      }
      object9 = object9.buffer;
      other = other.buffer;
    case arrayBufferTag$2:
      if (object9.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object9), new Uint8Array2(other))) {
        return false;
      }
      return true;
    case boolTag$2:
    case dateTag$2:
    case numberTag$2:
      return eq(+object9, +other);
    case errorTag$1:
      return object9.name == other.name && object9.message == other.message;
    case regexpTag$2:
    case stringTag$3:
      return object9 == other + "";
    case mapTag$5:
      var convert = mapToArray;
    case setTag$5:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray$2);
      if (object9.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object9);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object9, other);
      var result = equalArrays$1(convert(object9), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object9);
      return result;
    case symbolTag$3:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object9) == symbolValueOf$1.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$4(array4, values2) {
  var index2 = -1, length = values2.length, offset2 = array4.length;
  while (++index2 < length) {
    array4[offset2 + index2] = values2[index2];
  }
  return array4;
}
var _arrayPush = arrayPush$4;
var arrayPush$3 = _arrayPush;
var isArray$g = isArray_1;
function baseGetAllKeys$2(object9, keysFunc, symbolsFunc) {
  var result = keysFunc(object9);
  return isArray$g(object9) ? result : arrayPush$3(result, symbolsFunc(object9));
}
var _baseGetAllKeys = baseGetAllKeys$2;
function arrayFilter$2(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array4[index2];
    if (predicate(value, index2, array4)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$2;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter$1 = _arrayFilter;
var stubArray$1 = stubArray_1;
var objectProto$4 = Object.prototype;
var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object9) {
  if (object9 == null) {
    return [];
  }
  object9 = Object(object9);
  return arrayFilter$1(nativeGetSymbols$1(object9), function(symbol) {
    return propertyIsEnumerable.call(object9, symbol);
  });
};
var _getSymbols = getSymbols$3;
var baseGetAllKeys$1 = _baseGetAllKeys;
var getSymbols$2 = _getSymbols;
var keys$5 = keys_1;
function getAllKeys$2(object9) {
  return baseGetAllKeys$1(object9, keys$5, getSymbols$2);
}
var _getAllKeys = getAllKeys$2;
var getAllKeys$1 = _getAllKeys;
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$3 = Object.prototype;
var hasOwnProperty$4 = objectProto$3.hasOwnProperty;
function equalObjects$1(object9, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys$1(object9), objLength = objProps.length, othProps = getAllKeys$1(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object9);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object9;
  }
  var result = true;
  stack.set(object9, other);
  stack.set(other, object9);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object9[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object9, stack) : customizer(objValue, othValue, key, object9, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object9.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object9 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object9);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$3 = _getNative;
var root$3 = _root;
var DataView$1 = getNative$3(root$3, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative;
var root$2 = _root;
var Promise$2 = getNative$2(root$2, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative;
var root$1 = _root;
var Set$2 = getNative$1(root$1, "Set");
var _Set = Set$2;
var getNative = _getNative;
var root = _root;
var WeakMap$1 = getNative(root, "WeakMap");
var _WeakMap = WeakMap$1;
var DataView = _DataView;
var Map$1 = _Map;
var Promise$1 = _Promise;
var Set$1 = _Set;
var WeakMap = _WeakMap;
var baseGetTag$2 = _baseGetTag;
var toSource = _toSource;
var mapTag$4 = "[object Map]";
var objectTag$2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag$4 = "[object Set]";
var weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map$1);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set$1);
var weakMapCtorString = toSource(WeakMap);
var getTag$5 = baseGetTag$2;
if (DataView && getTag$5(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$5(new Map$1()) != mapTag$4 || Promise$1 && getTag$5(Promise$1.resolve()) != promiseTag || Set$1 && getTag$5(new Set$1()) != setTag$4 || WeakMap && getTag$5(new WeakMap()) != weakMapTag$1) {
  getTag$5 = function(value) {
    var result = baseGetTag$2(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$4;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$4;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$5;
var Stack$2 = _Stack;
var equalArrays = _equalArrays;
var equalByTag = _equalByTag;
var equalObjects = _equalObjects;
var getTag$4 = _getTag;
var isArray$f = isArray_1;
var isBuffer$3 = isBuffer$6.exports;
var isTypedArray$1 = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag$1 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var objectTag$1 = "[object Object]";
var objectProto$2 = Object.prototype;
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
function baseIsEqualDeep$1(object9, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$f(object9), othIsArr = isArray$f(other), objTag = objIsArr ? arrayTag$1 : getTag$4(object9), othTag = othIsArr ? arrayTag$1 : getTag$4(other);
  objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
  othTag = othTag == argsTag$1 ? objectTag$1 : othTag;
  var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$3(object9)) {
    if (!isBuffer$3(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$2());
    return objIsArr || isTypedArray$1(object9) ? equalArrays(object9, other, bitmask, customizer, equalFunc, stack) : equalByTag(object9, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$3.call(object9, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$3.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object9.value() : object9, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$2());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$2());
  return equalObjects(object9, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep;
var isObjectLike$4 = isObjectLike_1;
function baseIsEqual$3(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$4(value) && !isObjectLike$4(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);
}
var _baseIsEqual = baseIsEqual$3;
var Stack$1 = _Stack;
var baseIsEqual$2 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1;
var COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(object9, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object9 == null) {
    return !length;
  }
  object9 = Object(object9);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object9[data[0]] : !(data[0] in object9)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object9[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object9)) {
        return false;
      }
    } else {
      var stack = new Stack$1();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object9, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject$3 = isObject_1;
function isStrictComparable$2(value) {
  return value === value && !isObject$3(value);
}
var _isStrictComparable = isStrictComparable$2;
var isStrictComparable$1 = _isStrictComparable;
var keys$4 = keys_1;
function getMatchData$1(object9) {
  var result = keys$4(object9), length = result.length;
  while (length--) {
    var key = result[length], value = object9[key];
    result[length] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(key, srcValue) {
  return function(object9) {
    if (object9 == null) {
      return false;
    }
    return object9[key] === srcValue && (srcValue !== void 0 || key in Object(object9));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2;
var baseIsMatch = _baseIsMatch;
var getMatchData = _getMatchData;
var matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object9) {
    return object9 === source || baseIsMatch(object9, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
var baseGetTag$1 = _baseGetTag;
var isObjectLike$3 = isObjectLike_1;
var symbolTag$2 = "[object Symbol]";
function isSymbol$5(value) {
  return typeof value == "symbol" || isObjectLike$3(value) && baseGetTag$1(value) == symbolTag$2;
}
var isSymbol_1 = isSymbol$5;
var isArray$e = isArray_1;
var isSymbol$4 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey$3(value, object9) {
  if (isArray$e(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$4(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object9 != null && value in Object(object9);
}
var _isKey = isKey$3;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap$6(array4, iteratee) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array4[index2], index2, array4);
  }
  return result;
}
var _arrayMap = arrayMap$6;
var Symbol$3 = _Symbol;
var arrayMap$5 = _arrayMap;
var isArray$d = isArray_1;
var isSymbol$3 = isSymbol_1;
var INFINITY$4 = 1 / 0;
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0;
var symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString$4(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$d(value)) {
    return arrayMap$5(value, baseToString$4) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$4 ? "-0" : result;
}
var _baseToString = baseToString$4;
var baseToString$3 = _baseToString;
function toString$9(value) {
  return value == null ? "" : baseToString$3(value);
}
var toString_1 = toString$9;
var isArray$c = isArray_1;
var isKey$2 = _isKey;
var stringToPath = _stringToPath;
var toString$8 = toString_1;
function castPath$6(value, object9) {
  if (isArray$c(value)) {
    return value;
  }
  return isKey$2(value, object9) ? [value] : stringToPath(toString$8(value));
}
var _castPath = castPath$6;
var isSymbol$2 = isSymbol_1;
var INFINITY$3 = 1 / 0;
function toKey$6(value) {
  if (typeof value == "string" || isSymbol$2(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
}
var _toKey = toKey$6;
var castPath$5 = _castPath;
var toKey$5 = _toKey;
function baseGet$5(object9, path) {
  path = castPath$5(path, object9);
  var index2 = 0, length = path.length;
  while (object9 != null && index2 < length) {
    object9 = object9[toKey$5(path[index2++])];
  }
  return index2 && index2 == length ? object9 : void 0;
}
var _baseGet = baseGet$5;
var baseGet$4 = _baseGet;
function get$12(object9, path, defaultValue) {
  var result = object9 == null ? void 0 : baseGet$4(object9, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$12;
function baseHasIn$1(object9, key) {
  return object9 != null && key in Object(object9);
}
var _baseHasIn = baseHasIn$1;
var castPath$4 = _castPath;
var isArguments$2 = isArguments_1;
var isArray$b = isArray_1;
var isIndex$1 = _isIndex;
var isLength = isLength_1;
var toKey$4 = _toKey;
function hasPath$1(object9, path, hasFunc) {
  path = castPath$4(path, object9);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = toKey$4(path[index2]);
    if (!(result = object9 != null && hasFunc(object9, key))) {
      break;
    }
    object9 = object9[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object9 == null ? 0 : object9.length;
  return !!length && isLength(length) && isIndex$1(key, length) && (isArray$b(object9) || isArguments$2(object9));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn;
var hasPath = _hasPath;
function hasIn$2(object9, path) {
  return object9 != null && hasPath(object9, path, baseHasIn);
}
var hasIn_1 = hasIn$2;
var baseIsEqual$1 = _baseIsEqual;
var get2 = get_1;
var hasIn$1 = hasIn_1;
var isKey$1 = _isKey;
var isStrictComparable = _isStrictComparable;
var matchesStrictComparable = _matchesStrictComparable;
var toKey$3 = _toKey;
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(path, srcValue) {
  if (isKey$1(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$3(path), srcValue);
  }
  return function(object9) {
    var objValue = get2(object9, path);
    return objValue === void 0 && objValue === srcValue ? hasIn$1(object9, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function baseProperty$1(key) {
  return function(object9) {
    return object9 == null ? void 0 : object9[key];
  };
}
var _baseProperty = baseProperty$1;
var baseGet$3 = _baseGet;
function basePropertyDeep$1(path) {
  return function(object9) {
    return baseGet$3(object9, path);
  };
}
var _basePropertyDeep = basePropertyDeep$1;
var baseProperty = _baseProperty;
var basePropertyDeep = _basePropertyDeep;
var isKey = _isKey;
var toKey$2 = _toKey;
function property$1(path) {
  return isKey(path) ? baseProperty(toKey$2(path)) : basePropertyDeep(path);
}
var property_1 = property$1;
var baseMatches = _baseMatches;
var baseMatchesProperty = _baseMatchesProperty;
var identity$1 = identity_1;
var isArray$a = isArray_1;
var property = property_1;
function baseIteratee$9(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$1;
  }
  if (typeof value == "object") {
    return isArray$a(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var _baseIteratee = baseIteratee$9;
var baseEach$3 = _baseEach;
function baseSome$1(collection, predicate) {
  var result;
  baseEach$3(collection, function(value, index2, collection2) {
    result = predicate(value, index2, collection2);
    return !result;
  });
  return !!result;
}
var _baseSome = baseSome$1;
var arraySome = _arraySome;
var baseIteratee$8 = _baseIteratee;
var baseSome = _baseSome;
var isArray$9 = isArray_1;
var isIterateeCall$1 = _isIterateeCall;
function some2(collection, predicate, guard) {
  var func = isArray$9(collection) ? arraySome : baseSome;
  if (guard && isIterateeCall$1(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee$8(predicate));
}
var some_1 = some2;
var baseKeys = _baseKeys;
var getTag$3 = _getTag;
var isArguments$1 = isArguments_1;
var isArray$8 = isArray_1;
var isArrayLike$3 = isArrayLike_1;
var isBuffer$2 = isBuffer$6.exports;
var isPrototype = _isPrototype;
var isTypedArray2 = isTypedArray_1;
var mapTag$3 = "[object Map]";
var setTag$3 = "[object Set]";
var objectProto$1 = Object.prototype;
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike$3(value) && (isArray$8(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer$2(value) || isTypedArray2(value) || isArguments$1(value))) {
    return !value.length;
  }
  var tag = getTag$3(value);
  if (tag == mapTag$3 || tag == setTag$3) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty$2.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_1 = isEmpty;
function baseSlice$2(array4, start, end) {
  var index2 = -1, length = array4.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array4[index2 + start];
  }
  return result;
}
var _baseSlice = baseSlice$2;
var baseSlice$1 = _baseSlice;
function castSlice$2(array4, start, end) {
  var length = array4.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array4 : baseSlice$1(array4, start, end);
}
var _castSlice = castSlice$2;
var rsAstralRange$2 = "\\ud800-\\udfff";
var rsComboMarksRange$3 = "\\u0300-\\u036f";
var reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$3 = "\\u20d0-\\u20ff";
var rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;
var rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsZWJ$2 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
function hasUnicode$2(string2) {
  return reHasUnicode.test(string2);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string2) {
  return string2.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange$1 = "\\ud800-\\udfff";
var rsComboMarksRange$2 = "\\u0300-\\u036f";
var reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$2 = "\\u20d0-\\u20ff";
var rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
var rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange$1 + "]";
var rsCombo$2 = "[" + rsComboRange$2 + "]";
var rsFitz$1 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")";
var rsNonAstral$1 = "[^" + rsAstralRange$1 + "]";
var rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ$1 = "\\u200d";
var reOptMod$1 = rsModifier$1 + "?";
var rsOptVar$1 = "[" + rsVarRange$1 + "]?";
var rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*";
var rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1;
var rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
function unicodeToArray$1(string2) {
  return string2.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray;
var hasUnicode$1 = _hasUnicode;
var unicodeToArray = _unicodeToArray;
function stringToArray$2(string2) {
  return hasUnicode$1(string2) ? unicodeToArray(string2) : asciiToArray(string2);
}
var _stringToArray = stringToArray$2;
var castSlice$1 = _castSlice;
var hasUnicode = _hasUnicode;
var stringToArray$1 = _stringToArray;
var toString$7 = toString_1;
function createCaseFirst$2(methodName) {
  return function(string2) {
    string2 = toString$7(string2);
    var strSymbols = hasUnicode(string2) ? stringToArray$1(string2) : void 0;
    var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
    var trailing = strSymbols ? castSlice$1(strSymbols, 1).join("") : string2.slice(1);
    return chr[methodName]() + trailing;
  };
}
var _createCaseFirst = createCaseFirst$2;
var createCaseFirst$1 = _createCaseFirst;
var upperFirst$1 = createCaseFirst$1("toUpperCase");
var upperFirst_1 = upperFirst$1;
var baseEach$2 = _baseEach;
function baseFilter$1(collection, predicate) {
  var result = [];
  baseEach$2(collection, function(value, index2, collection2) {
    if (predicate(value, index2, collection2)) {
      result.push(value);
    }
  });
  return result;
}
var _baseFilter = baseFilter$1;
var arrayFilter = _arrayFilter;
var baseFilter = _baseFilter;
var baseIteratee$7 = _baseIteratee;
var isArray$7 = isArray_1;
function filter2(collection, predicate) {
  var func = isArray$7(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee$7(predicate));
}
var filter_1 = filter2;
var copyObject$4 = _copyObject;
var keys$3 = keys_1;
function baseAssign$1(object9, source) {
  return object9 && copyObject$4(source, keys$3(source), object9);
}
var _baseAssign = baseAssign$1;
var copyObject$3 = _copyObject;
var keysIn$2 = keysIn_1;
function baseAssignIn$1(object9, source) {
  return object9 && copyObject$3(source, keysIn$2(source), object9);
}
var _baseAssignIn = baseAssignIn$1;
var copyObject$2 = _copyObject;
var getSymbols$1 = _getSymbols;
function copySymbols$1(source, object9) {
  return copyObject$2(source, getSymbols$1(source), object9);
}
var _copySymbols = copySymbols$1;
var arrayPush$2 = _arrayPush;
var getPrototype = _getPrototype;
var getSymbols = _getSymbols;
var stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object9) {
  var result = [];
  while (object9) {
    arrayPush$2(result, getSymbols(object9));
    object9 = getPrototype(object9);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$1 = _copyObject;
var getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object9) {
  return copyObject$1(source, getSymbolsIn$1(source), object9);
}
var _copySymbolsIn = copySymbolsIn$1;
var baseGetAllKeys = _baseGetAllKeys;
var getSymbolsIn = _getSymbolsIn;
var keysIn$1 = keysIn_1;
function getAllKeysIn$2(object9) {
  return baseGetAllKeys(object9, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$2;
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function initCloneArray$1(array4) {
  var length = array4.length, result = new array4.constructor(length);
  if (length && typeof array4[0] == "string" && hasOwnProperty$1.call(array4, "index")) {
    result.index = array4.index;
    result.input = array4.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$2 = _Symbol;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer = _cloneArrayBuffer;
var cloneDataView = _cloneDataView;
var cloneRegExp = _cloneRegExp;
var cloneSymbol = _cloneSymbol;
var cloneTypedArray = _cloneTypedArray;
var boolTag$1 = "[object Boolean]";
var dateTag$1 = "[object Date]";
var mapTag$2 = "[object Map]";
var numberTag$1 = "[object Number]";
var regexpTag$1 = "[object RegExp]";
var setTag$2 = "[object Set]";
var stringTag$2 = "[object String]";
var symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$1 = "[object DataView]";
var float32Tag$1 = "[object Float32Array]";
var float64Tag$1 = "[object Float64Array]";
var int8Tag$1 = "[object Int8Array]";
var int16Tag$1 = "[object Int16Array]";
var int32Tag$1 = "[object Int32Array]";
var uint8Tag$1 = "[object Uint8Array]";
var uint8ClampedTag$1 = "[object Uint8ClampedArray]";
var uint16Tag$1 = "[object Uint16Array]";
var uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object9, tag, isDeep) {
  var Ctor = object9.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object9);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object9);
    case dataViewTag$1:
      return cloneDataView(object9, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object9, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$2:
      return new Ctor(object9);
    case regexpTag$1:
      return cloneRegExp(object9);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object9);
  }
}
var _initCloneByTag = initCloneByTag$1;
var getTag$2 = _getTag;
var isObjectLike$2 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$2(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap;
var baseUnary$3 = _baseUnary;
var nodeUtil$1 = _nodeUtil.exports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$1 = nodeIsMap ? baseUnary$3(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag;
var isObjectLike$1 = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$1(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet;
var baseUnary$2 = _baseUnary;
var nodeUtil = _nodeUtil.exports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$1 = nodeIsSet ? baseUnary$2(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack = _Stack;
var arrayEach = _arrayEach;
var assignValue$1 = _assignValue;
var baseAssign = _baseAssign;
var baseAssignIn = _baseAssignIn;
var cloneBuffer = _cloneBuffer.exports;
var copyArray$1 = _copyArray;
var copySymbols = _copySymbols;
var copySymbolsIn = _copySymbolsIn;
var getAllKeys = _getAllKeys;
var getAllKeysIn$1 = _getAllKeysIn;
var getTag = _getTag;
var initCloneArray = _initCloneArray;
var initCloneByTag = _initCloneByTag;
var initCloneObject = _initCloneObject;
var isArray$6 = isArray_1;
var isBuffer$1 = isBuffer$6.exports;
var isMap = isMap_1;
var isObject$2 = isObject_1;
var isSet = isSet_1;
var keys$2 = keys_1;
var keysIn = keysIn_1;
var CLONE_DEEP_FLAG$2 = 1;
var CLONE_FLAT_FLAG$1 = 2;
var CLONE_SYMBOLS_FLAG$3 = 4;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag$1 = "[object String]";
var symbolTag = "[object Symbol]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag$1] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$3(value, bitmask, customizer, key, object9, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$3;
  if (customizer) {
    result = object9 ? customizer(value, key, object9, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$2(value)) {
    return value;
  }
  var isArr = isArray$6(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray$1(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object9) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object9 ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$3(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$3(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$1 : getAllKeys : isFlat ? keysIn : keys$2;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$1(result, key2, baseClone$3(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$3;
var baseClone$2 = _baseClone;
var CLONE_DEEP_FLAG$1 = 1;
var CLONE_SYMBOLS_FLAG$2 = 4;
function cloneDeep(value) {
  return baseClone$2(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$2);
}
var cloneDeep_1 = cloneDeep;
var assignValue = _assignValue;
var castPath$3 = _castPath;
var isIndex = _isIndex;
var isObject$1 = isObject_1;
var toKey$1 = _toKey;
function baseSet$2(object9, path, value, customizer) {
  if (!isObject$1(object9)) {
    return object9;
  }
  path = castPath$3(path, object9);
  var index2 = -1, length = path.length, lastIndex = length - 1, nested = object9;
  while (nested != null && ++index2 < length) {
    var key = toKey$1(path[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object9;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$1(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object9;
}
var _baseSet = baseSet$2;
var baseSet$1 = _baseSet;
function set2(object9, path, value) {
  return object9 == null ? object9 : baseSet$1(object9, path, value);
}
var set_1 = set2;
var Symbol$1 = _Symbol;
var isArguments = isArguments_1;
var isArray$5 = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$5(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush$1 = _arrayPush;
var isFlattenable = _isFlattenable;
function baseFlatten$6(array4, depth, predicate, isStrict, result) {
  var index2 = -1, length = array4.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value = array4[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$6(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush$1(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$6;
function baseFindIndex$3(array4, predicate, fromIndex, fromRight) {
  var length = array4.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array4[index2], index2, array4)) {
      return index2;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex$3;
function baseIsNaN$1(value) {
  return value !== value;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(array4, value, fromIndex) {
  var index2 = fromIndex - 1, length = array4.length;
  while (++index2 < length) {
    if (array4[index2] === value) {
      return index2;
    }
  }
  return -1;
}
var _strictIndexOf = strictIndexOf$1;
var baseFindIndex$2 = _baseFindIndex;
var baseIsNaN = _baseIsNaN;
var strictIndexOf = _strictIndexOf;
function baseIndexOf$4(array4, value, fromIndex) {
  return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex$2(array4, baseIsNaN, fromIndex);
}
var _baseIndexOf = baseIndexOf$4;
var baseIndexOf$3 = _baseIndexOf;
function arrayIncludes$2(array4, value) {
  var length = array4 == null ? 0 : array4.length;
  return !!length && baseIndexOf$3(array4, value, 0) > -1;
}
var _arrayIncludes = arrayIncludes$2;
function arrayIncludesWith$2(array4, value, comparator) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (comparator(value, array4[index2])) {
      return true;
    }
  }
  return false;
}
var _arrayIncludesWith = arrayIncludesWith$2;
function noop$1() {
}
var noop_1 = noop$1;
var Set = _Set;
var noop2 = noop_1;
var setToArray$1 = _setToArray;
var INFINITY$2 = 1 / 0;
var createSet$1 = !(Set && 1 / setToArray$1(new Set([, -0]))[1] == INFINITY$2) ? noop2 : function(values2) {
  return new Set(values2);
};
var _createSet = createSet$1;
var SetCache$1 = _SetCache;
var arrayIncludes$1 = _arrayIncludes;
var arrayIncludesWith$1 = _arrayIncludesWith;
var cacheHas$1 = _cacheHas;
var createSet = _createSet;
var setToArray = _setToArray;
var LARGE_ARRAY_SIZE$1 = 200;
function baseUniq$1(array4, iteratee, comparator) {
  var index2 = -1, includes2 = arrayIncludes$1, length = array4.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith$1;
  } else if (length >= LARGE_ARRAY_SIZE$1) {
    var set3 = iteratee ? null : createSet(array4);
    if (set3) {
      return setToArray(set3);
    }
    isCommon = false;
    includes2 = cacheHas$1;
    seen = new SetCache$1();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length) {
      var value = array4[index2], computed2 = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed2 === computed2) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed2) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed2);
        }
        result.push(value);
      } else if (!includes2(seen, computed2, comparator)) {
        if (seen !== result) {
          seen.push(computed2);
        }
        result.push(value);
      }
    }
  return result;
}
var _baseUniq = baseUniq$1;
var baseFlatten$5 = _baseFlatten;
var baseRest$3 = _baseRest;
var baseUniq = _baseUniq;
var isArrayLikeObject$2 = isArrayLikeObject_1;
var union = baseRest$3(function(arrays) {
  return baseUniq(baseFlatten$5(arrays, 1, isArrayLikeObject$2, true));
});
var union_1 = union;
var baseFlatten$4 = _baseFlatten;
var INFINITY$1 = 1 / 0;
function flattenDeep(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? baseFlatten$4(array4, INFINITY$1) : [];
}
var flattenDeep_1 = flattenDeep;
var MERGE_KEYS = ["presets", "usePresets", "addClasses", "prependClasses", "removeClasses", "replaceClasses", "overrideClasses"];
var LOCALS_KEYS = ["addClass", "removeClass", "replaceClass", "overrideClass"];
var MergeClasses = class {
  constructor() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.options = options;
    if (this.shouldMergeTemplateClasses) {
      this.componentClasses = this.templateClasses;
      this.merge({
        overrideClasses: {
          [this.component]: this.themeClasses
        }
      });
    } else {
      this.componentClasses = this.templateClasses;
    }
    this.merge(this.config);
    each(options.merge, (merge3) => {
      this.merge(merge3);
    });
    this.merge(this.locals || this.component$.value, true);
    if (this.config.classHelpers && this.config.env !== "production") {
      this.merge({
        prependClasses: {
          [this.component]: this.getClassHelpers(this.componentClasses, [this.component])
        }
      });
    }
  }
  get classes() {
    return new Proxy(this.componentClasses, {
      get: (target, prop) => {
        if (typeof prop !== "string") {
          return target[prop];
        }
        return this.getDynamicClasses(target, prop);
      }
    });
  }
  get config() {
    return this.options.config || {};
  }
  get component() {
    return this.options.component;
  }
  get component$() {
    return this.options.component$;
  }
  get locals() {
    return this.options.locals;
  }
  get view() {
    return this.options.view;
  }
  get theme() {
    return this.options.theme;
  }
  get presets() {
    return this.config.presets;
  }
  get templates() {
    return this.options.templates || {};
  }
  get template() {
    return this.view && this.templates["".concat(this.component, "_").concat(this.view)] ? this.templates["".concat(this.component, "_").concat(this.view)] : this.templates[this.component] || {};
  }
  get themeClasses() {
    return cloneDeep_1(this.toArray(this.view && this.theme.classes["".concat(this.component, "_").concat(this.view)] ? this.theme.classes["".concat(this.component, "_").concat(this.view)] : this.theme.classes[this.component]));
  }
  get templateClasses() {
    return cloneDeep_1(this.toArray(this.defaultClasses));
  }
  get shouldMergeTemplateClasses() {
    var merge3 = typeof this.template.data === "function" && this.template.data().merge !== void 0 ? this.template.data().merge : this.component$.value.merge;
    return merge3 !== void 0 ? merge3 : false;
  }
  get defaultClasses() {
    return typeof this.template.data === "function" && this.template.data().defaultClasses ? this.template.data().defaultClasses : this.component$.value.defaultClasses;
  }
  get mainClass() {
    var defaultClasses = typeof this.template.data === "function" && this.template.data().defaultClasses ? this.template.data().defaultClasses : this.component$.value.defaultClasses;
    return Object.keys(defaultClasses)[0];
  }
  merge(merge3) {
    var locals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    each(this.pick(merge3, locals ? LOCALS_KEYS : MERGE_KEYS), (mergables, key) => {
      if (typeof mergables === "function") {
        mergables = mergables(this.component$.value.form$, "el$" in this.component$.value && typeof this.component$.value.el$ === "object" ? this.component$.value.el$ : void 0);
      }
      switch (key) {
        case "addClasses":
        case "prependClasses":
        case "overrideClasses":
          if (!mergables || mergables[this.component] === void 0) {
            return;
          }
          this.mergeComponentClasses(this.toArray(mergables[this.component]), key);
          break;
        case "removeClasses":
        case "replaceClasses":
          if (!mergables || mergables[this.component] === void 0) {
            return;
          }
          this.mergeComponentClasses(mergables[this.component], key);
          break;
        case "addClass":
        case "removeClass":
        case "replaceClass":
        case "overrideClass":
          if (!mergables) {
            return;
          }
          if (typeof mergables === "string" || Array.isArray(mergables)) {
            if (!Array.isArray(mergables)) {
              mergables = mergables.length > 0 ? mergables.split(" ") : [];
            }
            this.mergeComponentClasses({
              [this.mainClass]: mergables
            }, "".concat(key, "es"));
          } else if (key === "replaceClass") {
            this.mergeComponentClasses(mergables, "".concat(key, "es"));
          } else if (isPlainObject_1(mergables)) {
            this.mergeComponentClasses(this.toArray(mergables), "".concat(key, "es"));
          } else
            ;
          break;
        case "presets":
        case "usePresets":
          if (!Array.isArray(mergables)) {
            return;
          }
          each(mergables, (presetName) => {
            this.merge(this.presets[presetName]);
          });
          break;
      }
    });
  }
  mergeComponentClasses(componentClasses, key) {
    each(componentClasses, (classes, className) => {
      this[key](classes, [className]);
    });
  }
  addClasses(add2, levels) {
    var base79 = get_1(this.componentClasses, levels.join("."));
    if (add2.length == 1 && !add2[0]) {
      return;
    }
    if (isPlainObject_1(base79)) {
      each(add2, (subclasses, subclassName) => {
        this.addClasses(subclasses, levels.concat(subclassName));
      });
    } else {
      set_1(this.componentClasses, levels.join("."), union_1(base79, add2));
    }
  }
  prependClasses(prepend, levels) {
    var base79 = get_1(this.componentClasses, levels.join("."));
    if (prepend.length == 1 && !prepend[0]) {
      return;
    }
    if (isPlainObject_1(base79)) {
      each(prepend, (subclasses, subclassName) => {
        this.prependClasses(subclasses, levels.concat(subclassName));
      });
    } else {
      set_1(this.componentClasses, levels.join("."), union_1(prepend, base79));
    }
  }
  removeClasses(remove, levels) {
    var base79 = get_1(this.componentClasses, levels.join("."));
    if (isPlainObject_1(base79)) {
      each(remove, (subclasses, subclassName) => {
        this.removeClasses(subclasses, levels.concat(subclassName));
      });
    } else if (Array.isArray(base79)) {
      set_1(this.componentClasses, levels.join("."), base79.filter((c) => {
        return typeof c !== "string" || remove.indexOf(c) === -1;
      }));
    }
  }
  replaceClasses(replace, levels) {
    var base79 = get_1(this.componentClasses, levels.join("."));
    if (Array.isArray(replace)) {
      var tempReplace = {};
      replace.forEach((r2) => {
        tempReplace = _objectSpread2$1(_objectSpread2$1({}, tempReplace), r2);
      });
      replace = tempReplace;
    }
    if (isPlainObject_1(base79)) {
      each(replace, (subclasses, subclassName) => {
        this.replaceClasses(subclasses, levels.concat(subclassName));
      });
    } else if (Array.isArray(base79)) {
      set_1(this.componentClasses, levels.join("."), base79.map((c) => {
        return typeof c !== "string" || Object.keys(replace).indexOf(c) === -1 ? c : replace[c];
      }));
    }
  }
  overrideClasses(override, levels) {
    var base79 = get_1(this.componentClasses, levels.join("."));
    if (isPlainObject_1(base79)) {
      each(override, (subclasses, subclassName) => {
        this.overrideClasses(subclasses, levels.concat(subclassName));
      });
    } else {
      set_1(this.componentClasses, levels.join("."), override);
    }
  }
  toArray(componentClasses) {
    var arrayClasses = {};
    each(componentClasses, (classes, className) => {
      arrayClasses[className] = this.classesToArray(classes, [className]);
    });
    return arrayClasses;
  }
  classesToArray(classes, path) {
    var _classes$constructor;
    var arrayClasses = classes;
    var base79 = path ? get_1(this.componentClasses, path.join(".")) : void 0;
    if (typeof classes === "string") {
      arrayClasses = classes.length > 0 ? classes.split(" ") : [];
    } else if (isPlainObject_1(classes)) {
      if (base79 && Array.isArray(base79)) {
        arrayClasses = [classes];
      } else if (!base79 || isPlainObject_1(base79)) {
        arrayClasses = {};
        each(classes, (subclasses, subclassName) => {
          arrayClasses[subclassName] = this.classesToArray(subclasses, path.concat([subclassName]));
        });
      }
    } else if (typeof classes === "boolean" || typeof classes === "object" && ["ComputedRefImpl", "RefImpl"].indexOf(classes === null || classes === void 0 || (_classes$constructor = classes.constructor) === null || _classes$constructor === void 0 ? void 0 : _classes$constructor.name) !== -1) {
      throw Error("Cannot add conditional class to ".concat(this.component, ": '").concat(path.join("."), "'"));
    }
    return arrayClasses;
  }
  getDynamicClasses(target, prop, mainTarget) {
    if (!mainTarget) {
      mainTarget = target;
    }
    var classes = Array.isArray(target[prop]) ? flattenDeep_1(target[prop]) : target[prop];
    if (target["$".concat(prop)]) {
      var propVal = target["$".concat(prop)](mainTarget, this.component$.value);
      return typeof propVal === "function" ? propVal : flattenDeep_1(propVal);
    }
    if (isPlainObject_1(classes)) {
      classes = cloneDeep_1(classes);
      each(classes, (classList, className) => {
        classes[className] = this.getDynamicClasses(classes, className, target);
      });
    }
    return classes;
  }
  getClassHelpers(componentClasses, path) {
    var classHelpers = {};
    each(componentClasses, (classes, className) => {
      if (className.match(/[$]/)) {
        return;
      }
      if (isPlainObject_1(classes)) {
        classHelpers[className] = this.getClassHelpers(componentClasses[className], path.concat([className]));
      } else {
        classHelpers[className] = ["".concat(path.join("."), ".").concat(className, "-->")];
      }
    });
    return classHelpers;
  }
  pick(from2, picks) {
    var picked = {};
    if (!from2) {
      return picked;
    }
    each(picks, (pick2) => {
      if (pick2 in from2) {
        picked[pick2] = from2[pick2];
      }
    });
    return picked;
  }
};
var getFormData = function getFormData2(data, formData, namespace) {
  if (formData === void 0) {
    formData = new FormData();
  }
  if (namespace === void 0) {
    namespace = "";
  }
  if (isArray_1(data)) {
    each(data, (value, key) => {
      getFormData2(value, formData, namespace + "[" + key + "]");
    });
  } else if (isPlainObject_1(data)) {
    each(data, (value, key) => {
      getFormData2(value, formData, namespace ? namespace + "[" + key + "]" : key);
    });
  } else {
    formData.append(namespace, data === null ? "" : data);
  }
  return formData;
};
var arrayMap$4 = _arrayMap;
function baseValues$1(object9, props) {
  return arrayMap$4(props, function(key) {
    return object9[key];
  });
}
var _baseValues = baseValues$1;
var baseValues = _baseValues;
var keys$1 = keys_1;
function values$1(object9) {
  return object9 == null ? [] : baseValues(object9, keys$1(object9));
}
var values_1 = values$1;
function asyncForEach(_x, _x2) {
  return _asyncForEach.apply(this, arguments);
}
function _asyncForEach() {
  _asyncForEach = _asyncToGenerator(function* (array4, callback57) {
    for (var index2 = 0; index2 < (isPlainObject_1(array4) ? values_1(array4) : array4).length; index2++) {
      var key = isPlainObject_1(array4) ? keys_1(array4)[index2] : index2;
      yield callback57(array4[key], key, array4);
    }
  });
  return _asyncForEach.apply(this, arguments);
}
var baseAssignValue = _baseAssignValue;
var baseForOwn = _baseForOwn;
var baseIteratee$6 = _baseIteratee;
function mapValues(object9, iteratee) {
  var result = {};
  iteratee = baseIteratee$6(iteratee);
  baseForOwn(object9, function(value, key, object10) {
    baseAssignValue(result, key, iteratee(value, key, object10));
  });
  return result;
}
var mapValues_1 = mapValues;
var baseIsEqual = _baseIsEqual;
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
var isEqual_1 = isEqual;
var fileToObject = function fileToObject2(file6) {
  return {
    lastModified: file6.lastModified,
    name: file6.name,
    size: file6.size,
    type: file6.type
  };
};
var dataToComperable = function dataToComperable2(data) {
  if (data instanceof File) {
    return fileToObject(data);
  } else if (data instanceof Date) {
    return data.toString();
  } else if (Array.isArray(data)) {
    return data.map(dataToComperable2);
  } else if (typeof data === "object" && data !== null) {
    return mapValues_1(data, dataToComperable2);
  }
  return data;
};
function dataEquals(a, b) {
  return isEqual_1(dataToComperable(a), dataToComperable(b));
}
function isComponentRegistered(vm, component) {
  return vm.appContext !== void 0 ? typeof vm.appContext.app.component(component) !== "string" : !!vm.proxy.$root.$options.components[component];
}
var flatten$3 = (source) => {
  var collection = [];
  source.forEach((item) => {
    collection.push(item.path);
    if (item.children) {
      flatten$3(item.children).forEach((child) => {
        collection.push(child);
      });
    }
  });
  return collection;
};
var collect = function collect2(elements, pages) {
  var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  var createMember = (name2) => {
    var element2 = elements[name2];
    var path = prefix.length ? "".concat(prefix, ".").concat(name2) : name2;
    var member = {
      name: name2,
      path,
      type: element2.type
    };
    if (["group", "object"].indexOf(element2.type) !== -1 && Object.keys(element2.schema || {}).length) {
      member.children = collect2(element2.schema, null, path);
    }
    if (element2.type === "list" && Object.keys((element2 === null || element2 === void 0 ? void 0 : element2.element) || {}).length) {
      member.children = collect2({
        0: element2.element
      }, null, path);
    }
    return member;
  };
  var children = [];
  if (pages && Object.keys(pages).length) {
    Object.values(pages).forEach((page) => {
      page.elements.forEach((name2) => {
        children.push(createMember(name2));
      });
    });
  } else {
    Object.keys(elements).forEach((name2) => {
      children.push(createMember(name2));
    });
  }
  return children;
};
var toString$6 = toString_1;
var upperFirst = upperFirst_1;
function capitalize$1(string2) {
  return upperFirst(toString$6(string2).toLowerCase());
}
var capitalize_1 = capitalize$1;
function arrayReduce$2(array4, iteratee, accumulator, initAccum) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  if (initAccum && length) {
    accumulator = array4[++index2];
  }
  while (++index2 < length) {
    accumulator = iteratee(accumulator, array4[index2], index2, array4);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$2;
function basePropertyOf$1(object9) {
  return function(key) {
    return object9 == null ? void 0 : object9[key];
  };
}
var _basePropertyOf = basePropertyOf$1;
var basePropertyOf = _basePropertyOf;
var deburredLetters = {
  // Latin-1 Supplement block.
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "c",
  "": "D",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "N",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "Y",
  "": "y",
  "": "y",
  "": "Ae",
  "": "ae",
  "": "Th",
  "": "th",
  "": "ss",
  // Latin Extended-A block.
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "D",
  "": "D",
  "": "d",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "H",
  "": "H",
  "": "h",
  "": "h",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "J",
  "": "j",
  "": "K",
  "": "k",
  "": "k",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "R",
  "": "R",
  "": "R",
  "": "r",
  "": "r",
  "": "r",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "T",
  "": "T",
  "": "T",
  "": "t",
  "": "t",
  "": "t",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "W",
  "": "w",
  "": "Y",
  "": "y",
  "": "Y",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "z",
  "": "z",
  "": "z",
  "": "IJ",
  "": "ij",
  "": "Oe",
  "": "oe",
  "": "'n",
  "": "s"
};
var deburrLetter$1 = basePropertyOf(deburredLetters);
var _deburrLetter = deburrLetter$1;
var deburrLetter = _deburrLetter;
var toString$5 = toString_1;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$1 = "\\u0300-\\u036f";
var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsCombo$1 = "[" + rsComboRange$1 + "]";
var reComboMark = RegExp(rsCombo$1, "g");
function deburr$1(string2) {
  string2 = toString$5(string2);
  return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var deburr_1 = deburr$1;
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords$1(string2) {
  return string2.match(reAsciiWord) || [];
}
var _asciiWords = asciiWords$1;
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord$1(string2) {
  return reHasUnicodeWord.test(string2);
}
var _hasUnicodeWord = hasUnicodeWord$1;
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "[']";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo = "[" + rsComboRange + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange + "]?";
var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords$1(string2) {
  return string2.match(reUnicodeWord) || [];
}
var _unicodeWords = unicodeWords$1;
var asciiWords = _asciiWords;
var hasUnicodeWord = _hasUnicodeWord;
var toString$4 = toString_1;
var unicodeWords = _unicodeWords;
function words$1(string2, pattern, guard) {
  string2 = toString$4(string2);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
  }
  return string2.match(pattern) || [];
}
var words_1 = words$1;
var arrayReduce$1 = _arrayReduce;
var deburr = deburr_1;
var words = words_1;
var rsApos = "[']";
var reApos = RegExp(rsApos, "g");
function createCompounder$1(callback57) {
  return function(string2) {
    return arrayReduce$1(words(deburr(string2).replace(reApos, "")), callback57, "");
  };
}
var _createCompounder = createCompounder$1;
var capitalize = capitalize_1;
var createCompounder = _createCompounder;
var camelCase = createCompounder(function(result, word, index2) {
  word = word.toLowerCase();
  return result + (index2 ? capitalize(word) : word);
});
var camelCase_1 = camelCase;
var base$1c = function base(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  if (!options.events) {
    throw new Error("`events` option is required for useEvents");
  }
  var events = ref(options.events);
  var listeners = ref({});
  var on2 = (evt, callback57) => {
    if (!listeners.value[evt]) {
      listeners.value[evt] = [];
    }
    listeners.value[evt].push(callback57);
  };
  var off2 = (evt) => {
    delete listeners.value[evt];
  };
  var fire = function fire2() {
    var evt = arguments[0];
    var args = [].slice.call(arguments).splice(1);
    each(listeners.value[evt], (callback57) => {
      callback57(...args);
    });
    if (!listeners.value[evt] || !listeners.value[evt].length) {
      context.emit(...[evt].concat(args));
    }
  };
  each(events.value, (evt) => {
    var callback57 = props["on" + upperFirst_1(camelCase_1(evt))];
    if (callback57) {
      on2(evt, callback57);
    }
  });
  return {
    events,
    listeners,
    on: on2,
    off: off2,
    fire
  };
};
function useModel(props, context, dependencies2) {
  var {
    value: v,
    modelValue: mv,
    sync
  } = toRefs(props);
  var $this = dependencies2.$this;
  var externalValue = $this.$vueform.vueVersion === 3 ? mv : v;
  var internalData = ref({});
  var intermediaryValue = ref(externalValue && externalValue.value ? cloneDeep_1(externalValue.value) : null);
  var isSync = computed(() => {
    return sync.value && externalValue && externalValue.value !== void 0;
  });
  var model = computed(() => {
    return cloneDeep_1(externalValue.value || internalData.value);
  });
  var updateModel = (dataPath, val) => {
    if (externalValue.value) {
      if (dataPath) {
        var parts = dataPath.split(".");
        var element2 = parts.pop();
        var parent2 = parts.join(".") || null;
        var externalValueObject = parent2 ? get_1(externalValue.value, parent2) : externalValue.value;
        if (externalValueObject !== void 0) {
          $this.$set(externalValueObject, element2, val);
        }
        intermediaryValue.value = cloneDeep_1(externalValue.value);
      } else {
        each(val, (v2, key) => {
          if (externalValue.value !== void 0) {
            $this.$set(externalValue.value, key, v2);
          }
          if (intermediaryValue.value !== void 0) {
            $this.$set(intermediaryValue.value, key, v2);
          }
        });
      }
    } else {
      var _model = cloneDeep_1(externalValue.value || internalData.value);
      if (dataPath) {
        set_1(_model, dataPath, val);
      } else {
        _model = Object.assign({}, _model, val);
      }
      internalData.value = _model;
    }
  };
  if (externalValue && externalValue.value) {
    watch(model, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      internalData.value = n2;
    }, {
      deep: true,
      immediate: false
    });
  }
  return {
    model,
    internalData,
    intermediaryValue,
    externalValue,
    isSync,
    updateModel
  };
}
var base$1b = function base2(props, context) {
  var {
    schema,
    tabs,
    steps,
    size: size2,
    view,
    views,
    addClass,
    removeClass,
    replaceClass,
    overrideClass,
    addClasses,
    removeClasses,
    replaceClasses,
    overrideClasses,
    presets,
    templates,
    theme,
    messages,
    columns,
    languages,
    formKey,
    endpoint,
    method,
    formData,
    language,
    locale: locale2,
    validateOn,
    forceLabels,
    floatPlaceholders,
    multilingual: multilingual11,
    stepsControls,
    displayErrors,
    displayMessages,
    formatLoad,
    formatData,
    forceNumbers,
    prepare,
    default: default_,
    disabled,
    loading,
    providers,
    useProviders,
    providerOptions,
    onChange: _onChange,
    onReset: _onReset,
    onClear: _onClear,
    onSubmit: _onSubmit,
    onSuccess: _onSuccess,
    onError: _onError,
    onLanguage: _onLanguage,
    onBeforeMount: _onBeforeMount,
    onMounted: _onMounted,
    onBeforeUpdate: _onBeforeUpdate,
    onUpdated: _onUpdated,
    onBeforeUnmount: _onBeforeUnmount,
    onUnmounted: _onUnmounted
  } = toRefs(props);
  var evts = ["change", "reset", "clear", "submit", "success", "error", "language", "response", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"];
  var vm = getCurrentInstance();
  var $this = vm.proxy;
  var {
    events,
    listeners,
    fire,
    on: on2,
    off: off2
  } = base$1c(props, context, {
    form$: $this
  }, {
    events: evts
  });
  var {
    externalValue,
    model,
    internalData,
    intermediaryValue,
    isSync,
    updateModel
  } = useModel(props, context, {
    $this,
    fire
  });
  var elements$ = ref({});
  var tabs$ = ref(null);
  var steps$ = ref(null);
  var validation2 = ref(true);
  var conditions = ref(true);
  var messageBag2 = ref({});
  var submitting = ref(false);
  var preparing = ref(false);
  var cancelToken = ref(null);
  var selectedLanguage = ref(null);
  var userConfig = ref({});
  var mounted = ref(false);
  var messagesRegistered = ref(isComponentRegistered(vm, "FormMessages"));
  var errorsRegistered = ref(isComponentRegistered(vm, "FormErrors"));
  var languagesRegistered = ref(isComponentRegistered(vm, "FormLanguages"));
  var tabsRegistered = ref(isComponentRegistered(vm, "FormTabs"));
  var stepsRegistered = ref(isComponentRegistered(vm, "FormSteps"));
  var form$ = computed(() => {
    return $this;
  });
  var baseConfig2 = computed(() => {
    return $this.$vueform;
  });
  var config$ = computed(() => {
    return baseConfig2.value;
  });
  var locale$ = computed(() => {
    return options.value.locale || baseConfig2.value.i18n.locale;
  });
  var services = computed(() => {
    return $this.$vueform.services;
  });
  var options = computed(() => {
    var options2 = {
      schema: orderedSchema.value,
      tabs: formTabs.value,
      steps: formSteps.value
    };
    var override = {
      columns,
      languages,
      language,
      theme,
      method,
      validateOn,
      messages,
      formKey,
      multilingual: multilingual11,
      formatLoad,
      formatData,
      prepare,
      default: default_,
      formData,
      templates,
      addClass,
      removeClass,
      replaceClass,
      overrideClass,
      addClasses,
      removeClasses,
      replaceClasses,
      overrideClasses,
      presets,
      size: size2,
      view,
      views,
      locale: locale2
    };
    var ifPropSet = {
      stepsControls,
      displayErrors,
      displayMessages,
      forceLabels,
      disabled,
      loading,
      floatPlaceholders,
      endpoint,
      forceNumbers,
      onChange: _onChange.value,
      onReset: _onReset.value,
      onClear: _onClear.value,
      onSubmit: _onSubmit.value,
      onSuccess: _onSuccess.value,
      onError: _onError.value,
      onLanguage: _onLanguage.value,
      onBeforeMount: _onBeforeMount.value,
      onMounted: _onMounted.value,
      onBeforeUpdate: _onBeforeUpdate.value,
      onUpdated: _onUpdated.value,
      onBeforeUnmount: _onBeforeUnmount.value,
      onUnmounted: _onUnmounted.value
    };
    var toMerge = {
      useProviders,
      providers,
      providerOptions
    };
    var defaults4 = {
      providers: baseConfig2.value.config.providers,
      useProviders: baseConfig2.value.config.useProviders,
      providerOptions: baseConfig2.value.config.providerOptions,
      languages: baseConfig2.value.config.languages,
      language: baseConfig2.value.config.language,
      endpoint: typeof baseConfig2.value.config.endpoints.submit === "function" ? baseConfig2.value.config.endpoints.submit : baseConfig2.value.config.endpoints.submit.url,
      method: typeof baseConfig2.value.config.endpoints.submit === "function" ? null : baseConfig2.value.config.endpoints.submit.method,
      validateOn: baseConfig2.value.config.validateOn,
      displayErrors: baseConfig2.value.config.displayErrors,
      displayMessages: baseConfig2.value.config.displayMessages,
      forceLabels: baseConfig2.value.config.forceLabels,
      floatPlaceholders: baseConfig2.value.config.floatPlaceholders,
      formData: baseConfig2.value.config.formData,
      theme: baseConfig2.value.theme,
      view: baseConfig2.value.config.view,
      views: {},
      columns: {},
      size: null,
      addClass: null,
      removeClass: null,
      replaceClass: null,
      overrideClass: null,
      addClasses: {},
      removeClasses: {},
      replaceClasses: {},
      overrideClasses: {},
      presets: [],
      templates: {},
      messages: {},
      default: {},
      formKey: null,
      formatLoad: null,
      formatData: null,
      forceNumbers: null,
      prepare: null,
      multilingual: false,
      stepsControls: true,
      disabled: false,
      loading: false
    };
    each(override, (val, key) => {
      options2[key] = userConfig.value[key] !== void 0 ? userConfig.value[key] : (val && val.value ? val.value : void 0) || defaults4[key];
    });
    each(ifPropSet, (val, key) => {
      options2[key] = userConfig.value[key] !== void 0 ? userConfig.value[key] : val && val.value !== null ? val.value : defaults4[key];
    });
    each(toMerge, (val, key) => {
      options2[key] = merge_1({}, defaults4[key], userConfig.value[key] || {}, val && val.value ? val.value : {});
    });
    return options2;
  });
  var orderedSchema = computed(() => {
    var blocks;
    var orderedSchema2 = formSchema.value;
    if (Object.keys(formSteps.value).length > 0) {
      blocks = formSteps.value;
    }
    if (Object.keys(formTabs.value).length > 0) {
      blocks = formTabs.value;
    }
    if (blocks) {
      orderedSchema2 = {};
      each(blocks, (block) => {
        each(block.elements, (name2) => {
          if (formSchema.value[name2]) {
            orderedSchema2[name2] = formSchema.value[name2];
          }
        });
      });
      each(Object.keys(formSchema.value), (name2) => {
        if (orderedSchema2[name2] === void 0) {
          orderedSchema2[name2] = formSchema.value[name2];
        }
      });
    }
    return orderedSchema2;
  });
  var formSchema = computed(() => {
    return merge_1({}, schema && schema.value ? schema.value : {}, userConfig.value.schema || {});
  });
  var formTabs = computed(() => {
    return merge_1({}, tabs && tabs.value ? tabs.value : {}, userConfig.value.tabs || {});
  });
  var formSteps = computed(() => {
    return merge_1({}, steps && steps.value ? steps.value : {}, userConfig.value.steps || {});
  });
  var tree = computed(() => {
    return collect(formSchema.value, hasTabs.value ? formTabs.value : formSteps.value);
  });
  var flatTree = computed(() => {
    return flatten$3(tree.value);
  });
  var data = computed(() => {
    var data2 = {};
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      data2 = Object.assign({}, data2, e$.data);
    });
    return data2;
  });
  var requestData = computed(() => {
    var requestData2 = {};
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      requestData2 = Object.assign({}, requestData2, e$.requestData);
    });
    return formatData.value ? formatData.value(requestData2) : requestData2;
  });
  var dirty = computed(() => {
    return some_1(elements$.value, (element$) => {
      return element$.isStatic === false && element$.available === true && element$.dirty === true;
    });
  });
  var invalid = computed(() => {
    return some_1(elements$.value, (element$) => {
      return element$.isStatic === false && element$.available === true && element$.invalid === true;
    });
  });
  var debouncing = computed(() => {
    return some_1(elements$.value, (element$) => {
      return element$.isStatic === false && element$.available === true && element$.debouncing === true;
    });
  });
  var pending = computed(() => {
    return some_1(elements$.value, (element$) => {
      return element$.isStatic === false && element$.available === true && element$.pending === true;
    });
  });
  var validated = computed(() => {
    return !some_1(elements$.value, (element$) => {
      return element$.isStatic === false && element$.available === true && element$.validated === false;
    });
  });
  var busy = computed(() => {
    return some_1(elements$.value, (element$) => {
      return element$.isStatic === false && element$.available === true && element$.busy === true;
    }) || submitting.value || preparing.value || isLoading.value;
  });
  var elementErrors = computed(() => {
    var errors = [];
    each(filter_1(elements$.value, {
      available: true,
      isStatic: false
    }), (element$) => {
      each(element$.errors, (error) => {
        errors.push(error);
      });
    });
    return errors;
  });
  var formErrors = computed(() => {
    return messageBag2.value.errors;
  });
  var hasErrors = computed(() => {
    return formErrors.value.length > 0;
  });
  var showErrors = computed(() => {
    return hasErrors.value && options.value.displayErrors && errorsRegistered.value;
  });
  var formMessages = computed(() => {
    return messageBag2.value.messages;
  });
  var hasMessages = computed(() => {
    return formMessages.value.length > 0;
  });
  var showMessages = computed(() => {
    return hasMessages.value && options.value.displayMessages && messagesRegistered.value;
  });
  var isMultilingual = computed(() => {
    return options.value.multilingual;
  });
  var showLanguages = computed(() => {
    return isMultilingual.value && languagesRegistered.value;
  });
  var isDisabled = computed(() => {
    return invalid.value && shouldValidateOnChange.value || busy.value || options.value.disabled;
  });
  var isLoading = computed(() => {
    return options.value.loading;
  });
  var shouldValidateOnChange = computed(() => {
    return options.value.validateOn.split("|").indexOf("change") !== -1;
  });
  var shouldValidateOnStep = computed(() => {
    return options.value.validateOn.split("|").indexOf("step") !== -1;
  });
  var hasSteps = computed(() => {
    return !isEmpty_1(options.value.steps);
  });
  var showSteps = computed(() => {
    return hasSteps.value && stepsRegistered.value;
  });
  var showStepsControls = computed(() => {
    return hasSteps.value && options.value.stepsControls && stepsRegistered.value;
  });
  var hasTabs = computed(() => {
    return !isEmpty_1(options.value.tabs);
  });
  var showTabs = computed(() => {
    return hasTabs.value && tabsRegistered.value;
  });
  var extendedTheme = computed(() => {
    var presetTemplates = {};
    each(baseConfig2.value.config.usePresets.concat(options.value.presets), (presetName) => {
      var preset = baseConfig2.value.config.presets[presetName];
      if (!preset || !preset.templates) {
        return;
      }
      presetTemplates = Object.assign({}, presetTemplates, preset.templates);
    });
    return Object.assign({}, options.value.theme, {
      // Add registered component to theme (or overwrite)
      templates: Object.assign({}, options.value.theme.templates, baseConfig2.value.templates, presetTemplates, options.value.templates || {})
    });
  });
  var Templates = computed(() => {
    return extendedTheme.value.templates;
  });
  var template = computed(() => {
    return View.value && Templates.value["Vueform_".concat(View.value)] ? Templates.value["Vueform_".concat(View.value)] : Templates.value.Vueform;
  });
  var classes = computed(() => {
    return new MergeClasses({
      component: "Vueform",
      component$: form$,
      theme: extendedTheme.value,
      config: baseConfig2.value.config,
      templates: Templates.value,
      view: View.value,
      locals: options.value,
      merge: [options.value]
    }).classes;
  });
  var Size = computed(() => {
    var Size2;
    if (options.value.size) {
      Size2 = options.value.size;
    } else {
      each(baseConfig2.value.config.usePresets.concat(options.value.presets), (presetName) => {
        var preset = baseConfig2.value.config.presets[presetName];
        if (!preset || !preset.size) {
          return;
        }
        Size2 = preset.size;
      });
    }
    if (!Size2) {
      Size2 = baseConfig2.value.config.size;
    }
    return Size2;
  });
  var Views = computed(() => {
    var Views2 = baseConfig2.value.config.views;
    each(baseConfig2.value.config.usePresets.concat(options.value.presets), (presetName) => {
      var preset = baseConfig2.value.config.presets[presetName];
      if (!preset || !preset.views) {
        return;
      }
      Views2 = Object.assign({}, Views2, preset.views);
    });
    Views2 = Object.assign({}, Views2, options.value.views);
    return Views2;
  });
  var View = computed(() => {
    if (options.value.view) {
      return options.value.view;
    }
    return Views.value.Vueform;
  });
  var translations = computed(() => {
    var i18n2 = $this.$vueform.i18n;
    var locales2 = i18n2.locales;
    var currentLocale = locale2.value || i18n2.locale;
    var fallbackLocale = i18n2.fallbackLocale || "en";
    return currentLocale ? merge_1({}, locales2[fallbackLocale], locales2[currentLocale]) : locales2[fallbackLocale];
  });
  var update = function update2(data2) {
    var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (path) {
      el$(path).update(data2);
      return;
    }
    each(elements$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      if (data2[element$.name] === void 0 && !element$.flat) {
        return;
      }
      element$.update(element$.flat ? data2 : data2[element$.name]);
    });
  };
  var load = function() {
    var _ref = _asyncToGenerator(function* (data2) {
      var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (steps$.value !== null) {
        steps$.value.enableAllSteps();
      }
      var formatted = format2 && options.value.formatLoad !== null ? options.value.formatLoad(data2) : data2;
      yield asyncForEach(elements$.value, function() {
        var _ref2 = _asyncToGenerator(function* (e$) {
          if (e$.isStatic) {
            return;
          }
          var loadValue = e$.flat ? formatted : formatted[e$.name];
          if (loadValue === void 0) {
            e$.clear();
            return;
          }
          yield e$.load(loadValue, format2);
        });
        return function(_x2) {
          return _ref2.apply(this, arguments);
        };
      }());
    });
    return function load2(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  var reset = () => {
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      e$.reset();
    });
    if (steps$.value !== null) {
      steps$.value.reset();
    }
    if (tabs$.value !== null) {
      tabs$.value.reset();
    }
    fire("reset");
  };
  var clear = () => {
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      e$.clear();
    });
    if (steps$.value !== null) {
      steps$.value.reset();
    }
    if (tabs$.value !== null) {
      tabs$.value.reset();
    }
    fire("clear");
  };
  var clean = () => {
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      e$.clean();
    });
  };
  var clearMessages = () => {
    if (messageBag2.value) {
      messageBag2.value.clear();
    }
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      e$.clearMessages();
    });
  };
  var validate = function() {
    var _ref3 = _asyncToGenerator(function* () {
      if (!invalid.value && validated.value && shouldValidateOnChange.value) {
        return;
      }
      var validatableElements = Object.values(elements$.value).filter((e$) => {
        return e$.available && !e$.isStatic && (!e$.validated || !shouldValidateOnChange.value);
      });
      yield asyncForEach(validatableElements, function() {
        var _ref4 = _asyncToGenerator(function* (e$) {
          yield e$.validate();
        });
        return function(_x3) {
          return _ref4.apply(this, arguments);
        };
      }());
    });
    return function validate2() {
      return _ref3.apply(this, arguments);
    };
  }();
  var resetValidators = () => {
    each(elements$.value, (e$) => {
      if (e$.isStatic) {
        return;
      }
      e$.resetValidators();
    });
  };
  var submit = function() {
    var _ref5 = _asyncToGenerator(function* () {
      if (isDisabled.value) {
        return;
      }
      yield validate();
      if (invalid.value) {
        return;
      }
      preparing.value = true;
      try {
        yield prepareElements();
        if (typeof options.value.prepare === "function") {
          yield options.value.prepare(form$.value);
        }
        if (typeof $this.$vueform.config.beforeSend === "function") {
          yield $this.$vueform.config.beforeSend(form$.value);
        }
      } catch (error) {
        fire("error", error, {
          type: "prepare"
        }, form$.value);
        console.error(error);
        return;
      } finally {
        preparing.value = false;
      }
      var data2 = options.value.formData(form$.value);
      fire("submit", form$.value, data2);
      if (!options.value.endpoint) {
        return;
      }
      send();
    });
    return function submit2() {
      return _ref5.apply(this, arguments);
    };
  }();
  var send = function() {
    var _ref6 = _asyncToGenerator(function* () {
      submitting.value = true;
      var response = {};
      try {
        var _response2, _response3;
        resetValidators();
        var _data = options.value.formData(form$.value);
        if (typeof options.value.endpoint === "function") {
          response = yield options.value.endpoint(_data, form$.value);
        } else {
          var _$this$$vueform$confi, _$this$$vueform$confi2;
          cancelToken.value = services.value.axios.CancelToken.source();
          var url2 = ((_$this$$vueform$confi = $this.$vueform.config.endpoints[options.value.endpoint]) === null || _$this$$vueform$confi === void 0 ? void 0 : _$this$$vueform$confi.url) || options.value.endpoint;
          var _method = ((_$this$$vueform$confi2 = $this.$vueform.config.endpoints[options.value.endpoint]) === null || _$this$$vueform$confi2 === void 0 ? void 0 : _$this$$vueform$confi2.method) || options.value.method;
          response = yield services.value.axios.request({
            url: url2,
            method: _method.toLowerCase(),
            [_method.toLowerCase() === "get" ? "params" : "data"]: _data,
            cancelToken: cancelToken.value.token
          });
        }
        if (response && !(response instanceof Promise)) {
          var _response;
          if ((_response = response) !== null && _response !== void 0 && (_response = _response.data) !== null && _response !== void 0 && (_response = _response.payload) !== null && _response !== void 0 && _response.updates) {
            update(response.data.payload.updates);
          }
        }
        if (((_response2 = response) === null || _response2 === void 0 ? void 0 : _response2.status) >= 200 && ((_response3 = response) === null || _response3 === void 0 ? void 0 : _response3.status) < 300) {
          fire("success", response, form$.value);
        } else {
          fire("error", {
            response
          }, {
            type: "submit"
          }, form$.value);
        }
      } catch (error) {
        if (error.response) {
          fire("error", error, {
            type: "submit"
          }, form$.value);
          fire("response", error.response, form$.value);
        } else if (services.value.axios.isCancel(error)) {
          fire("error", error, {
            type: "cancel"
          }, form$.value);
        } else {
          fire("error", error, {
            type: "other"
          }, form$.value);
        }
        console.error(error);
        return;
      } finally {
        cancelToken.value = null;
        submitting.value = false;
      }
      fire("response", response, form$.value);
    });
    return function send2() {
      return _ref6.apply(this, arguments);
    };
  }();
  var cancel = () => {
    if (!cancelToken.value) {
      return;
    }
    cancelToken.value.cancel();
  };
  var prepareElements = function() {
    var _ref7 = _asyncToGenerator(function* () {
      try {
        yield asyncForEach(elements$.value, function() {
          var _ref8 = _asyncToGenerator(function* (e$) {
            if (e$.prepare) {
              yield e$.prepare();
            }
          });
          return function(_x4) {
            return _ref8.apply(this, arguments);
          };
        }());
      } catch (e2) {
        throw new Error(e2);
      }
    });
    return function prepareElements2() {
      return _ref7.apply(this, arguments);
    };
  }();
  var disableValidation = () => {
    validation2.value = false;
  };
  var enableValidation = () => {
    validation2.value = true;
  };
  var enableConditions = () => {
    conditions.value = true;
  };
  var disableConditions = () => {
    conditions.value = false;
  };
  var setLanguage = (code) => {
    selectedLanguage.value = code;
    fire("language", code);
  };
  var handleSubmit = () => {
    submit();
  };
  var convertFormData = (data2) => {
    return getFormData(data2);
  };
  var el$ = (path, elements) => {
    if (elements === void 0) {
      elements = elements$.value;
    }
    if (isEmpty_1(elements) || !path) {
      return null;
    }
    var matches2 = String(path).match(/^[^.]+\./);
    if (matches2) {
      var current = matches2[0].replace(".", "");
      if (!elements[current]) {
        return null;
      }
      return el$(path.replace(matches2[0], ""), elements[current].children$);
    } else if (elements[path] !== void 0) {
      return elements[path];
    }
    return null;
  };
  var siblings$ = (path) => {
    var _el$;
    if (!/\.+/.test(path)) {
      return elements$.value;
    }
    return ((_el$ = el$(path.match(/.*(?=\.)/)[0])) === null || _el$ === void 0 ? void 0 : _el$.children$) || {};
  };
  var initMessageBag = () => {
    messageBag2.value = new services.value.messageBag(elementErrors);
  };
  provide("form$", form$);
  provide("theme", extendedTheme);
  provide("Size", Size);
  provide("Views", Views);
  provide("translations", translations);
  provide("config$", config$);
  initMessageBag();
  setLanguage(options.value.language);
  onBeforeMount(() => {
    userConfig.value = $this.vueform || {};
    each(evts, (evt) => {
      var callback57 = options.value["on" + upperFirst_1(evt)];
      if (callback57) {
        on2(evt, callback57);
      }
    });
    fire("beforeMount", $this);
  });
  onMounted(() => {
    mounted.value = true;
    watch(data, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      fire("change", n2, o2, $this);
      if (externalValue && externalValue.value !== void 0) {
        context.emit("input", n2);
        context.emit("update:modelValue", n2);
      }
    }, {
      deep: true,
      immediate: false
    });
    if (externalValue && externalValue.value !== void 0 && JSON.stringify(externalValue.value) !== JSON.stringify(data.value)) {
      context.emit("input", data.value);
      context.emit("update:modelValue", data.value);
    }
    fire("mounted", $this);
  });
  onBeforeUpdate(() => fire("beforeUpdate", $this));
  onUpdated(() => fire("updated", $this));
  onBeforeUnmount(() => fire("beforeUnmount", $this));
  onUnmounted(() => fire("unmounted", $this));
  watch(computed(() => options.value.language), (n2, o2) => {
    if (n2) {
      setLanguage(n2);
    }
  });
  return {
    tabs$,
    steps$,
    elements$,
    options,
    validation: validation2,
    conditions,
    messageBag: messageBag2,
    selectedLanguage,
    submitting,
    preparing,
    cancelToken,
    events,
    listeners,
    internalData,
    data,
    requestData,
    dirty,
    invalid,
    debouncing,
    pending,
    validated,
    busy,
    formErrors,
    formMessages,
    isDisabled,
    isLoading,
    shouldValidateOnChange,
    shouldValidateOnStep,
    hasSteps,
    hasTabs,
    hasErrors,
    hasMessages,
    isMultilingual,
    showErrors,
    showMessages,
    showLanguages,
    showSteps,
    showTabs,
    showStepsControls,
    classes,
    Templates,
    template,
    extendedTheme,
    Size,
    View,
    Views,
    form$,
    model,
    intermediaryValue,
    userConfig,
    isSync,
    tree,
    flatTree,
    translations,
    locale$,
    prepareElements,
    updateModel,
    update,
    load,
    reset,
    clear,
    clean,
    clearMessages,
    validate,
    resetValidators,
    convertFormData,
    submit,
    send,
    cancel,
    disableValidation,
    enableValidation,
    enableConditions,
    disableConditions,
    setLanguage,
    handleSubmit,
    el$,
    siblings$,
    initMessageBag,
    fire,
    on: on2,
    off: off2,
    messagesRegistered,
    errorsRegistered,
    languagesRegistered,
    tabsRegistered,
    stepsRegistered
  };
};
var base$1a = function base3(props, context, dependencies2) {
  var componentName = context.name;
  var form$ = dependencies2.form$;
  var el$ = dependencies2.el$;
  var component$ = dependencies2.component$ || dependencies2.el$;
  var theme = dependencies2.theme;
  var Templates = dependencies2.Templates;
  var View = dependencies2.View;
  var classesInstance = computed(() => {
    return new MergeClasses({
      component: componentName.value,
      component$,
      theme: theme.value,
      config: form$.value.$vueform.config,
      templates: Templates.value,
      view: View.value,
      merge: [form$.value.options, el$.value]
    });
  });
  var classes = computed(() => {
    var _classesInstance$valu;
    return _objectSpread2$1({}, (_classesInstance$valu = classesInstance.value) === null || _classesInstance$valu === void 0 ? void 0 : _classesInstance$valu.classes);
  });
  return {
    classes,
    classesInstance
  };
};
var VueformComponent = {
  name: "Vueform",
  emits: ["input", "update:modelValue", "change", "reset", "clear", "submit", "success", "error", "response", "language", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  slots: ["default", "empty"],
  setup: (props, context) => {
    context.emits = ["input", "update:modelValue", "change", "reset", "clear", "submit", "success", "error", "response", "language", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"];
    context.name = ref("Vueform");
    var {
      tabs$,
      steps$,
      elements$,
      options,
      validation: validation2,
      conditions,
      messageBag: messageBag2,
      selectedLanguage,
      submitting,
      preparing,
      cancelToken,
      events,
      listeners,
      internalData,
      data,
      requestData,
      dirty,
      invalid,
      debouncing,
      pending,
      validated,
      busy,
      formErrors,
      formMessages,
      isDisabled,
      isLoading,
      shouldValidateOnChange,
      shouldValidateOnStep,
      hasSteps,
      hasTabs,
      hasErrors,
      hasMessages,
      isMultilingual,
      showErrors,
      showMessages,
      showLanguages,
      showSteps,
      showTabs,
      showStepsControls,
      classes,
      Templates,
      template,
      extendedTheme,
      Size,
      View,
      Views,
      form$,
      model,
      intermediaryValue,
      userConfig,
      isSync,
      tree,
      flatTree,
      translations,
      locale$,
      prepareElements,
      updateModel,
      update,
      load,
      reset,
      clear,
      clean,
      clearMessages,
      validate,
      resetValidators,
      convertFormData,
      submit,
      send,
      cancel,
      disableValidation,
      enableValidation,
      enableConditions,
      disableConditions,
      setLanguage,
      handleSubmit,
      el$,
      siblings$,
      initMessageBag,
      fire,
      on: on2,
      off: off2,
      messagesRegistered,
      errorsRegistered,
      languagesRegistered,
      tabsRegistered,
      stepsRegistered
    } = base$1b(props, context);
    return {
      tabs$,
      steps$,
      elements$,
      options,
      validation: validation2,
      conditions,
      messageBag: messageBag2,
      selectedLanguage,
      submitting,
      preparing,
      cancelToken,
      events,
      listeners,
      internalData,
      data,
      requestData,
      dirty,
      invalid,
      debouncing,
      pending,
      validated,
      busy,
      formErrors,
      formMessages,
      isDisabled,
      isLoading,
      shouldValidateOnChange,
      shouldValidateOnStep,
      hasSteps,
      hasTabs,
      hasErrors,
      hasMessages,
      isMultilingual,
      showErrors,
      showMessages,
      showLanguages,
      showSteps,
      showTabs,
      showStepsControls,
      classes,
      Templates,
      template,
      extendedTheme,
      Size,
      View,
      Views,
      form$,
      model,
      intermediaryValue,
      userConfig,
      isSync,
      tree,
      flatTree,
      translations,
      locale$,
      prepareElements,
      updateModel,
      update,
      load,
      reset,
      clear,
      clean,
      clearMessages,
      validate,
      resetValidators,
      convertFormData,
      submit,
      send,
      cancel,
      disableValidation,
      enableValidation,
      enableConditions,
      disableConditions,
      setLanguage,
      handleSubmit,
      el$,
      siblings$,
      initMessageBag,
      fire,
      on: on2,
      off: off2,
      messagesRegistered,
      errorsRegistered,
      languagesRegistered,
      tabsRegistered,
      stepsRegistered
    };
  },
  props: {
    schema: {
      type: Object,
      required: false,
      default: null
    },
    name: {
      type: String,
      required: false,
      default: null,
      private: true
    },
    tabs: {
      type: Object,
      required: false,
      default: null
    },
    steps: {
      type: Object,
      required: false,
      default: null
    },
    stepsControls: {
      type: Boolean,
      required: false,
      default: null,
      "@default": true
    },
    validateOn: {
      type: String,
      required: false,
      default: null
    },
    displayErrors: {
      type: Boolean,
      required: false,
      default: null
    },
    displayMessages: {
      type: Boolean,
      required: false,
      default: null
    },
    messages: {
      type: Object,
      required: false,
      default: null
    },
    endpoint: {
      type: [String, Boolean, Function, Promise],
      required: false,
      default: null
    },
    method: {
      type: String,
      required: false,
      default: null
    },
    prepare: {
      type: Function,
      required: false,
      default: null
    },
    formKey: {
      type: [String, Number],
      required: false,
      default: null
    },
    formData: {
      type: Function,
      required: false,
      default: null
    },
    value: {
      type: Object,
      required: false,
      default: void 0
    },
    modelValue: {
      type: Object,
      required: false,
      default: void 0
    },
    sync: {
      type: Boolean,
      required: false,
      default: false
    },
    default: {
      type: Object,
      required: false,
      default: null
    },
    forceNumbers: {
      required: false,
      type: [Boolean],
      default: null
    },
    formatData: {
      type: Function,
      required: false,
      default: null
    },
    formatLoad: {
      type: Function,
      required: false,
      default: null
    },
    loading: {
      type: Boolean,
      required: false,
      default: null
    },
    disabled: {
      type: Boolean,
      required: false,
      default: null
    },
    columns: {
      type: Object,
      required: false,
      default: null
    },
    forceLabels: {
      type: Boolean,
      required: false,
      default: null
    },
    floatPlaceholders: {
      type: Boolean,
      required: false,
      default: null
    },
    size: {
      required: false,
      type: [String],
      default: null
    },
    view: {
      required: false,
      type: [String],
      default: null
    },
    views: {
      required: false,
      type: [Object],
      default: null
    },
    addClasses: {
      required: false,
      type: [Object, Function],
      default: null
    },
    addClass: {
      required: false,
      type: [Array, Object, String, Function],
      default: null
    },
    removeClasses: {
      required: false,
      type: [Object, Function],
      default: null
    },
    removeClass: {
      required: false,
      type: [Array, Object, Function],
      default: null
    },
    replaceClasses: {
      required: false,
      type: [Object, Function],
      default: null
    },
    replaceClass: {
      required: false,
      type: [Object, Function],
      default: null
    },
    overrideClasses: {
      required: false,
      type: [Object, Function],
      default: null
    },
    overrideClass: {
      required: false,
      type: [Array, Object, String, Function],
      default: null
    },
    templates: {
      type: Object,
      required: false,
      default: null
    },
    presets: {
      required: false,
      type: [Array],
      default: null
    },
    multilingual: {
      type: Boolean,
      required: false,
      default: null
    },
    languages: {
      type: Object,
      required: false,
      default: null
    },
    language: {
      type: String,
      required: false,
      default: null
    },
    locale: {
      type: String,
      required: false,
      default: null
    },
    providers: {
      type: [Object],
      required: false,
      default: null
    },
    useProviders: {
      type: [Object],
      required: false,
      default: null
    },
    providerOptions: {
      type: [Object],
      required: false,
      default: null
    },
    onChange: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onReset: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClear: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSubmit: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onResponse: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSuccess: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onError: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onLanguage: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onBeforeMount: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onMounted: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onBeforeUpdate: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onUpdated: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onBeforeUnmount: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onUnmounted: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  render() {
    return this.template.render.apply(this, arguments);
  }
  // staticRenderFns() {
  //   return this.templates.Vueform.staticRenderFns
  // }
};
var baseEach$1 = _baseEach;
var isArrayLike$2 = isArrayLike_1;
function baseMap$2(collection, iteratee) {
  var index2 = -1, result = isArrayLike$2(collection) ? Array(collection.length) : [];
  baseEach$1(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
var _baseMap = baseMap$2;
var arrayMap$3 = _arrayMap;
var baseIteratee$5 = _baseIteratee;
var baseMap$1 = _baseMap;
var isArray$4 = isArray_1;
function map2(collection, iteratee) {
  var func = isArray$4(collection) ? arrayMap$3 : baseMap$1;
  return func(collection, baseIteratee$5(iteratee));
}
var map_1 = map2;
var baseGetTag = _baseGetTag;
var isArray$3 = isArray_1;
var isObjectLike = isObjectLike_1;
var stringTag = "[object String]";
function isString$1(value) {
  return typeof value == "string" || !isArray$3(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}
var isString_1 = isString$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string2) {
  var index2 = string2.length;
  while (index2-- && reWhitespace.test(string2.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$2(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
}
var _baseTrim = baseTrim$2;
var baseIndexOf$2 = _baseIndexOf;
function charsEndIndex$1(strSymbols, chrSymbols) {
  var index2 = strSymbols.length;
  while (index2-- && baseIndexOf$2(chrSymbols, strSymbols[index2], 0) > -1) {
  }
  return index2;
}
var _charsEndIndex = charsEndIndex$1;
var baseIndexOf$1 = _baseIndexOf;
function charsStartIndex$1(strSymbols, chrSymbols) {
  var index2 = -1, length = strSymbols.length;
  while (++index2 < length && baseIndexOf$1(chrSymbols, strSymbols[index2], 0) > -1) {
  }
  return index2;
}
var _charsStartIndex = charsStartIndex$1;
var baseToString$2 = _baseToString;
var baseTrim$1 = _baseTrim;
var castSlice = _castSlice;
var charsEndIndex = _charsEndIndex;
var charsStartIndex = _charsStartIndex;
var stringToArray = _stringToArray;
var toString$3 = toString_1;
function trim2(string2, chars, guard) {
  string2 = toString$3(string2);
  if (string2 && (guard || chars === void 0)) {
    return baseTrim$1(string2);
  }
  if (!string2 || !(chars = baseToString$2(chars))) {
    return string2;
  }
  var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
  return castSlice(strSymbols, start, end).join("");
}
var trim_1 = trim2;
var Validator = class {
  constructor(rule, props) {
    var _props$element$;
    this.rule = rule;
    this.attributes = rule.attributes || {};
    this.conditions = rule.conditions || [];
    this.dependents = rule.dependents || [];
    this.element$ = props.element$;
    this.form$ = ((_props$element$ = props.element$) === null || _props$element$ === void 0 ? void 0 : _props$element$.form$) || {};
    this.numeric = props.numeric || false;
    this.elementMessages = props.element$.messages;
    this.invalid = false;
    this.pending = false;
    this.debouncer = null;
    this.lastValue = null;
    this.watchers = {};
    this.dependents.forEach((dependent) => {
      watch(computed(() => get_1(this.form$.data, dependent)), () => {
        if (this.element$.validated) {
          if (this.name === "nullable") {
            this.element$.validate();
          } else {
            this.revalidate();
          }
        }
      });
    });
    watch(computed(() => props.element$.messages), (n2, o2) => {
      if (isEqual_1(n2, o2)) {
        return;
      }
      this.elementMessages = props.element$.messages;
    }, {
      deep: true
    });
    this.init();
  }
  get name() {
    return this.rule.name;
  }
  get failing() {
    return this.invalid;
  }
  get defaultMessage() {
    return this.form$.translations.vueform.defaultMessage;
  }
  get message() {
    var _this$form$$translati;
    var message = "";
    if (this.msg) {
      message = this.msg;
    } else if (this.elementMessages[this.name]) {
      message = this.elementMessages[this.name];
    } else if (this.form$.options.messages[this.name]) {
      message = this.form$.options.messages[this.name];
    } else if (this.name !== "_class" && ((_this$form$$translati = this.form$.translations.validation) === null || _this$form$$translati === void 0 ? void 0 : _this$form$$translati[this.name]) !== void 0) {
      message = this.form$.translations.validation[this.name];
      if (isPlainObject_1(message)) {
        message = message[this.messageType];
      }
    } else {
      message = this.defaultMessage;
    }
    each(map_1(message.match(/:\w+/g), (p) => p.replace(":", "")), (param) => {
      message = message.replace(":".concat(param), this.messageParams[param]);
    });
    each(map_1(message.match(/{[^}]+/g), (p) => p.replace("{", "")), (param) => {
      message = message.replace("{".concat(param, "}"), this.messageParams[param]);
    });
    return message;
  }
  get messageType() {
    if (this.isNumeric) {
      return "numeric";
    } else if (this.isFile) {
      return "file";
    } else if (this.isArray) {
      return "array";
    }
    return "string";
  }
  get messageParams() {
    return {
      attribute: this.attributeName
    };
  }
  get attributeName() {
    return this.element$.genericName;
  }
  get type() {
    if (this.isNumeric) {
      return "numeric";
    } else if (this.isFile) {
      return "file";
    } else if (this.isArray) {
      return "array";
    }
    return "string";
  }
  get isNumeric() {
    return some_1(this.element$.Validators, {
      name: "numeric"
    }) || some_1(this.element$.Validators, {
      name: "integer"
    });
  }
  get isNullable() {
    var nullable2 = false;
    each(this.element$.Validators, (Validator2) => {
      if (Validator2.name !== "nullable") {
        return;
      }
      if (!Validator2.conditions.length) {
        nullable2 = true;
        return;
      }
      nullable2 = Validator2.conditions(this.form$, this, this.element$);
    });
    return nullable2;
  }
  get isFile() {
    return this.element$.isFileType;
  }
  get isArray() {
    return this.element$.isArrayType;
  }
  get isAsync() {
    return false;
  }
  get debounce() {
    if (this.attributes.debounce) {
      return this.attributes.debounce;
    }
    if (this.element$.debounce) {
      return this.element$.debounce;
    }
    return false;
  }
  get debouncing() {
    return this.debouncer !== null;
  }
  init() {
  }
  validate(value) {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (value === void 0) {
        var _this$element$;
        value = (_this$element$ = _this.element$) === null || _this$element$ === void 0 ? void 0 : _this$element$.value;
      }
      if (!_this.form$.validation) {
        return;
      }
      if (_this.isNullable && !_this.filled(value)) {
        _this.invalid = false;
        return;
      }
      if (_this.conditions.length) {
        if (!_this.conditions(_this.form$, _this, _this.element$)) {
          _this.invalid = false;
          return;
        }
      }
      if (_this.debounce && _this.filled(value)) {
        yield _this._validateWithDebounce(value);
      } else {
        if (_this.debounce && _this.debouncer) {
          clearTimeout(_this.debouncer);
        }
        yield _this._validate(value);
      }
    })();
  }
  replaceParams(message) {
    each(map_1(message.match(/:\w+/g), (p) => p.replace(":", "")), (param) => {
      message = message.replace(":".concat(param), this.messageParams[param]);
    });
    each(map_1(message.match(/{[^}]+/g), (p) => p.replace("{", "")), (param) => {
      message = message.replace("{".concat(param, "}"), this.messageParams[param]);
    });
    return message;
  }
  reset() {
    this.invalid = false;
  }
  watch(variables) {
    if (!Array.isArray(variables)) {
      variables = [variables];
    }
    variables.forEach((variable) => {
      this.addWatcher(variable);
    });
  }
  addWatcher(variable) {
    if (this.watchers[variable]) {
      return;
    }
    this.watchers[variable] = watch(computed(() => get_1(this.form$.data, variable)), () => {
      this.revalidate();
    });
  }
  revalidate() {
    this.element$.Validators.forEach((Validator2) => {
      if (Validator2.rule.name === this.rule.name) {
        Validator2.validate();
      }
    });
  }
  watchOther() {
    this.form$.$nextTick(() => {
      if (!this.other$) {
        return;
      }
      this.form$.$watch(() => {
        var _this$other$;
        return (_this$other$ = this.other$) === null || _this$other$ === void 0 ? void 0 : _this$other$.value;
      }, () => {
        if (this.element$.validated) {
          this.element$.validate();
        }
      });
    });
  }
  size(value) {
    if (this.isNumeric) {
      if (!isNaN(value)) {
        var num = parseFloat(value);
        if (Number.isInteger(num)) {
          return parseInt(value);
        }
        return num;
      }
      return null;
    } else if (this.isFile) {
      return value ? value.size / 1e3 : 0;
    } else if (this.isArray) {
      return value.length;
    } else if (value === null) {
      return 0;
    } else if (value === void 0) {
      return 0;
    } else if (value === "") {
      return 0;
    }
    return String(value).length;
  }
  filled(value) {
    if (value === void 0 || value === null && value !== this.element$.trueValue || value === this.element$.falseValue) {
      return false;
    } else if (this.isNumeric && trim_1(value) === "") {
      return false;
    } else if (isString_1(value) && trim_1(value) === "") {
      return false;
    } else if (isArray_1(value) && value.length < 1) {
      return false;
    } else if (value instanceof File && value.name === "") {
      return false;
    }
    return true;
  }
  _validate(value) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      if (_this2.isAsync) {
        yield _this2._validateAsync(value);
      } else {
        _this2._validateSync(value);
      }
    })();
  }
  _validateAsync(value) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      _this3.lastValue = value;
      _this3.pending = true;
      var valid = yield _this3.check(value);
      if (dataEquals(_this3.lastValue, value)) {
        _this3.invalid = !valid;
        _this3.pending = false;
      }
    })();
  }
  _validateSync(value) {
    this.invalid = !this.check(value);
  }
  _validateWithDebounce(value) {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      return new Promise((resolve, reject) => {
        if (_this4.debouncer) {
          resolve();
          clearTimeout(_this4.debouncer);
        }
        _this4.debouncer = setTimeout(_asyncToGenerator(function* () {
          yield _this4._validate(value);
          _this4.debouncer = null;
          resolve();
        }), _this4.debounce);
      });
    })();
  }
};
function last$1(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? array4[length - 1] : void 0;
}
var last_1 = last$1;
var baseGet$2 = _baseGet;
var baseSlice = _baseSlice;
function parent$1(object9, path) {
  return path.length < 2 ? object9 : baseGet$2(object9, baseSlice(path, 0, -1));
}
var _parent = parent$1;
var castPath$2 = _castPath;
var last = last_1;
var parent = _parent;
var toKey = _toKey;
function baseUnset$1(object9, path) {
  path = castPath$2(path, object9);
  object9 = parent(object9, path);
  return object9 == null || delete object9[toKey(last(path))];
}
var _baseUnset = baseUnset$1;
var isPlainObject2 = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject2(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var baseFlatten$3 = _baseFlatten;
function flatten$2(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? baseFlatten$3(array4, 1) : [];
}
var flatten_1 = flatten$2;
var flatten$1 = flatten_1;
var overRest = _overRest;
var setToString = _setToString;
function flatRest$2(func) {
  return setToString(overRest(func, void 0, flatten$1), func + "");
}
var _flatRest = flatRest$2;
var arrayMap$2 = _arrayMap;
var baseClone$1 = _baseClone;
var baseUnset = _baseUnset;
var castPath$1 = _castPath;
var copyObject = _copyObject;
var customOmitClone = _customOmitClone;
var flatRest$1 = _flatRest;
var getAllKeysIn = _getAllKeysIn;
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG$1 = 4;
var omit = flatRest$1(function(object9, paths) {
  var result = {};
  if (object9 == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap$2(paths, function(path) {
    path = castPath$1(path, object9);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object9, getAllKeysIn(object9), result);
  if (isDeep) {
    result = baseClone$1(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG$1, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});
var omit_1 = omit;
var baseGet$1 = _baseGet;
var baseSet = _baseSet;
var castPath = _castPath;
function basePickBy$1(object9, paths, predicate) {
  var index2 = -1, length = paths.length, result = {};
  while (++index2 < length) {
    var path = paths[index2], value = baseGet$1(object9, path);
    if (predicate(value, path)) {
      baseSet(result, castPath(path, object9), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
var basePickBy = _basePickBy;
var hasIn = hasIn_1;
function basePick$1(object9, paths) {
  return basePickBy(object9, paths, function(value, path) {
    return hasIn(object9, path);
  });
}
var _basePick = basePick$1;
var basePick = _basePick;
var flatRest = _flatRest;
var pick = flatRest(function(object9, paths) {
  return object9 == null ? {} : basePick(object9, paths);
});
var pick_1 = pick;
var SetCache = _SetCache;
var arrayIncludes = _arrayIncludes;
var arrayIncludesWith = _arrayIncludesWith;
var arrayMap$1 = _arrayMap;
var baseUnary$1 = _baseUnary;
var cacheHas = _cacheHas;
var LARGE_ARRAY_SIZE = 200;
function baseDifference$2(array4, values2, iteratee, comparator) {
  var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array4.length, result = [], valuesLength = values2.length;
  if (!length) {
    return result;
  }
  if (iteratee) {
    values2 = arrayMap$1(values2, baseUnary$1(iteratee));
  }
  if (comparator) {
    includes2 = arrayIncludesWith;
    isCommon = false;
  } else if (values2.length >= LARGE_ARRAY_SIZE) {
    includes2 = cacheHas;
    isCommon = false;
    values2 = new SetCache(values2);
  }
  outer:
    while (++index2 < length) {
      var value = array4[index2], computed2 = iteratee == null ? value : iteratee(value);
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed2 === computed2) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values2[valuesIndex] === computed2) {
            continue outer;
          }
        }
        result.push(value);
      } else if (!includes2(values2, computed2, comparator)) {
        result.push(value);
      }
    }
  return result;
}
var _baseDifference = baseDifference$2;
var baseDifference$1 = _baseDifference;
var baseRest$2 = _baseRest;
var isArrayLikeObject$1 = isArrayLikeObject_1;
var without = baseRest$2(function(array4, values2) {
  return isArrayLikeObject$1(array4) ? baseDifference$1(array4, values2) : [];
});
var without_1 = without;
function isBuffer2(obj) {
  return obj && obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function keyIdentity(key) {
  return key;
}
function flatten(target, opts) {
  opts = opts || {};
  var delimiter = opts.delimiter || ".";
  var maxDepth = opts.maxDepth;
  var transformKey = opts.transformKey || keyIdentity;
  var output = {};
  function step(object9, prev, currentDepth) {
    currentDepth = currentDepth || 1;
    Object.keys(object9).forEach(function(key) {
      var value = object9[key];
      var isarray = opts.safe && Array.isArray(value);
      var type = Object.prototype.toString.call(value);
      var isbuffer = isBuffer2(value);
      var isobject = type === "[object Object]" || type === "[object Array]";
      var newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);
      if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {
        return step(value, newKey, currentDepth + 1);
      }
      output[newKey] = value;
    });
  }
  step(target);
  return output;
}
var baseDifference = _baseDifference;
var baseFlatten$2 = _baseFlatten;
var baseRest$1 = _baseRest;
var isArrayLikeObject = isArrayLikeObject_1;
var difference = baseRest$1(function(array4, values2) {
  return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten$2(values2, 1, isArrayLikeObject, true)) : [];
});
var difference_1 = difference;
function shouldApplyPlugin(name2, plugin) {
  if (!plugin.apply && difference_1(Object.keys(plugin), ["config", "install"]).length > 0) {
    return true;
  }
  var apply2 = plugin.apply;
  if (!Array.isArray(apply2)) {
    apply2 = [apply2];
  }
  var shouldApply = false;
  each(apply2, (condition2) => {
    if (typeof condition2 === "string" && condition2 === name2) {
      shouldApply = true;
      return false;
    } else if (typeof condition2 === "object" && condition2 instanceof RegExp && name2.match(condition2)) {
      shouldApply = true;
      return false;
    }
  });
  return shouldApply;
}
var name = "@vueform/vueform";
var version$1 = "1.9.9";
var description = "Open-Source Form Framework for Vue";
var homepage = "https://vueform.com";
var license = "MIT";
var authors = [
  {
    name: "Adam Berecz",
    email: "adam@vueform.com"
  }
];
var sideEffects = [
  "./themes/tailwind/templates/**/*.css",
  "./themes/vueform/templates/**/*.css"
];
var main = "./dist/index.mjs";
var module2 = "./dist/index.mjs";
var types = "./types/index.d.ts";
var exports = {
  ".": {
    types: "./types/index.d.ts",
    "default": "./dist/index.mjs"
  },
  "./core": {
    types: "./types/index.d.ts",
    "default": "./dist/core.mjs"
  },
  "./core.js": {
    types: "./types/index.d.ts",
    "default": "./dist/core.mjs"
  },
  "./element": "./element.mjs",
  "./element.js": "./element.mjs",
  "./plugin": "./plugin.mjs",
  "./plugin.js": "./plugin.mjs",
  "./locales/*.js": "./locales/*/index.mjs",
  "./locales/*": "./locales/*/index.mjs",
  "./src/*": "./src/*",
  "./types/*": "./types/*",
  "./dist/*.js": "./dist/*.mjs",
  "./dist/*": "./dist/*.mjs",
  "./dist/*.css": "./dist/*.css",
  "./tailwind": "./tailwind.js",
  "./tailwind.js": "./tailwind.js",
  "./vite": "./vite.js",
  "./vite.js": "./vite.js",
  "./vite.d.ts": "./vite.d.ts",
  "./tailwind-prefixer": "./tailwind-prefixer.js",
  "./tailwind-prefixer.js": "./tailwind-prefixer.js",
  "./postcss.config": "./postcss.config.js",
  "./postcss.config.js": "./postcss.config.js",
  "./tailwind.config": "./tailwind.config.js",
  "./tailwind.config.js": "./tailwind.config.js",
  "./package.json": "./package.json",
  "./themes/blank/templates/*": "./themes/blank/templates/*",
  "./themes/blank/*": "./themes/blank/*.mjs",
  "./themes/blank/*.js": "./themes/blank/*.mjs",
  "./themes/bootstrap/css/*": "./themes/bootstrap/css/*",
  "./themes/bootstrap/scss/*": "./themes/bootstrap/scss/*",
  "./themes/bootstrap/*": "./themes/bootstrap/*.mjs",
  "./themes/bootstrap/*.js": "./themes/bootstrap/*.mjs",
  "./themes/bootstrap.js": "./themes/bootstrap/index.mjs",
  "./themes/material/css/*": "./themes/material/css/*",
  "./themes/material/scss/*": "./themes/material/scss/*",
  "./themes/material/*": "./themes/material/*.mjs",
  "./themes/material/*.js": "./themes/material/*.mjs",
  "./themes/material.js": "./themes/material/index.mjs",
  "./themes/tailwind/templates/*": "./themes/tailwind/templates/*",
  "./themes/tailwind/*": "./themes/tailwind/*.mjs",
  "./themes/tailwind/*.js": "./themes/tailwind/*.mjs",
  "./themes/tailwind.js": "./themes/tailwind/index.mjs",
  "./themes/tailwind-material/css/*": "./themes/tailwind-material/css/*",
  "./themes/tailwind-material/scss/*": "./themes/tailwind-material/scss/*",
  "./themes/tailwind-material/*": "./themes/tailwind-material/*.mjs",
  "./themes/tailwind-material/*.js": "./themes/tailwind-material/*.mjs",
  "./themes/tailwind-material.js": "./themes/tailwind-material/index.mjs",
  "./themes/vueform/css/*": "./themes/vueform/css/*",
  "./themes/vueform/scss/*": "./themes/vueform/scss/*",
  "./themes/vueform/templates/*": "./themes/vueform/templates/*",
  "./themes/vueform/*": "./themes/vueform/*.mjs",
  "./themes/vueform/*.js": "./themes/vueform/*.mjs",
  "./themes/vueform.js": "./themes/vueform/index.mjs",
  "./themes/*": {
    types: "./dist/*.d.mts",
    "default": "./themes/*/index.mjs"
  }
};
var scripts = {
  build: "npm run build3 && npm run build2 && npm run generate",
  build2: "node ./scripts/pre-build-vue2 && rollup --config build/rollup.vue2.config.js && node ./scripts/post-build-vue2",
  build3: "rollup --config build/rollup.config.js",
  test: 'npm run generate:elements-base && NODE_OPTIONS="--max_old_space_size=5120 --no-experimental-fetch" VUE=3 jest --config=./tests/jest.config.js',
  "generate:types": "npx babel-node  scripts/generate-types.js --presets @babel/preset-env",
  "generate:common-features": "npx babel-node scripts/generate-common-features.js --presets @babel/preset-env",
  "generate:element-features": "npx babel-node scripts/generate-element-features.js --presets @babel/preset-env",
  "generate:elements-base": "npx babel-node scripts/generate-elements-base.js --presets @babel/preset-env",
  "generate:elements": "npx babel-node scripts/generate-elements.js --presets @babel/preset-env",
  "generate:components": "npx babel-node scripts/generate-components.js --presets @babel/preset-env",
  generate: "npm run generate:common-features; npm run generate:element-features; npm run generate:elements-base; npm run generate:elements; npm run generate:components; npm run generate:types; npm run fix-locales",
  "fix-locales": "npx babel-node --presets @babel/preset-env ./scripts/fix-locales.js"
};
var devDependencies = {
  "@babel/core": "^7.2.2",
  "@babel/node": "^7.12.10",
  "@babel/preset-env": "^7.3.1",
  "@rollup/plugin-alias": "^5.1.0",
  "@rollup/plugin-babel": "^5.3.0",
  "@rollup/plugin-commonjs": "^22.0.1",
  "@rollup/plugin-json": "^4.1.0",
  "@rollup/plugin-node-resolve": "^13.0.6",
  "@testing-library/jest-dom": "^5.11.5",
  "@vue/compiler-sfc": "^3.0.0",
  "@vue/test-utils": "2.0.0-rc.16",
  autoprefixer: "^9",
  autosize: "^6.0.1",
  "babel-core": "^7.0.0-bridge.0",
  "babel-loader": "^8.0.5",
  "core-js": "^3.10.1",
  "css-loader": "^2.1.0",
  flatpickr: "^4.6.13",
  "flush-promises": "^1.0.2",
  "html-loader": "^1.3.2",
  jest: "^27.3.1",
  "jest-canvas-mock": "^2.3.1",
  "jest-environment-jsdom-sixteen": "^1.0.3",
  "jest-transform-stub": "^2.0.0",
  "json-loader": "^0.5.7",
  locutus: "^2.0.16",
  "module-alias": "^2.2.3",
  moxios: "^0.4.0",
  "mutationobserver-shim": "^0.3.7",
  ncp: "^2.0.0",
  "rollup-plugin-license": "^3.2.0",
  "rollup-plugin-postcss": "^4.0.1",
  "rollup-plugin-terser": "^7.0.2",
  "rollup-plugin-vue": "^6.0.0",
  "rollup-plugin-vue2": "npm:rollup-plugin-vue@^5.1.9",
  "sass-loader": "^7.1.0",
  sortablejs: "^1.15.0",
  tailwindcss: "npm:@tailwindcss/postcss7-compat@^2.0.2",
  vue: "3.3.13",
  "vue-jest": "npm:@vue/vue3-jest@^27.0.0-alpha.1",
  "vue-loader": "^15.10.0",
  "vue-template-compiler": "^2.7.8",
  vue2: "npm:vue@^2.7.0"
};
var dependencies = {
  "@popperjs/core": "^2.11.8",
  "@vueform/country-phones": "^1.0.0",
  "@vueform/multiselect": "^2.6.3",
  "@vueform/slider": "^2.1.7",
  "@vueform/toggle": "^2.1.3",
  axios: "^1.5.0",
  color: "^4.2.3",
  lodash: "^4.17.21",
  "mini-svg-data-uri": "^1.4.4",
  moment: "^2.29.4",
  nouislider: "^15.7.1",
  sass: "^1.66.1",
  trix: "^2.1.1",
  wnumb: "^1.2.0"
};
var packageJson = {
  "private": false,
  name,
  version: version$1,
  description,
  homepage,
  license,
  authors,
  sideEffects,
  main,
  module: module2,
  types,
  exports,
  scripts,
  devDependencies,
  dependencies
};
var normalize = function normalize2(value) {
  if (value === void 0 || typeof value != "string") {
    return value;
  }
  if (value.match(/^-*\d+$/)) {
    return parseInt(value, 10);
  } else if (value.match(/^\d+\.\d+$/)) {
    return parseFloat(value);
  } else {
    return value;
  }
};
var parse = (string2) => {
  var parseRule = () => {
    return string2.split(":")[0];
  };
  var parseAttributes = () => {
    var parts = string2.split(":");
    if (parts.length <= 1) {
      return null;
    }
    var attributes = {};
    var rule = parts[0];
    parts.shift();
    var params = parts.join(":");
    if (["regex", "not_regex"].indexOf(rule) !== -1) {
      attributes[0] = params;
      return attributes;
    }
    each(params.split(","), (attribute, index2) => {
      var attrParts = attribute.split("=");
      if (attrParts.length <= 1) {
        attributes[index2] = normalize(attribute);
      } else {
        attributes[attrParts[0]] = normalize(attrParts[1]);
      }
    });
    return attributes;
  };
  return {
    name: parseRule(),
    attributes: parseAttributes()
  };
};
function replaceWildcards(fillable, fill) {
  if (!fill.match(/\.([0-9]+)(?![a-zA-Z]+)/g)) {
    return fillable;
  }
  fill.match(/\.([0-9]+)(?![a-zA-Z]+)/g).forEach((match) => {
    fillable = fillable.replace(".*", match);
  });
  return fillable;
}
var baseTrim = _baseTrim;
var isObject3 = isObject_1;
var isSymbol$1 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN;
  }
  if (isObject3(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject3(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var toNumber = toNumber_1;
var INFINITY = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign2 = value < 0 ? -1 : 1;
    return sign2 * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_1 = toFinite$1;
var toFinite = toFinite_1;
function toInteger$5(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger$5;
var baseIndexOf = _baseIndexOf;
var isArrayLike$1 = isArrayLike_1;
var isString3 = isString_1;
var toInteger$4 = toInteger_1;
var values = values_1;
var nativeMax$2 = Math.max;
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike$1(collection) ? collection : values(collection);
  fromIndex = fromIndex && !guard ? toInteger$4(fromIndex) : 0;
  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax$2(length + fromIndex, 0);
  }
  return isString3(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
}
var includes_1 = includes;
function baseClamp$2(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var _baseClamp = baseClamp$2;
var baseClamp$1 = _baseClamp;
var baseToString$1 = _baseToString;
var toInteger$3 = toInteger_1;
var toString$2 = toString_1;
function startsWith(string2, target, position) {
  string2 = toString$2(string2);
  position = position == null ? 0 : baseClamp$1(toInteger$3(position), 0, string2.length);
  target = baseToString$1(target);
  return string2.slice(position, position + target.length) == target;
}
var startsWith_1 = startsWith;
var baseClamp = _baseClamp;
var baseToString = _baseToString;
var toInteger$2 = toInteger_1;
var toString$1 = toString_1;
function endsWith2(string2, target, position) {
  string2 = toString$1(string2);
  target = baseToString(target);
  var length = string2.length;
  position = position === void 0 ? length : baseClamp(toInteger$2(position), 0, length);
  var end = position;
  position -= target.length;
  return position >= 0 && string2.slice(position, end) == target;
}
var endsWith_1 = endsWith2;
function compare(actual, operator, expected, el$) {
  if (!operator) {
    return false;
  }
  actual = Array.isArray(actual) ? actual.map((e2) => normalize(e2)) : normalize(actual);
  expected = Array.isArray(expected) ? expected.map((e2) => normalize(e2)) : normalize(expected);
  switch (operator.toLowerCase()) {
    case ">":
      return isArray_1(actual) ? actual.every((a) => a > expected) : actual > expected;
    case ">=":
      return isArray_1(actual) ? actual.every((a) => a >= expected) : actual >= expected;
    case "<":
      return isArray_1(actual) ? actual.every((a) => a < expected) : actual < expected;
    case "<=":
      return isArray_1(actual) ? actual.every((a) => a <= expected) : actual <= expected;
    case "between":
      return actual > expected[0] && actual < expected[1];
    case "empty":
      if (isArray_1(actual)) {
        return !actual.length;
      } else if (actual && actual instanceof File) {
        return false;
      } else if (actual && typeof actual === "object") {
        var values2 = Object.values(actual);
        return !values2.length || values2.every((v) => ["", null, void 0].indexOf(v) !== -1);
      } else {
        return ["", null, void 0].indexOf(actual) !== -1;
      }
    case "not_empty":
      if (isArray_1(actual)) {
        return !!actual.length;
      } else if (actual && actual instanceof File) {
        return true;
      } else if (actual && typeof actual === "object") {
        var _values = Object.values(actual);
        return _values.length && _values.some((v) => ["", null, void 0].indexOf(v) === -1);
      } else {
        return ["", null, void 0].indexOf(actual) === -1;
      }
    case "==":
    case "in":
      if (isArray_1(expected)) {
        if (isArray_1(actual)) {
          return !expected.length ? !actual.length : actual.filter((a) => includes_1(expected, a)).length > 0;
        } else {
          return expected.indexOf(actual) !== -1;
        }
      } else {
        if (isArray_1(actual)) {
          return actual.indexOf(expected) !== -1;
        } else {
          return actual == expected;
        }
      }
    case "!=":
    case "not_in":
      if (isArray_1(expected)) {
        if (isArray_1(actual)) {
          return !expected.length ? !!actual.length : actual.filter((e2) => includes_1(expected, e2)).length == 0;
        } else {
          return expected.indexOf(actual) === -1;
        }
      } else {
        if (isArray_1(actual)) {
          return actual.indexOf(expected) === -1;
        } else {
          return actual != expected;
        }
      }
    case "today":
      if (!isArray_1(actual)) {
        actual = [actual];
      }
      return actual.length && actual.every((a) => moment_default(a, el$.valueDateFormat).isSame(moment_default(), "day"));
    case "before":
      if (!isArray_1(actual)) {
        actual = [actual];
      }
      return actual.length && actual.every((a) => {
        var date6 = moment_default(a, el$.valueDateFormat);
        return date6.isValid() && date6.isBefore(moment_default(expected === "today" ? void 0 : expected), "day");
      });
    case "after":
      if (!isArray_1(actual)) {
        actual = [actual];
      }
      return actual.length && actual.every((a) => {
        var date6 = moment_default(a, el$.valueDateFormat);
        return date6.isValid() && date6.isAfter(moment_default(expected === "today" ? void 0 : expected), "day");
      });
    case "^":
      return startsWith_1(actual, expected);
    case "$":
      return endsWith_1(actual, expected);
    case "*":
      return includes_1(actual, expected);
  }
}
var Factory = class {
  constructor(path, form$) {
    this.form$ = form$;
    this.element$ = form$.el$(path);
  }
  get rules() {
    var rules2 = Object.assign({}, this.form$.$vueform.services.validation.rules, this.form$.$vueform.rules);
    if (!rules2.in && rules2.in_) {
      rules2.in = rules2.in_;
    }
    return rules2;
  }
  makeAll(rules2) {
    var parsedRules = this.parseRules(rules2);
    if (parsedRules.length == 0) {
      return [];
    }
    return map_1(parsedRules, (rule) => {
      return this.make(rule);
    });
  }
  make(rule) {
    var ruleClass = typeof rule == "function" ? rule : Array.isArray(rule) ? rule[0] : this.rules[rule.name];
    if (!ruleClass) {
      throw new Error("Unknown rule: '".concat(rule.name, "'"));
    }
    return new ruleClass(rule !== null && rule !== void 0 && rule.name ? rule : {
      name: "custom_rule_".concat(Math.floor(Math.random() * 9e6) + 1e6),
      attributes: Array.isArray(rule) && rule[1] ? rule[1] : []
    }, {
      element$: this.element$
    });
  }
  parseRules(rules2) {
    if (!isArray_1(rules2)) {
      rules2 = rules2.split("|");
    }
    return rules2.map((rule) => {
      if (typeof rule == "function" || Array.isArray(rule)) {
        return rule;
      }
      return this.isConditional(rule) ? this.parseConditional(rule) : this.parse(rule);
    });
  }
  parse(rule) {
    return parse(rule);
  }
  isConditional(rule) {
    return isPlainObject_1(rule);
  }
  parseConditional(rule) {
    var _conditions = values_1(rule)[0];
    if (!Array.isArray(_conditions[0])) {
      _conditions = [_conditions];
    }
    var parsed = _objectSpread2$1(_objectSpread2$1({}, parse(keys_1(rule)[0])), {}, {
      conditions: (form$, Validator2, el$) => {
        return _conditions.every((condition2) => {
          if (isArray_1(condition2)) {
            if (isArray_1(condition2[0])) {
              return condition2.some((subcondition) => {
                if (isArray_1(subcondition)) {
                  return this.createConditionFromArray(subcondition)(form$, Validator2, el$);
                } else {
                  return condition2(form$, Validator2, el$);
                }
              });
            } else {
              return this.createConditionFromArray(condition2)(form$, Validator2, el$);
            }
          } else {
            return condition2(form$, Validator2, el$);
          }
        });
      },
      dependents: []
    });
    _conditions.forEach((condition2) => {
      if (isArray_1(condition2)) {
        if (isArray_1(condition2[0])) {
          condition2.forEach((subcondition) => {
            if (isArray_1(subcondition)) {
              parsed.dependents.push(replaceWildcards(subcondition[0], this.element$.path));
            }
          });
        } else {
          parsed.dependents.push(replaceWildcards(condition2[0], this.element$.path));
        }
      }
    });
    return parsed;
  }
  createConditionFromArray(condition2) {
    var field = replaceWildcards(condition2[0], this.element$.path);
    var operator = condition2.length == 3 || ["empty", "not_empty", "today"].indexOf(condition2[1]) !== -1 ? condition2[1] : "==";
    var value = condition2.length == 3 ? condition2[2] : ["empty", "not_empty", "today"].indexOf(condition2[1]) === -1 ? condition2[1] : true;
    return (form$, Validator2, el$) => {
      var actual = get_1(form$.requestData, field);
      var expected = value;
      return compare(actual, operator, expected, this.element$);
    };
  }
};
var accepted = class extends Validator {
  check(value) {
    return ["yes", "on", "1", 1, true, "true"].indexOf(value) !== -1;
  }
};
var active_url = class extends Validator {
  get isAsync() {
    return true;
  }
  check(value) {
    var _this = this;
    return _asyncToGenerator(function* () {
      var endpoint = _this.form$.$vueform.config.endpoints.activeUrl;
      var method = typeof endpoint !== "function" ? endpoint.method : null;
      var res;
      if (typeof endpoint === "function") {
        res = yield endpoint(value, _this.element$, _this.form$);
      } else {
        res = yield _this.form$.$vueform.services.axios.request({
          url: endpoint.url,
          method,
          [method.toLowerCase() === "get" ? "params" : "data"]: {
            url: value
          }
        });
      }
      return res.data;
    })();
  }
};
var after = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      date: this.date.format(this.format)
    };
  }
  get param() {
    return this.attributes[0];
  }
  get format() {
    return ["date", "dates"].indexOf(this.element$.type) !== -1 && this.element$.valueFormat ? this.element$.valueFormat : "YYYY-MM-DD";
  }
  get otherFormat() {
    if (this.dateType != "element") {
      return this.format;
    }
    return ["date", "dates"].indexOf(this.other$.type) !== -1 && this.other$.valueFormat ? this.other$.valueFormat : this.format;
  }
  get otherPath() {
    if (this.dateType != "element") {
      return null;
    }
    return this.param;
  }
  get other$() {
    if (this.dateType != "element") {
      return {};
    }
    return this.form$.el$(this.param);
  }
  get date() {
    var date6 = "";
    switch (this.dateType) {
      case "relative":
        if (this.param === "today") {
          date6 = moment_default().startOf("day");
        }
        if (this.param === "tomorrow") {
          date6 = moment_default().startOf("day").add(1, "days");
        }
        if (this.param === "yesterday") {
          date6 = moment_default().startOf("day").subtract(1, "days");
        }
        break;
      case "element":
        date6 = moment_default(this.other$.value, this.otherFormat);
        break;
      case "absolute":
        date6 = moment_default(this.param, this.format);
        break;
    }
    return date6;
  }
  get dateType() {
    if (["today", "tomorrow", "yesterday"].indexOf(this.param) !== -1) {
      return "relative";
    } else if (this.form$.el$(this.param)) {
      return "element";
    } else {
      return "absolute";
    }
  }
  init() {
    this.form$.$nextTick(() => {
      if (this.dateType == "element") {
        this.watchOther();
      }
    });
  }
  check(value) {
    if (isArray_1(value)) {
      var valid = true;
      each(value, (date6) => {
        if (!this.checkDate(date6)) {
          valid = false;
        }
      });
      return valid;
    }
    return this.checkDate(value);
  }
  checkDate(value) {
    return moment_default(value, this.format).isAfter(moment_default(this.date, this.otherFormat));
  }
};
var after_or_equal = class extends after {
  checkDate(value) {
    return moment_default(value, this.format).isSameOrAfter(moment_default(this.date, this.otherFormat));
  }
};
var alpha = class extends Validator {
  check(value) {
    return /^[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/.test(value);
  }
};
var alpha_dash = class extends Validator {
  check(value) {
    return /^[0-9-_\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/.test(value);
  }
};
var alpha_num = class extends Validator {
  check(value) {
    return /^[0-9\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/.test(value);
  }
};
var array$2 = class extends Validator {
  check(value) {
    return isArray_1(value);
  }
};
var before = class extends after {
  checkDate(value) {
    return moment_default(value, this.format).isBefore(moment_default(this.date, this.otherFormat));
  }
};
var before_or_equal = class extends after {
  checkDate(value) {
    return moment_default(value, this.format).isSameOrBefore(moment_default(this.date, this.otherFormat));
  }
};
var between = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      min: this.min,
      max: this.max
    };
  }
  get min() {
    return this.attributes[0];
  }
  get max() {
    return this.attributes[1];
  }
  check(value) {
    if (!value) {
      return true;
    }
    var size2 = this.size(value);
    return size2 >= this.min && size2 <= this.max;
  }
};
var boolean$1 = class extends Validator {
  check(value) {
    var accepted2 = [true, false, 0, 1, "0", "1"];
    return accepted2.indexOf(value) !== -1;
  }
};
var captcha$2 = class extends Validator {
  get isAsync() {
    return true;
  }
  check(value) {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (!_this.element$.shouldVerify) {
        return true;
      }
      return yield _this.element$.Provider.validate(_this.element$.Provider.getResponse());
    })();
  }
};
var completed = class extends Validator {
  get debounce() {
    if (this.attributes.debounce !== void 0) {
      return this.attributes.debounce;
    }
    if (this.element$.debounce !== null) {
      return this.element$.debounce;
    }
    return 1e3;
  }
  check(value) {
    var _this$element$$Mask$m;
    if (!this.element$.Mask) {
      return this.filled(value);
    }
    var isComplete = (_this$element$$Mask$m = this.element$.Mask.masked.currentMask) === null || _this$element$$Mask$m === void 0 ? void 0 : _this$element$$Mask$m.isComplete;
    return isComplete === void 0 || this.element$.empty ? true : isComplete;
  }
};
var confirmed = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      other: this.other$.genericName
    };
  }
  get otherPath() {
    return "".concat(this.element$.path, "_confirmation");
  }
  get other$() {
    return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
  }
  init() {
    this.watchOther();
  }
  check(value) {
    if (!this.filled(this.other$.value)) {
      return true;
    }
    return value == this.other$.value;
  }
};
var reSpace = "[ \\t]+";
var reSpaceOpt = "[ \\t]*";
var reMeridian = "(?:([ap])\\.?m\\.?([\\t ]|$))";
var reHour24 = "(2[0-4]|[01]?[0-9])";
var reHour24lz = "([01][0-9]|2[0-4])";
var reHour12 = "(0?[1-9]|1[0-2])";
var reMinute = "([0-5]?[0-9])";
var reMinutelz = "([0-5][0-9])";
var reSecond = "(60|[0-5]?[0-9])";
var reSecondlz = "(60|[0-5][0-9])";
var reFrac = "(?:\\.([0-9]+))";
var reDayfull = "sunday|monday|tuesday|wednesday|thursday|friday|saturday";
var reDayabbr = "sun|mon|tue|wed|thu|fri|sat";
var reDaytext = reDayfull + "|" + reDayabbr + "|weekdays?";
var reReltextnumber = "first|second|third|fourth|fifth|sixth|seventh|eighth?|ninth|tenth|eleventh|twelfth";
var reReltexttext = "next|last|previous|this";
var reReltextunit = "(?:second|sec|minute|min|hour|day|fortnight|forthnight|month|year)s?|weeks|" + reDaytext;
var reYear = "([0-9]{1,4})";
var reYear2 = "([0-9]{2})";
var reYear4 = "([0-9]{4})";
var reYear4withSign = "([+-]?[0-9]{4})";
var reMonth = "(1[0-2]|0?[0-9])";
var reMonthlz = "(0[0-9]|1[0-2])";
var reDay = "(?:(3[01]|[0-2]?[0-9])(?:st|nd|rd|th)?)";
var reDaylz = "(0[0-9]|[1-2][0-9]|3[01])";
var reMonthFull = "january|february|march|april|may|june|july|august|september|october|november|december";
var reMonthAbbr = "jan|feb|mar|apr|may|jun|jul|aug|sept?|oct|nov|dec";
var reMonthroman = "i[vx]|vi{0,3}|xi{0,2}|i{1,3}";
var reMonthText = "(" + reMonthFull + "|" + reMonthAbbr + "|" + reMonthroman + ")";
var reTzCorrection = "((?:GMT)?([+-])" + reHour24 + ":?" + reMinute + "?)";
var reTzAbbr = "\\(?([a-zA-Z]{1,6})\\)?";
var reDayOfYear = "(00[1-9]|0[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6])";
var reWeekOfYear = "(0[1-9]|[1-4][0-9]|5[0-3])";
var reDateNoYear = reMonthText + "[ .\\t-]*" + reDay + "[,.stndrh\\t ]*";
function processMeridian(hour, meridian) {
  meridian = meridian && meridian.toLowerCase();
  switch (meridian) {
    case "a":
      hour += hour === 12 ? -12 : 0;
      break;
    case "p":
      hour += hour !== 12 ? 12 : 0;
      break;
  }
  return hour;
}
function processYear(yearStr) {
  var year = +yearStr;
  if (yearStr.length < 4 && year < 100) {
    year += year < 70 ? 2e3 : 1900;
  }
  return year;
}
function lookupMonth(monthStr) {
  return {
    jan: 0,
    january: 0,
    i: 0,
    feb: 1,
    february: 1,
    ii: 1,
    mar: 2,
    march: 2,
    iii: 2,
    apr: 3,
    april: 3,
    iv: 3,
    may: 4,
    v: 4,
    jun: 5,
    june: 5,
    vi: 5,
    jul: 6,
    july: 6,
    vii: 6,
    aug: 7,
    august: 7,
    viii: 7,
    sep: 8,
    sept: 8,
    september: 8,
    ix: 8,
    oct: 9,
    october: 9,
    x: 9,
    nov: 10,
    november: 10,
    xi: 10,
    dec: 11,
    december: 11,
    xii: 11
  }[monthStr.toLowerCase()];
}
function lookupWeekday(dayStr) {
  var desiredSundayNumber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var dayNumbers = {
    mon: 1,
    monday: 1,
    tue: 2,
    tuesday: 2,
    wed: 3,
    wednesday: 3,
    thu: 4,
    thursday: 4,
    fri: 5,
    friday: 5,
    sat: 6,
    saturday: 6,
    sun: 0,
    sunday: 0
  };
  return dayNumbers[dayStr.toLowerCase()] || desiredSundayNumber;
}
function lookupRelative(relText) {
  var relativeNumbers = {
    last: -1,
    previous: -1,
    this: 0,
    first: 1,
    next: 1,
    second: 2,
    third: 3,
    fourth: 4,
    fifth: 5,
    sixth: 6,
    seventh: 7,
    eight: 8,
    eighth: 8,
    ninth: 9,
    tenth: 10,
    eleventh: 11,
    twelfth: 12
  };
  var relativeBehavior = {
    this: 1
  };
  var relTextLower = relText.toLowerCase();
  return {
    amount: relativeNumbers[relTextLower],
    behavior: relativeBehavior[relTextLower] || 0
  };
}
function processTzCorrection(tzOffset, oldValue) {
  var reTzCorrectionLoose = /(?:GMT)?([+-])(\d+)(:?)(\d{0,2})/i;
  tzOffset = tzOffset && tzOffset.match(reTzCorrectionLoose);
  if (!tzOffset) {
    return oldValue;
  }
  var sign2 = tzOffset[1] === "-" ? -1 : 1;
  var hours2 = +tzOffset[2];
  var minutes2 = +tzOffset[4];
  if (!tzOffset[4] && !tzOffset[3]) {
    minutes2 = Math.floor(hours2 % 100);
    hours2 = Math.floor(hours2 / 100);
  }
  return sign2 * (hours2 * 60 + minutes2) * 60;
}
var tzAbbrOffsets = {
  acdt: 37800,
  acst: 34200,
  addt: -7200,
  adt: -10800,
  aedt: 39600,
  aest: 36e3,
  ahdt: -32400,
  ahst: -36e3,
  akdt: -28800,
  akst: -32400,
  amt: -13840,
  apt: -10800,
  ast: -14400,
  awdt: 32400,
  awst: 28800,
  awt: -10800,
  bdst: 7200,
  bdt: -36e3,
  bmt: -14309,
  bst: 3600,
  cast: 34200,
  cat: 7200,
  cddt: -14400,
  cdt: -18e3,
  cemt: 10800,
  cest: 7200,
  cet: 3600,
  cmt: -15408,
  cpt: -18e3,
  cst: -21600,
  cwt: -18e3,
  chst: 36e3,
  dmt: -1521,
  eat: 10800,
  eddt: -10800,
  edt: -14400,
  eest: 10800,
  eet: 7200,
  emt: -26248,
  ept: -14400,
  est: -18e3,
  ewt: -14400,
  ffmt: -14660,
  fmt: -4056,
  gdt: 39600,
  gmt: 0,
  gst: 36e3,
  hdt: -34200,
  hkst: 32400,
  hkt: 28800,
  hmt: -19776,
  hpt: -34200,
  hst: -36e3,
  hwt: -34200,
  iddt: 14400,
  idt: 10800,
  imt: 25025,
  ist: 7200,
  jdt: 36e3,
  jmt: 8440,
  jst: 32400,
  kdt: 36e3,
  kmt: 5736,
  kst: 30600,
  lst: 9394,
  mddt: -18e3,
  mdst: 16279,
  mdt: -21600,
  mest: 7200,
  met: 3600,
  mmt: 9017,
  mpt: -21600,
  msd: 14400,
  msk: 10800,
  mst: -25200,
  mwt: -21600,
  nddt: -5400,
  ndt: -9052,
  npt: -9e3,
  nst: -12600,
  nwt: -9e3,
  nzdt: 46800,
  nzmt: 41400,
  nzst: 43200,
  pddt: -21600,
  pdt: -25200,
  pkst: 21600,
  pkt: 18e3,
  plmt: 25590,
  pmt: -13236,
  ppmt: -17340,
  ppt: -25200,
  pst: -28800,
  pwt: -25200,
  qmt: -18840,
  rmt: 5794,
  sast: 7200,
  sdmt: -16800,
  sjmt: -20173,
  smt: -13884,
  sst: -39600,
  tbmt: 10751,
  tmt: 12344,
  uct: 0,
  utc: 0,
  wast: 7200,
  wat: 3600,
  wemt: 7200,
  west: 3600,
  wet: 0,
  wib: 25200,
  wita: 28800,
  wit: 32400,
  wmt: 5040,
  yddt: -25200,
  ydt: -28800,
  ypt: -28800,
  yst: -32400,
  ywt: -28800,
  a: 3600,
  b: 7200,
  c: 10800,
  d: 14400,
  e: 18e3,
  f: 21600,
  g: 25200,
  h: 28800,
  i: 32400,
  k: 36e3,
  l: 39600,
  m: 43200,
  n: -3600,
  o: -7200,
  p: -10800,
  q: -14400,
  r: -18e3,
  s: -21600,
  t: -25200,
  u: -28800,
  v: -32400,
  w: -36e3,
  x: -39600,
  y: -43200,
  z: 0
};
var formats$1 = {
  yesterday: {
    regex: /^yesterday/i,
    name: "yesterday",
    callback: function callback() {
      this.rd -= 1;
      return this.resetTime();
    }
  },
  now: {
    regex: /^now/i,
    name: "now"
    // do nothing
  },
  noon: {
    regex: /^noon/i,
    name: "noon",
    callback: function callback2() {
      return this.resetTime() && this.time(12, 0, 0, 0);
    }
  },
  midnightOrToday: {
    regex: /^(midnight|today)/i,
    name: "midnight | today",
    callback: function callback3() {
      return this.resetTime();
    }
  },
  tomorrow: {
    regex: /^tomorrow/i,
    name: "tomorrow",
    callback: function callback4() {
      this.rd += 1;
      return this.resetTime();
    }
  },
  timestamp: {
    regex: /^@(-?\d+)/i,
    name: "timestamp",
    callback: function callback5(match, timestamp) {
      this.rs += +timestamp;
      this.y = 1970;
      this.m = 0;
      this.d = 1;
      this.dates = 0;
      return this.resetTime() && this.zone(0);
    }
  },
  firstOrLastDay: {
    regex: /^(first|last) day of/i,
    name: "firstdayof | lastdayof",
    callback: function callback6(match, day) {
      if (day.toLowerCase() === "first") {
        this.firstOrLastDayOfMonth = 1;
      } else {
        this.firstOrLastDayOfMonth = -1;
      }
    }
  },
  backOrFrontOf: {
    regex: RegExp("^(back|front) of " + reHour24 + reSpaceOpt + reMeridian + "?", "i"),
    name: "backof | frontof",
    callback: function callback7(match, side, hours2, meridian) {
      var back = side.toLowerCase() === "back";
      var hour = +hours2;
      var minute = 15;
      if (!back) {
        hour -= 1;
        minute = 45;
      }
      hour = processMeridian(hour, meridian);
      return this.resetTime() && this.time(hour, minute, 0, 0);
    }
  },
  weekdayOf: {
    regex: RegExp("^(" + reReltextnumber + "|" + reReltexttext + ")" + reSpace + "(" + reDayfull + "|" + reDayabbr + ")" + reSpace + "of", "i"),
    name: "weekdayof"
    // todo
  },
  mssqltime: {
    regex: RegExp("^" + reHour12 + ":" + reMinutelz + ":" + reSecondlz + "[:.]([0-9]+)" + reMeridian, "i"),
    name: "mssqltime",
    callback: function callback8(match, hour, minute, second, frac, meridian) {
      return this.time(processMeridian(+hour, meridian), +minute, +second, +frac.substr(0, 3));
    }
  },
  oracledate: {
    regex: /^(\d{2})-([A-Z]{3})-(\d{2})$/i,
    name: "d-M-y",
    callback: function callback9(match, day, monthText, year) {
      var month = {
        JAN: 0,
        FEB: 1,
        MAR: 2,
        APR: 3,
        MAY: 4,
        JUN: 5,
        JUL: 6,
        AUG: 7,
        SEP: 8,
        OCT: 9,
        NOV: 10,
        DEC: 11
      }[monthText.toUpperCase()];
      return this.ymd(2e3 + parseInt(year, 10), month, parseInt(day, 10));
    }
  },
  timeLong12: {
    regex: RegExp("^" + reHour12 + "[:.]" + reMinute + "[:.]" + reSecondlz + reSpaceOpt + reMeridian, "i"),
    name: "timelong12",
    callback: function callback10(match, hour, minute, second, meridian) {
      return this.time(processMeridian(+hour, meridian), +minute, +second, 0);
    }
  },
  timeShort12: {
    regex: RegExp("^" + reHour12 + "[:.]" + reMinutelz + reSpaceOpt + reMeridian, "i"),
    name: "timeshort12",
    callback: function callback11(match, hour, minute, meridian) {
      return this.time(processMeridian(+hour, meridian), +minute, 0, 0);
    }
  },
  timeTiny12: {
    regex: RegExp("^" + reHour12 + reSpaceOpt + reMeridian, "i"),
    name: "timetiny12",
    callback: function callback12(match, hour, meridian) {
      return this.time(processMeridian(+hour, meridian), 0, 0, 0);
    }
  },
  soap: {
    regex: RegExp("^" + reYear4 + "-" + reMonthlz + "-" + reDaylz + "T" + reHour24lz + ":" + reMinutelz + ":" + reSecondlz + reFrac + reTzCorrection + "?", "i"),
    name: "soap",
    callback: function callback13(match, year, month, day, hour, minute, second, frac, tzCorrection) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, +frac.substr(0, 3)) && this.zone(processTzCorrection(tzCorrection));
    }
  },
  wddx: {
    regex: RegExp("^" + reYear4 + "-" + reMonth + "-" + reDay + "T" + reHour24 + ":" + reMinute + ":" + reSecond),
    name: "wddx",
    callback: function callback14(match, year, month, day, hour, minute, second) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
    }
  },
  exif: {
    regex: RegExp("^" + reYear4 + ":" + reMonthlz + ":" + reDaylz + " " + reHour24lz + ":" + reMinutelz + ":" + reSecondlz, "i"),
    name: "exif",
    callback: function callback15(match, year, month, day, hour, minute, second) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
    }
  },
  xmlRpc: {
    regex: RegExp("^" + reYear4 + reMonthlz + reDaylz + "T" + reHour24 + ":" + reMinutelz + ":" + reSecondlz),
    name: "xmlrpc",
    callback: function callback16(match, year, month, day, hour, minute, second) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
    }
  },
  xmlRpcNoColon: {
    regex: RegExp("^" + reYear4 + reMonthlz + reDaylz + "[Tt]" + reHour24 + reMinutelz + reSecondlz),
    name: "xmlrpcnocolon",
    callback: function callback17(match, year, month, day, hour, minute, second) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
    }
  },
  clf: {
    regex: RegExp("^" + reDay + "/(" + reMonthAbbr + ")/" + reYear4 + ":" + reHour24lz + ":" + reMinutelz + ":" + reSecondlz + reSpace + reTzCorrection, "i"),
    name: "clf",
    callback: function callback18(match, day, month, year, hour, minute, second, tzCorrection) {
      return this.ymd(+year, lookupMonth(month), +day) && this.time(+hour, +minute, +second, 0) && this.zone(processTzCorrection(tzCorrection));
    }
  },
  iso8601long: {
    regex: RegExp("^t?" + reHour24 + "[:.]" + reMinute + "[:.]" + reSecond + reFrac, "i"),
    name: "iso8601long",
    callback: function callback19(match, hour, minute, second, frac) {
      return this.time(+hour, +minute, +second, +frac.substr(0, 3));
    }
  },
  dateTextual: {
    regex: RegExp("^" + reMonthText + "[ .\\t-]*" + reDay + "[,.stndrh\\t ]+" + reYear, "i"),
    name: "datetextual",
    callback: function callback20(match, month, day, year) {
      return this.ymd(processYear(year), lookupMonth(month), +day);
    }
  },
  pointedDate4: {
    regex: RegExp("^" + reDay + "[.\\t-]" + reMonth + "[.-]" + reYear4),
    name: "pointeddate4",
    callback: function callback21(match, day, month, year) {
      return this.ymd(+year, month - 1, +day);
    }
  },
  pointedDate2: {
    regex: RegExp("^" + reDay + "[.\\t]" + reMonth + "\\." + reYear2),
    name: "pointeddate2",
    callback: function callback22(match, day, month, year) {
      return this.ymd(processYear(year), month - 1, +day);
    }
  },
  timeLong24: {
    regex: RegExp("^t?" + reHour24 + "[:.]" + reMinute + "[:.]" + reSecond),
    name: "timelong24",
    callback: function callback23(match, hour, minute, second) {
      return this.time(+hour, +minute, +second, 0);
    }
  },
  dateNoColon: {
    regex: RegExp("^" + reYear4 + reMonthlz + reDaylz),
    name: "datenocolon",
    callback: function callback24(match, year, month, day) {
      return this.ymd(+year, month - 1, +day);
    }
  },
  pgydotd: {
    regex: RegExp("^" + reYear4 + "\\.?" + reDayOfYear),
    name: "pgydotd",
    callback: function callback25(match, year, day) {
      return this.ymd(+year, 0, +day);
    }
  },
  timeShort24: {
    regex: RegExp("^t?" + reHour24 + "[:.]" + reMinute, "i"),
    name: "timeshort24",
    callback: function callback26(match, hour, minute) {
      return this.time(+hour, +minute, 0, 0);
    }
  },
  iso8601noColon: {
    regex: RegExp("^t?" + reHour24lz + reMinutelz + reSecondlz, "i"),
    name: "iso8601nocolon",
    callback: function callback27(match, hour, minute, second) {
      return this.time(+hour, +minute, +second, 0);
    }
  },
  iso8601dateSlash: {
    // eventhough the trailing slash is optional in PHP
    // here it's mandatory and inputs without the slash
    // are handled by dateslash
    regex: RegExp("^" + reYear4 + "/" + reMonthlz + "/" + reDaylz + "/"),
    name: "iso8601dateslash",
    callback: function callback28(match, year, month, day) {
      return this.ymd(+year, month - 1, +day);
    }
  },
  dateSlash: {
    regex: RegExp("^" + reYear4 + "/" + reMonth + "/" + reDay),
    name: "dateslash",
    callback: function callback29(match, year, month, day) {
      return this.ymd(+year, month - 1, +day);
    }
  },
  american: {
    regex: RegExp("^" + reMonth + "/" + reDay + "/" + reYear),
    name: "american",
    callback: function callback30(match, month, day, year) {
      return this.ymd(processYear(year), month - 1, +day);
    }
  },
  americanShort: {
    regex: RegExp("^" + reMonth + "/" + reDay),
    name: "americanshort",
    callback: function callback31(match, month, day) {
      return this.ymd(this.y, month - 1, +day);
    }
  },
  gnuDateShortOrIso8601date2: {
    // iso8601date2 is complete subset of gnudateshort
    regex: RegExp("^" + reYear + "-" + reMonth + "-" + reDay),
    name: "gnudateshort | iso8601date2",
    callback: function callback32(match, year, month, day) {
      return this.ymd(processYear(year), month - 1, +day);
    }
  },
  iso8601date4: {
    regex: RegExp("^" + reYear4withSign + "-" + reMonthlz + "-" + reDaylz),
    name: "iso8601date4",
    callback: function callback33(match, year, month, day) {
      return this.ymd(+year, month - 1, +day);
    }
  },
  gnuNoColon: {
    regex: RegExp("^t?" + reHour24lz + reMinutelz, "i"),
    name: "gnunocolon",
    callback: function callback34(match, hour, minute) {
      switch (this.times) {
        case 0:
          return this.time(+hour, +minute, 0, this.f);
        case 1:
          this.y = hour * 100 + +minute;
          this.times++;
          return true;
        default:
          return false;
      }
    }
  },
  gnuDateShorter: {
    regex: RegExp("^" + reYear4 + "-" + reMonth),
    name: "gnudateshorter",
    callback: function callback35(match, year, month) {
      return this.ymd(+year, month - 1, 1);
    }
  },
  pgTextReverse: {
    // note: allowed years are from 32-9999
    // years below 32 should be treated as days in datefull
    regex: RegExp("^(\\d{3,4}|[4-9]\\d|3[2-9])-(" + reMonthAbbr + ")-" + reDaylz, "i"),
    name: "pgtextreverse",
    callback: function callback36(match, year, month, day) {
      return this.ymd(processYear(year), lookupMonth(month), +day);
    }
  },
  dateFull: {
    regex: RegExp("^" + reDay + "[ \\t.-]*" + reMonthText + "[ \\t.-]*" + reYear, "i"),
    name: "datefull",
    callback: function callback37(match, day, month, year) {
      return this.ymd(processYear(year), lookupMonth(month), +day);
    }
  },
  dateNoDay: {
    regex: RegExp("^" + reMonthText + "[ .\\t-]*" + reYear4, "i"),
    name: "datenoday",
    callback: function callback38(match, month, year) {
      return this.ymd(+year, lookupMonth(month), 1);
    }
  },
  dateNoDayRev: {
    regex: RegExp("^" + reYear4 + "[ .\\t-]*" + reMonthText, "i"),
    name: "datenodayrev",
    callback: function callback39(match, year, month) {
      return this.ymd(+year, lookupMonth(month), 1);
    }
  },
  pgTextShort: {
    regex: RegExp("^(" + reMonthAbbr + ")-" + reDaylz + "-" + reYear, "i"),
    name: "pgtextshort",
    callback: function callback40(match, month, day, year) {
      return this.ymd(processYear(year), lookupMonth(month), +day);
    }
  },
  dateNoYear: {
    regex: RegExp("^" + reDateNoYear, "i"),
    name: "datenoyear",
    callback: function callback41(match, month, day) {
      return this.ymd(this.y, lookupMonth(month), +day);
    }
  },
  dateNoYearRev: {
    regex: RegExp("^" + reDay + "[ .\\t-]*" + reMonthText, "i"),
    name: "datenoyearrev",
    callback: function callback42(match, day, month) {
      return this.ymd(this.y, lookupMonth(month), +day);
    }
  },
  isoWeekDay: {
    regex: RegExp("^" + reYear4 + "-?W" + reWeekOfYear + "(?:-?([0-7]))?"),
    name: "isoweekday | isoweek",
    callback: function callback43(match, year, week, day) {
      day = day ? +day : 1;
      if (!this.ymd(+year, 0, 1)) {
        return false;
      }
      var dayOfWeek = new Date(this.y, this.m, this.d).getDay();
      dayOfWeek = 0 - (dayOfWeek > 4 ? dayOfWeek - 7 : dayOfWeek);
      this.rd += dayOfWeek + (week - 1) * 7 + day;
    }
  },
  relativeText: {
    regex: RegExp("^(" + reReltextnumber + "|" + reReltexttext + ")" + reSpace + "(" + reReltextunit + ")", "i"),
    name: "relativetext",
    callback: function callback44(match, relValue, relUnit) {
      var _lookupRelative = lookupRelative(relValue), amount = _lookupRelative.amount;
      switch (relUnit.toLowerCase()) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
          this.rs += amount;
          break;
        case "min":
        case "mins":
        case "minute":
        case "minutes":
          this.ri += amount;
          break;
        case "hour":
        case "hours":
          this.rh += amount;
          break;
        case "day":
        case "days":
          this.rd += amount;
          break;
        case "fortnight":
        case "fortnights":
        case "forthnight":
        case "forthnights":
          this.rd += amount * 14;
          break;
        case "week":
        case "weeks":
          this.rd += amount * 7;
          break;
        case "month":
        case "months":
          this.rm += amount;
          break;
        case "year":
        case "years":
          this.ry += amount;
          break;
        case "mon":
        case "monday":
        case "tue":
        case "tuesday":
        case "wed":
        case "wednesday":
        case "thu":
        case "thursday":
        case "fri":
        case "friday":
        case "sat":
        case "saturday":
        case "sun":
        case "sunday":
          this.resetTime();
          this.weekday = lookupWeekday(relUnit, 7);
          this.weekdayBehavior = 1;
          this.rd += (amount > 0 ? amount - 1 : amount) * 7;
          break;
      }
    }
  },
  relative: {
    regex: RegExp("^([+-]*)[ \\t]*(\\d+)" + reSpaceOpt + "(" + reReltextunit + "|week)", "i"),
    name: "relative",
    callback: function callback45(match, signs, relValue, relUnit) {
      var minuses = signs.replace(/[^-]/g, "").length;
      var amount = +relValue * Math.pow(-1, minuses);
      switch (relUnit.toLowerCase()) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
          this.rs += amount;
          break;
        case "min":
        case "mins":
        case "minute":
        case "minutes":
          this.ri += amount;
          break;
        case "hour":
        case "hours":
          this.rh += amount;
          break;
        case "day":
        case "days":
          this.rd += amount;
          break;
        case "fortnight":
        case "fortnights":
        case "forthnight":
        case "forthnights":
          this.rd += amount * 14;
          break;
        case "week":
        case "weeks":
          this.rd += amount * 7;
          break;
        case "month":
        case "months":
          this.rm += amount;
          break;
        case "year":
        case "years":
          this.ry += amount;
          break;
        case "mon":
        case "monday":
        case "tue":
        case "tuesday":
        case "wed":
        case "wednesday":
        case "thu":
        case "thursday":
        case "fri":
        case "friday":
        case "sat":
        case "saturday":
        case "sun":
        case "sunday":
          this.resetTime();
          this.weekday = lookupWeekday(relUnit, 7);
          this.weekdayBehavior = 1;
          this.rd += (amount > 0 ? amount - 1 : amount) * 7;
          break;
      }
    }
  },
  dayText: {
    regex: RegExp("^(" + reDaytext + ")", "i"),
    name: "daytext",
    callback: function callback46(match, dayText) {
      this.resetTime();
      this.weekday = lookupWeekday(dayText, 0);
      if (this.weekdayBehavior !== 2) {
        this.weekdayBehavior = 1;
      }
    }
  },
  relativeTextWeek: {
    regex: RegExp("^(" + reReltexttext + ")" + reSpace + "week", "i"),
    name: "relativetextweek",
    callback: function callback47(match, relText) {
      this.weekdayBehavior = 2;
      switch (relText.toLowerCase()) {
        case "this":
          this.rd += 0;
          break;
        case "next":
          this.rd += 7;
          break;
        case "last":
        case "previous":
          this.rd -= 7;
          break;
      }
      if (isNaN(this.weekday)) {
        this.weekday = 1;
      }
    }
  },
  monthFullOrMonthAbbr: {
    regex: RegExp("^(" + reMonthFull + "|" + reMonthAbbr + ")", "i"),
    name: "monthfull | monthabbr",
    callback: function callback48(match, month) {
      return this.ymd(this.y, lookupMonth(month), this.d);
    }
  },
  tzCorrection: {
    regex: RegExp("^" + reTzCorrection, "i"),
    name: "tzcorrection",
    callback: function callback49(tzCorrection) {
      return this.zone(processTzCorrection(tzCorrection));
    }
  },
  tzAbbr: {
    regex: RegExp("^" + reTzAbbr),
    name: "tzabbr",
    callback: function callback50(match, abbr) {
      var offset2 = tzAbbrOffsets[abbr.toLowerCase()];
      if (isNaN(offset2)) {
        return false;
      }
      return this.zone(offset2);
    }
  },
  ago: {
    regex: /^ago/i,
    name: "ago",
    callback: function callback51() {
      this.ry = -this.ry;
      this.rm = -this.rm;
      this.rd = -this.rd;
      this.rh = -this.rh;
      this.ri = -this.ri;
      this.rs = -this.rs;
      this.rf = -this.rf;
    }
  },
  year4: {
    regex: RegExp("^" + reYear4),
    name: "year4",
    callback: function callback52(match, year) {
      this.y = +year;
      return true;
    }
  },
  whitespace: {
    regex: /^[ .,\t]+/,
    name: "whitespace"
    // do nothing
  },
  dateShortWithTimeLong: {
    regex: RegExp("^" + reDateNoYear + "t?" + reHour24 + "[:.]" + reMinute + "[:.]" + reSecond, "i"),
    name: "dateshortwithtimelong",
    callback: function callback53(match, month, day, hour, minute, second) {
      return this.ymd(this.y, lookupMonth(month), +day) && this.time(+hour, +minute, +second, 0);
    }
  },
  dateShortWithTimeLong12: {
    regex: RegExp("^" + reDateNoYear + reHour12 + "[:.]" + reMinute + "[:.]" + reSecondlz + reSpaceOpt + reMeridian, "i"),
    name: "dateshortwithtimelong12",
    callback: function callback54(match, month, day, hour, minute, second, meridian) {
      return this.ymd(this.y, lookupMonth(month), +day) && this.time(processMeridian(+hour, meridian), +minute, +second, 0);
    }
  },
  dateShortWithTimeShort: {
    regex: RegExp("^" + reDateNoYear + "t?" + reHour24 + "[:.]" + reMinute, "i"),
    name: "dateshortwithtimeshort",
    callback: function callback55(match, month, day, hour, minute) {
      return this.ymd(this.y, lookupMonth(month), +day) && this.time(+hour, +minute, 0, 0);
    }
  },
  dateShortWithTimeShort12: {
    regex: RegExp("^" + reDateNoYear + reHour12 + "[:.]" + reMinutelz + reSpaceOpt + reMeridian, "i"),
    name: "dateshortwithtimeshort12",
    callback: function callback56(match, month, day, hour, minute, meridian) {
      return this.ymd(this.y, lookupMonth(month), +day) && this.time(processMeridian(+hour, meridian), +minute, 0, 0);
    }
  }
};
var resultProto = {
  // date
  y: NaN,
  m: NaN,
  d: NaN,
  // time
  h: NaN,
  i: NaN,
  s: NaN,
  f: NaN,
  // relative shifts
  ry: 0,
  rm: 0,
  rd: 0,
  rh: 0,
  ri: 0,
  rs: 0,
  rf: 0,
  // weekday related shifts
  weekday: NaN,
  weekdayBehavior: 0,
  // first or last day of month
  // 0 none, 1 first, -1 last
  firstOrLastDayOfMonth: 0,
  // timezone correction in minutes
  z: NaN,
  // counters
  dates: 0,
  times: 0,
  zones: 0,
  // helper functions
  ymd: function ymd(y, m, d) {
    if (this.dates > 0) {
      return false;
    }
    this.dates++;
    this.y = y;
    this.m = m;
    this.d = d;
    return true;
  },
  time: function time(h2, i, s, f) {
    if (this.times > 0) {
      return false;
    }
    this.times++;
    this.h = h2;
    this.i = i;
    this.s = s;
    this.f = f;
    return true;
  },
  resetTime: function resetTime() {
    this.h = 0;
    this.i = 0;
    this.s = 0;
    this.f = 0;
    this.times = 0;
    return true;
  },
  zone: function zone(minutes2) {
    if (this.zones <= 1) {
      this.zones++;
      this.z = minutes2;
      return true;
    }
    return false;
  },
  toDate: function toDate2(relativeTo) {
    if (this.dates && !this.times) {
      this.h = this.i = this.s = this.f = 0;
    }
    if (isNaN(this.y)) {
      this.y = relativeTo.getFullYear();
    }
    if (isNaN(this.m)) {
      this.m = relativeTo.getMonth();
    }
    if (isNaN(this.d)) {
      this.d = relativeTo.getDate();
    }
    if (isNaN(this.h)) {
      this.h = relativeTo.getHours();
    }
    if (isNaN(this.i)) {
      this.i = relativeTo.getMinutes();
    }
    if (isNaN(this.s)) {
      this.s = relativeTo.getSeconds();
    }
    if (isNaN(this.f)) {
      this.f = relativeTo.getMilliseconds();
    }
    switch (this.firstOrLastDayOfMonth) {
      case 1:
        this.d = 1;
        break;
      case -1:
        this.d = 0;
        this.m += 1;
        break;
    }
    if (!isNaN(this.weekday)) {
      var date6 = new Date(relativeTo.getTime());
      date6.setFullYear(this.y, this.m, this.d);
      date6.setHours(this.h, this.i, this.s, this.f);
      var dow = date6.getDay();
      if (this.weekdayBehavior === 2) {
        if (dow === 0 && this.weekday !== 0) {
          this.weekday = -6;
        }
        if (this.weekday === 0 && dow !== 0) {
          this.weekday = 7;
        }
        this.d -= dow;
        this.d += this.weekday;
      } else {
        var diff2 = this.weekday - dow;
        if (this.rd < 0 && diff2 < 0 || this.rd >= 0 && diff2 <= -this.weekdayBehavior) {
          diff2 += 7;
        }
        if (this.weekday >= 0) {
          this.d += diff2;
        } else {
          this.d -= 7 - (Math.abs(this.weekday) - dow);
        }
        this.weekday = NaN;
      }
    }
    this.y += this.ry;
    this.m += this.rm;
    this.d += this.rd;
    this.h += this.rh;
    this.i += this.ri;
    this.s += this.rs;
    this.f += this.rf;
    this.ry = this.rm = this.rd = 0;
    this.rh = this.ri = this.rs = this.rf = 0;
    var result = new Date(relativeTo.getTime());
    result.setFullYear(this.y, this.m, this.d);
    result.setHours(this.h, this.i, this.s, this.f);
    switch (this.firstOrLastDayOfMonth) {
      case 1:
        result.setDate(1);
        break;
      case -1:
        result.setMonth(result.getMonth() + 1, 0);
        break;
    }
    if (!isNaN(this.z) && result.getTimezoneOffset() !== this.z) {
      result.setUTCFullYear(result.getFullYear(), result.getMonth(), result.getDate());
      result.setUTCHours(result.getHours(), result.getMinutes(), result.getSeconds() - this.z, result.getMilliseconds());
    }
    return result;
  }
};
var strtotime = function strtotime2(str, now2) {
  if (now2 == null) {
    now2 = Math.floor(Date.now() / 1e3);
  }
  var rules2 = [
    formats$1.yesterday,
    formats$1.now,
    formats$1.noon,
    formats$1.midnightOrToday,
    formats$1.tomorrow,
    formats$1.timestamp,
    formats$1.firstOrLastDay,
    formats$1.backOrFrontOf,
    // formats.weekdayOf, // not yet implemented
    formats$1.timeTiny12,
    formats$1.timeShort12,
    formats$1.timeLong12,
    formats$1.mssqltime,
    formats$1.oracledate,
    formats$1.timeShort24,
    formats$1.timeLong24,
    formats$1.iso8601long,
    formats$1.gnuNoColon,
    formats$1.iso8601noColon,
    formats$1.americanShort,
    formats$1.american,
    formats$1.iso8601date4,
    formats$1.iso8601dateSlash,
    formats$1.dateSlash,
    formats$1.gnuDateShortOrIso8601date2,
    formats$1.gnuDateShorter,
    formats$1.dateFull,
    formats$1.pointedDate4,
    formats$1.pointedDate2,
    formats$1.dateNoDay,
    formats$1.dateNoDayRev,
    formats$1.dateTextual,
    formats$1.dateNoYear,
    formats$1.dateNoYearRev,
    formats$1.dateNoColon,
    formats$1.xmlRpc,
    formats$1.xmlRpcNoColon,
    formats$1.soap,
    formats$1.wddx,
    formats$1.exif,
    formats$1.pgydotd,
    formats$1.isoWeekDay,
    formats$1.pgTextShort,
    formats$1.pgTextReverse,
    formats$1.clf,
    formats$1.year4,
    formats$1.ago,
    formats$1.dayText,
    formats$1.relativeTextWeek,
    formats$1.relativeText,
    formats$1.monthFullOrMonthAbbr,
    formats$1.tzCorrection,
    formats$1.tzAbbr,
    formats$1.dateShortWithTimeShort12,
    formats$1.dateShortWithTimeLong12,
    formats$1.dateShortWithTimeShort,
    formats$1.dateShortWithTimeLong,
    formats$1.relative,
    formats$1.whitespace
  ];
  var result = Object.create(resultProto);
  while (str.length) {
    var longestMatch = null;
    var finalRule = null;
    for (var i = 0, l = rules2.length; i < l; i++) {
      var format2 = rules2[i];
      var match = str.match(format2.regex);
      if (match) {
        if (!longestMatch || match[0].length > longestMatch[0].length) {
          longestMatch = match;
          finalRule = format2;
        }
      }
    }
    if (!finalRule || finalRule.callback && finalRule.callback.apply(result, longestMatch) === false) {
      return false;
    }
    str = str.substr(longestMatch[0].length);
    finalRule = null;
    longestMatch = null;
  }
  return Math.floor(result.toDate(new Date(now2 * 1e3)) / 1e3);
};
var date$4 = class extends Validator {
  check(value) {
    return !!strtotime(value);
  }
};
var date_equals = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      date: this.date
    };
  }
  get date() {
    return this.attributes[0];
  }
  check(value) {
    return value === this.date;
  }
};
var date_format = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      format: this.format
    };
  }
  get format() {
    return this.attributes[0];
  }
  check(value) {
    return value && moment_default(value, this.format).format(this.format) === value;
  }
};
var different = class extends Validator {
  get otherPath() {
    return this.attributes[0];
  }
  get other$() {
    return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
  }
  get messageParams() {
    return {
      attribute: this.attributeName,
      other: this.other$.genericName
    };
  }
  init() {
    this.watchOther();
  }
  check(value) {
    if (!this.filled(value) && !this.filled(this.other$.value)) {
      return true;
    }
    return value != this.other$.value;
  }
};
var digits = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      digits: this.digits
    };
  }
  get digits() {
    return this.attributes[0];
  }
  check(value) {
    return /^\d+$/.test(value) && value.toString().length == this.digits;
  }
};
var digits_between = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      min: this.min,
      max: this.max
    };
  }
  get min() {
    return this.attributes[0];
  }
  get max() {
    return this.attributes[1];
  }
  check(value) {
    var length = value.toString().length;
    return /^\d+$/.test(value) && length >= this.min && length <= this.max;
  }
};
var dimensions = class extends Validator {
  get isAsync() {
    return true;
  }
  readImage(inputFile) {
    return _asyncToGenerator(function* () {
      var reader = new FileReader();
      return new Promise((resolve, reject) => {
        reader.onerror = () => {
          temporaryFileReader.abort();
          reject(new DOMException("File cannot be parsed."));
        };
        reader.onloadend = (event) => {
          resolve(event.target.result);
        };
        reader.readAsDataURL(inputFile);
      });
    })();
  }
  loadImage(value) {
    var _this = this;
    return _asyncToGenerator(function* () {
      var source = yield _this.readImage(value);
      var image2 = new Image();
      return new Promise((resolve, reject) => {
        image2.onerror = () => {
          reject(new DOMException("Image could not be loaded."));
        };
        image2.onload = (event) => {
          resolve(event.target);
        };
        image2.src = source;
      });
    })();
  }
  hasAttribute(attribute) {
    return Object.keys(this.attributes).map((a) => a.toLowerCase()).indexOf(attribute) !== -1;
  }
  check(value) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      if (_this2.isFile && !value) {
        return true;
      }
      if (!_this2.isFile || !(value instanceof File)) {
        return false;
      }
      var image2 = yield _this2.loadImage(value);
      if (_this2.hasAttribute("min_width")) {
        if (image2.width < _this2.attributes["min_width"]) {
          return false;
        }
      }
      if (_this2.hasAttribute("max_width")) {
        if (image2.width > _this2.attributes["max_width"]) {
          return false;
        }
      }
      if (_this2.hasAttribute("min_height")) {
        if (image2.height < _this2.attributes["min_height"]) {
          return false;
        }
      }
      if (_this2.hasAttribute("max_height")) {
        if (image2.height > _this2.attributes["max_height"]) {
          return false;
        }
      }
      if (_this2.hasAttribute("width")) {
        if (image2.width != _this2.attributes["width"]) {
          return false;
        }
      }
      if (_this2.hasAttribute("height")) {
        if (image2.height != _this2.attributes["height"]) {
          return false;
        }
      }
      if (_this2.hasAttribute("ratio")) {
        var ratio = _this2.attributes["ratio"];
        var precision = 1 / (Math.min(image2.width, image2.height) + 1);
        var numerator = /\//.test(ratio) ? ratio.split("/")[0] : ratio;
        var denominator = /\//.test(ratio) ? ratio.split("/")[1] : 1;
        if (Math.abs(numerator / denominator - image2.width / image2.height) > precision) {
          return false;
        }
      }
      return true;
    })();
  }
};
function pregQuote(str, delimiter) {
  return (str + "").replace(new RegExp("[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\" + (delimiter || "") + "-]", "g"), "\\$&");
}
function baseReduce$1(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index2, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
  });
  return accumulator;
}
var _baseReduce = baseReduce$1;
var arrayReduce = _arrayReduce;
var baseEach = _baseEach;
var baseIteratee$4 = _baseIteratee;
var baseReduce = _baseReduce;
var isArray$2 = isArray_1;
function reduce(collection, iteratee, accumulator) {
  var func = isArray$2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
  return func(collection, baseIteratee$4(iteratee), accumulator, initAccum, baseEach);
}
var reduce_1 = reduce;
var flattenKeys = function flattenKeys2(obj) {
  var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return !isObject_1(obj) ? {
    [path.join(".")]: obj
  } : reduce_1(obj, (cum, next, key) => merge_1(cum, flattenKeys2(next, [...path, key])), {});
};
var distinct = class extends Validator {
  check(value) {
    var attribute = this.element$.path;
    var attributeName = attribute.replace(/\d+(?!\d+)/, "*");
    var rootVariable = attribute.match(/^[\w-]+/)[0];
    var attributeData = {
      [rootVariable]: this.form$.data[rootVariable]
    };
    var pattern = pregQuote(attributeName, "#").replace("\\*", "[^.]+");
    var data = {};
    each(flattenKeys(attributeData), (v, k) => {
      if (k != attribute && k.match("^" + pattern + "$") !== null) {
        data[k] = v;
      }
    });
    return !(values_1(data).indexOf(value) !== -1);
  }
};
var email = class extends Validator {
  check(value) {
    var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(String(value).toLowerCase());
  }
};
var exists = class extends Validator {
  get isAsync() {
    return true;
  }
  get requestParams() {
    var params = {};
    each(this.attributes, (param, key) => {
      var requestParam = key;
      if (!isNaN(key)) {
        requestParam = param;
      }
      if (requestParam == "debounce") {
        return;
      }
      var el = this.form$.el$(requestParam);
      params[keys_1(params).length] = el && key != 0 ? el.value : requestParam;
    });
    return params;
  }
  check(value) {
    var _this = this;
    return _asyncToGenerator(function* () {
      var name2 = _this.element$.name;
      var endpoint = _this.form$.$vueform.config.endpoints.exists;
      var method = typeof endpoint !== "function" ? endpoint.method : null;
      var res;
      if (typeof endpoint === "function") {
        res = yield endpoint(value, name2, _this.requestParams, _this.element$, _this.form$);
      } else {
        res = yield _this.form$.$vueform.services.axios.request({
          url: endpoint.url,
          method,
          [method.toLowerCase() === "get" ? "params" : "data"]: {
            params: _this.requestParams,
            [name2]: value,
            vueformFieldName: name2,
            value,
            name: name2
          }
        });
        res = res.data;
      }
      return res;
    })();
  }
};
var file$5 = class extends Validator {
  check(value) {
    return (!value || value instanceof File) && this.isFile;
  }
};
var filled = class extends Validator {
  check(value) {
    return this.filled(value);
  }
};
var gt = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      value: this.other$.value != null ? this.size(this.other$.value) : 0
    };
  }
  get otherPath() {
    return this.attributes[0];
  }
  get other$() {
    return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
  }
  init() {
    this.watchOther();
  }
  check(value) {
    var otherValue = this.other$.value;
    return this.compare(value, otherValue);
  }
  compare(value, otherValue) {
    var otherSize = this.size(otherValue);
    return otherSize == 0 || this.size(value) > otherSize;
  }
};
var gte = class extends gt {
  compare(value, otherValue) {
    var otherSize = this.size(otherValue);
    return otherSize == 0 || this.size(value) >= otherSize;
  }
};
var image = class extends Validator {
  check(value) {
    if (this.isFile && !value) {
      return true;
    }
    if (!this.isFile || !(value instanceof File) || !value.name) {
      return false;
    }
    var extension = value.name.split(".").pop();
    return ["jpg", "jpeg", "png", "gif", "bmp", "svg", "webp"].indexOf(extension) !== -1;
  }
};
var in_ = class extends Validator {
  check(value) {
    return values_1(this.attributes).indexOf(normalize(String(value).trim())) !== -1;
  }
};
var in_array = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      other: this.other$.genericName
    };
  }
  get other$() {
    return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
  }
  get otherPath() {
    var matches2 = this.attributes[0].match(/.*(?=\.\*)/);
    if (matches2 === null) {
      throw new Error("in_array rule's other attribute should end with .*");
    }
    return matches2[0];
  }
  init() {
    this.watchOther();
  }
  check(value) {
    var data = this.other$.value;
    if (!data) {
      return false;
    }
    return data.indexOf(value) !== -1;
  }
};
var integer = class extends Validator {
  check(value) {
    var normalized = normalize(String(value).trim());
    return normalized === parseInt(normalized, 10);
  }
};
var checker$1 = function checker(value) {
  var re = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\/([0-9]|[1-2][0-9]|3[0-2]))?$/;
  return re.test(value);
};
var ipv4 = class extends Validator {
  check(value) {
    return checker$1(value);
  }
};
var checker2 = function checker3(value) {
  var re = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*(\/(\d|\d\d|1[0-1]\d|12[0-8]))?$/;
  return re.test(value);
};
var ipv6 = class extends Validator {
  check(value) {
    return checker2(value);
  }
};
var ip = class extends Validator {
  check(value) {
    return checker$1(value) || checker2(value);
  }
};
function isJson(str) {
  try {
    JSON.parse(str);
  } catch (e2) {
    return false;
  }
  return true;
}
var json = class extends Validator {
  check(value) {
    return isJson(value);
  }
};
var lt = class extends gt {
  compare(value, otherValue) {
    var size2 = this.size(value);
    var otherSize = this.size(otherValue);
    return otherSize == 0 && size2 == 0 || this.size(value) < otherSize;
  }
};
var lte = class extends gt {
  compare(value, otherValue) {
    var size2 = this.size(value);
    var otherSize = this.size(otherValue);
    return otherSize == 0 && size2 == 0 || this.size(value) <= otherSize;
  }
};
var max2 = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      max: this.max
    };
  }
  get max() {
    return this.attributes[0];
  }
  check(value) {
    if (!value) {
      return true;
    }
    return this.size(value) <= this.max;
  }
};
var mimes = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      values: this.accepted.join(", ")
    };
  }
  get accepted() {
    return Object.values(this.attributes).map((a) => a.toLowerCase());
  }
  check(value) {
    if (this.isFile && !value) {
      return true;
    }
    if (!this.isFile || !(value instanceof File) || !value.name) {
      return false;
    }
    var extension = value.name.split(".").pop();
    return this.accepted.indexOf(extension.toLowerCase()) !== -1;
  }
};
var mimetypes = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      values: this.accepted.join(", ")
    };
  }
  get accepted() {
    return Object.values(this.attributes).map((a) => a.toLowerCase());
  }
  check(value) {
    if (this.isFile && !value) {
      return true;
    }
    if (!this.isFile || !(value instanceof File) || !value.type) {
      return false;
    }
    return this.accepted.indexOf(value.type.toLowerCase()) !== -1;
  }
};
var min$1 = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      min: this.min
    };
  }
  get min() {
    return this.attributes[0];
  }
  check(value) {
    if (!value) {
      return true;
    }
    return this.size(value) >= this.min;
  }
};
var not_in = class extends Validator {
  check(value) {
    return values_1(this.attributes).indexOf(value) === -1;
  }
};
var not_regex = class extends Validator {
  check(value) {
    var regex2 = new RegExp(this.attributes[0].replace(/^\/|\/[^\/]*$/g, ""));
    return !regex2.test(value);
  }
};
var nullable = class extends Validator {
  check(value) {
    return true;
  }
};
var numeric = class extends Validator {
  check(value) {
    return !isNaN(parseFloat(value)) && isFinite(value) && !/\s/.test(String(value)) && !Boolean(String(value).match(/^0x[0-9a-f]+$/i));
  }
};
var regex = class extends Validator {
  check(value) {
    var regex2 = new RegExp(this.attributes[0].replace(/^\/|\/[^\/]*$/g, ""));
    return regex2.test(value);
  }
};
var required = class extends Validator {
  check(value) {
    return this.filled(value);
  }
};
var same = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      other: this.other$.genericName
    };
  }
  get otherPath() {
    return this.attributes[0];
  }
  get other$() {
    return this.form$.el$(replaceWildcards(this.otherPath, this.element$.path));
  }
  init() {
    this.watchOther();
  }
  check(value) {
    if (!this.filled(value) && !this.filled(this.other$.value)) {
      return true;
    }
    return value == this.other$.value;
  }
};
var size = class extends Validator {
  get messageParams() {
    return {
      attribute: this.attributeName,
      size: this.size_
    };
  }
  get size_() {
    return this.attributes[0];
  }
  check(value) {
    if (!value) {
      return true;
    }
    return this.size(value) == this.size_;
  }
};
var string = class extends Validator {
  check(value) {
    return isString_1(value);
  }
};
var timezone = class extends Validator {
  check(value) {
    try {
      Intl.DateTimeFormat(void 0, {
        timeZone: value
      });
      return true;
    } catch (ex) {
      return false;
    }
  }
};
var unique = class extends Validator {
  get isAsync() {
    return true;
  }
  get requestParams() {
    var params = {};
    each(this.attributes, (param, key) => {
      var requestParam = key;
      if (!isNaN(key)) {
        requestParam = param;
      }
      if (requestParam == "debounce") {
        return;
      }
      var el = this.form$.el$(requestParam);
      params[keys_1(params).length] = el && key != 0 ? el.value : requestParam;
    });
    return params;
  }
  check(value) {
    var _this = this;
    return _asyncToGenerator(function* () {
      var name2 = _this.element$.name;
      var endpoint = _this.form$.$vueform.config.endpoints.unique;
      var method = typeof endpoint !== "function" ? endpoint.method : null;
      var res;
      if (typeof endpoint === "function") {
        res = yield endpoint(value, name2, _this.requestParams, _this.element$, _this.form$);
      } else {
        res = yield _this.form$.$vueform.services.axios.request({
          url: endpoint.url,
          method,
          [method.toLowerCase() === "get" ? "params" : "data"]: {
            params: _this.requestParams,
            name: name2,
            value
          }
        });
        res = res.data;
      }
      return res;
    })();
  }
};
var url = class extends Validator {
  check(value) {
    var regex2 = new RegExp("^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$", "i");
    return regex2.test(value);
  }
};
var uuid = class extends Validator {
  check(value) {
    var regex2 = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/i;
    return regex2.test(value);
  }
};
var index$2 = {
  accepted,
  active_url,
  after,
  after_or_equal,
  alpha,
  alpha_dash,
  alpha_num,
  array: array$2,
  before,
  before_or_equal,
  between,
  boolean: boolean$1,
  confirmed,
  date: date$4,
  date_equals,
  date_format,
  different,
  digits,
  digits_between,
  dimensions,
  distinct,
  email,
  exists,
  file: file$5,
  filled,
  gt,
  gte,
  image,
  in: in_,
  in_array,
  integer,
  ip,
  ipv4,
  ipv6,
  json,
  lt,
  lte,
  max: max2,
  mimes,
  mimetypes,
  min: min$1,
  not_in,
  not_regex,
  nullable,
  numeric,
  regex,
  required,
  same,
  size,
  string,
  timezone,
  unique,
  url,
  uuid
};
var rules = Object.freeze({
  __proto__: null,
  accepted,
  active_url,
  after,
  after_or_equal,
  alpha,
  alpha_dash,
  alpha_num,
  array: array$2,
  before,
  before_or_equal,
  between,
  boolean: boolean$1,
  captcha: captcha$2,
  completed,
  confirmed,
  date: date$4,
  date_equals,
  date_format,
  different,
  digits,
  digits_between,
  dimensions,
  distinct,
  email,
  exists,
  file: file$5,
  filled,
  gt,
  gte,
  image,
  in_,
  in_array,
  integer,
  ip,
  ipv4,
  ipv6,
  json,
  lt,
  lte,
  max: max2,
  mimes,
  mimetypes,
  min: min$1,
  not_in,
  not_regex,
  nullable,
  numeric,
  regex,
  required,
  same,
  size,
  string,
  timezone,
  unique,
  url,
  uuid,
  "default": index$2
});
var validation = {
  factory: Factory,
  rules: {}
};
var arrayPush = _arrayPush;
var baseFlatten$1 = _baseFlatten;
var copyArray = _copyArray;
var isArray$1 = isArray_1;
function concat() {
  var length = arguments.length;
  if (!length) {
    return [];
  }
  var args = Array(length - 1), array4 = arguments[0], index2 = length;
  while (index2--) {
    args[index2 - 1] = arguments[index2];
  }
  return arrayPush(isArray$1(array4) ? copyArray(array4) : [array4], baseFlatten$1(args, 1));
}
var concat_1 = concat;
function head(array4) {
  return array4 && array4.length ? array4[0] : void 0;
}
var head_1 = head;
var messageBag = class {
  constructor(baseErrors) {
    this.baseErrors = baseErrors;
    this.prepends = {
      errors: [],
      messages: []
    };
    this.appends = {
      errors: [],
      messages: []
    };
  }
  get errors() {
    return concat_1(this.prepends.errors, this.baseErrors, this.appends.errors);
  }
  get messages() {
    return concat_1(this.prepends.messages, this.appends.messages);
  }
  /**
   * The first error
   * 
   * @type {string}
   */
  get error() {
    return head_1(this.errors);
  }
  /**
   * The first message
   * 
   * @type {string}
   */
  get message() {
    return head_1(this.messages);
  }
  prepend(msg, type) {
    if (type === void 0) {
      type = "error";
    }
    this.prepends[type == "error" ? "errors" : "messages"].unshift(msg);
  }
  append(msg, type) {
    if (type === void 0) {
      type = "error";
    }
    this.appends[type == "error" ? "errors" : "messages"].push(msg);
  }
  remove(msg, type) {
    if (type === void 0) {
      type = "any";
    }
    if (["any", "error"].indexOf(type) !== -1) {
      each(this.prepends.errors, (error, index2) => {
        if (error == msg) {
          this.rm("prepends", "errors", index2);
        }
      });
      each(this.appends.errors, (error, index2) => {
        if (error == msg) {
          this.rm("appends", "errors", index2);
        }
      });
    }
    if (["any", "message"].indexOf(type) !== -1) {
      each(this.prepends.messages, (error, index2) => {
        if (error == msg) {
          this.rm("prepends", "messages", index2);
        }
      });
      each(this.appends.messages, (error, index2) => {
        if (error == msg) {
          this.rm("appends", "messages", index2);
        }
      });
    }
  }
  rm(group7, type, index2) {
    this[group7][type].splice(index2, 1);
  }
  clear(type) {
    if (type === void 0) {
      type = "all";
    }
    if (type == "all") {
      this.prepends = {
        errors: [],
        messages: []
      };
      this.appends = {
        errors: [],
        messages: []
      };
    } else {
      this.prepends[type] = [];
      this.appends[type] = [];
    }
  }
  clearPrepended(type) {
    if (type === void 0) {
      type = "all";
    }
    if (type == "all") {
      this.prepends = {
        errors: [],
        messages: []
      };
    } else {
      this.prepends[type] = [];
    }
  }
  clearAppended(type) {
    if (type === void 0) {
      type = "all";
    }
    if (type == "all") {
      this.appends = {
        errors: [],
        messages: []
      };
    } else {
      this.appends[type] = [];
    }
  }
};
var e = /* @__PURE__ */ new Map();
function t(t2) {
  var o2 = e.get(t2);
  o2 && o2.destroy();
}
function o(t2) {
  var o2 = e.get(t2);
  o2 && o2.update();
}
var r = null;
"undefined" == typeof window ? ((r = function(e2) {
  return e2;
}).destroy = function(e2) {
  return e2;
}, r.update = function(e2) {
  return e2;
}) : ((r = function(t2, o2) {
  return t2 && Array.prototype.forEach.call(t2.length ? t2 : [t2], function(t3) {
    return function(t4) {
      if (t4 && t4.nodeName && "TEXTAREA" === t4.nodeName && !e.has(t4)) {
        var o3, r2 = null, n2 = window.getComputedStyle(t4), i = (o3 = t4.value, function() {
          a({ testForHeightReduction: "" === o3 || !t4.value.startsWith(o3), restoreTextAlign: null }), o3 = t4.value;
        }), l = (function(o4) {
          t4.removeEventListener("autosize:destroy", l), t4.removeEventListener("autosize:update", s), t4.removeEventListener("input", i), window.removeEventListener("resize", s), Object.keys(o4).forEach(function(e2) {
            return t4.style[e2] = o4[e2];
          }), e.delete(t4);
        }).bind(t4, { height: t4.style.height, resize: t4.style.resize, textAlign: t4.style.textAlign, overflowY: t4.style.overflowY, overflowX: t4.style.overflowX, wordWrap: t4.style.wordWrap });
        t4.addEventListener("autosize:destroy", l), t4.addEventListener("autosize:update", s), t4.addEventListener("input", i), window.addEventListener("resize", s), t4.style.overflowX = "hidden", t4.style.wordWrap = "break-word", e.set(t4, { destroy: l, update: s }), s();
      }
      function a(e2) {
        var o4, i2, l2 = e2.restoreTextAlign, s2 = void 0 === l2 ? null : l2, d = e2.testForHeightReduction, u = void 0 === d || d, c = n2.overflowY;
        if (0 !== t4.scrollHeight && ("vertical" === n2.resize ? t4.style.resize = "none" : "both" === n2.resize && (t4.style.resize = "horizontal"), u && (o4 = function(e3) {
          for (var t5 = []; e3 && e3.parentNode && e3.parentNode instanceof Element; )
            e3.parentNode.scrollTop && t5.push([e3.parentNode, e3.parentNode.scrollTop]), e3 = e3.parentNode;
          return function() {
            return t5.forEach(function(e4) {
              var t6 = e4[0], o5 = e4[1];
              t6.style.scrollBehavior = "auto", t6.scrollTop = o5, t6.style.scrollBehavior = null;
            });
          };
        }(t4), t4.style.height = ""), i2 = "content-box" === n2.boxSizing ? t4.scrollHeight - (parseFloat(n2.paddingTop) + parseFloat(n2.paddingBottom)) : t4.scrollHeight + parseFloat(n2.borderTopWidth) + parseFloat(n2.borderBottomWidth), "none" !== n2.maxHeight && i2 > parseFloat(n2.maxHeight) ? ("hidden" === n2.overflowY && (t4.style.overflow = "scroll"), i2 = parseFloat(n2.maxHeight)) : "hidden" !== n2.overflowY && (t4.style.overflow = "hidden"), t4.style.height = i2 + "px", s2 && (t4.style.textAlign = s2), o4 && o4(), r2 !== i2 && (t4.dispatchEvent(new Event("autosize:resized", { bubbles: true })), r2 = i2), c !== n2.overflow && !s2)) {
          var v = n2.textAlign;
          "hidden" === n2.overflow && (t4.style.textAlign = "start" === v ? "end" : "start"), a({ restoreTextAlign: v, testForHeightReduction: true });
        }
      }
      function s() {
        a({ testForHeightReduction: true, restoreTextAlign: null });
      }
    }(t3);
  }), t2;
}).destroy = function(e2) {
  return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], t), e2;
}, r.update = function(e2) {
  return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], o), e2;
});
var n = r;
var google = class {
  constructor() {
    this.autocomplete = null;
    this.autocompleteListener = null;
    this.options = {};
  }
  init(container, onChange, options) {
    if (window.google === void 0 || window.google.maps === void 0 || window.google.maps.places === void 0 || window.google.maps.places.Autocomplete === void 0)
      ;
    this.options = options;
    this.autocomplete = new window.google.maps.places.Autocomplete(container, options);
    this.autocompleteListener = this.autocomplete.addListener("place_changed", () => {
      var place = this.autocomplete.getPlace();
      onChange(this.formatValue(place), place);
    });
  }
  destroy() {
    window.google.maps.event.removeListener(this.autocompleteListener);
    window.google.maps.event.clearInstanceListeners(this.autocomplete);
    var pac = document.querySelector(".pac-container");
    if (pac) {
      pac.remove();
    }
  }
  formatValue(value) {
    if (!isPlainObject_1(value)) {
      return value;
    }
    var addressComponents = value.address_components;
    var street = this.addressComponent(addressComponents, "street");
    var streetNumber = this.addressComponent(addressComponents, "street_number");
    var address = null;
    if (street !== null) {
      address = street;
    }
    if (streetNumber !== null) {
      address += (street !== null ? " " : "") + streetNumber;
    }
    return {
      country: this.addressComponent(addressComponents, "country"),
      country_code: this.addressComponent(addressComponents, "country_code"),
      state: this.addressComponent(addressComponents, "state"),
      state_code: this.addressComponent(addressComponents, "state_code"),
      city: this.addressComponent(addressComponents, "city"),
      zip: this.addressComponent(addressComponents, "zip"),
      address,
      formatted_address: value.formatted_address || null,
      lat: value.geometry.location.lat() || null,
      lng: value.geometry.location.lng() || null
    };
  }
  addressComponent(addressComponents, type) {
    var typeMap = {
      country: {
        field: "country",
        type: "long_name"
      },
      country_code: {
        field: "country",
        type: "short_name"
      },
      state: {
        field: "administrative_area_level_1",
        type: "long_name"
      },
      state_code: {
        field: "administrative_area_level_1",
        type: "short_name"
      },
      city: {
        field: "locality",
        type: "long_name"
      },
      zip: {
        field: "postal_code",
        type: "long_name"
      },
      street: {
        field: "route",
        type: "long_name"
      },
      street_number: {
        field: "street_number",
        type: "long_name"
      }
    };
    var addressComponent = null;
    each(addressComponents, (component) => {
      if (component.types.indexOf(typeMap[type].field) !== -1) {
        if (["state", "state_code"].indexOf(type) !== -1 && this.addressComponent(addressComponents, "country_code") != "US") {
          return;
        }
        addressComponent = component[typeMap[type].type] || null;
      }
    });
    return addressComponent;
  }
};
var algolia = class {
  constructor() {
    this.places = null;
    this.options = {};
  }
  init(container, onChange, options) {
    if (window.places === void 0) {
      throw new Error("Algolia Places API missing. Please include script in your project from https://community.algolia.com/places/documentation.html#cdn-script or install via npm and set to `window.places`.");
    }
    this.options = options;
    this.places = window.places(Object.assign({}, {
      container
    }, options));
    this.places.on("change", (e2) => {
      onChange(this.formatValue(e2.suggestion), e2.suggestion);
    });
  }
  destroy() {
    this.places.destroy();
  }
  formatValue(value) {
    if (!isPlainObject_1(value)) {
      return value;
    }
    return {
      country: value.country,
      country_code: value.countryCode ? value.countryCode.toUpperCase() : null,
      state: value.countryCode == "us" ? value.administrative : null,
      state_code: value.countryCode == "us" ? this.stateCode(value.administrative.toLowerCase()) : null,
      city: value.city,
      zip: value.postcode,
      address: value.name,
      formatted_address: value.value,
      lat: value.latlng.lat,
      lng: value.latlng.lng
    };
  }
  stateCode(name2) {
    var states = {
      AL: "alabama",
      AK: "alaska",
      AZ: "arizona",
      AR: "arkansas",
      CA: "california",
      CO: "colorado",
      CT: "connecticut",
      DE: "delaware",
      DC: "district of columbia",
      FL: "florida",
      GA: "georgia",
      HI: "hawaii",
      ID: "idaho",
      IL: "illinois",
      IN: "indiana",
      IA: "iowa",
      KS: "kansas",
      KY: "kentucky",
      LA: "louisiana",
      ME: "maine",
      MD: "maryland",
      MA: "massachusetts",
      MI: "michigan",
      MN: "minnesota",
      MS: "mississippi",
      MO: "missouri",
      MT: "montana",
      NE: "nebraska",
      NV: "nevada",
      NH: "new hampshire",
      NJ: "new Jersey",
      NM: "new Mexico",
      NY: "new york",
      NC: "north carolina",
      ND: "north dakota",
      OH: "ohio",
      OK: "oklahoma",
      OR: "oregon",
      PA: "pennsylvania",
      RI: "rhode Island",
      SC: "south carolina",
      SD: "south dakota",
      TN: "tennessee",
      TX: "texas",
      UT: "utah",
      VT: "vermont",
      VA: "virginia",
      WA: "washington",
      WV: "west virginia",
      WI: "wisconsin",
      WY: "wyoming"
    };
    if (values_1(states).indexOf(name2) === -1) {
      return null;
    }
    return keys_1(states)[values_1(states).indexOf(name2)];
  }
};
var location$4 = {
  google,
  algolia
};
var check = (condition2, elementPath, form$, el$) => {
  var checkFunction = () => {
    return condition2(form$, el$);
  };
  var checkArray = (condition3) => {
    var {
      conditionPath,
      operator,
      expected
    } = details(condition3);
    var element$ = form$.el$(conditionPath);
    var hasCircularCondition = false;
    if (element$ && elementPath) {
      each(element$.conditions, (condition4) => {
        if (!Array.isArray(condition4)) {
          return;
        }
        if (condition4[0] == elementPath) {
          hasCircularCondition = true;
        }
      });
    }
    if (!element$ || !hasCircularCondition && !element$.available) {
      return false;
    }
    return compareValues(element$.value, expected, operator);
  };
  var details = (condition3) => {
    return {
      conditionPath: elementPath ? replaceWildcards(condition3[0], elementPath) : condition3[0],
      operator: condition3.length == 3 || ["empty", "not_empty", "today"].indexOf(condition3[1]) !== -1 ? condition3[1] : "==",
      expected: condition3.length == 3 ? condition3[2] : ["empty", "not_empty", "today"].indexOf(condition3[1]) === -1 ? condition3[1] : true
    };
  };
  var compareValues = (actual, expected, operator) => {
    return compare(actual, operator, expected, el$);
  };
  if (typeof condition2 == "function") {
    return checkFunction();
  } else if (isArray_1(condition2) && isArray_1(condition2[0])) {
    return condition2.reduce((prev, curr) => {
      if (prev) {
        return prev;
      }
      if (isArray_1(curr[0])) {
        return curr.reduce((p, c) => !p ? p : checkArray(c), true);
      }
      return checkArray(curr);
    }, false);
  } else if (isArray_1(condition2)) {
    return checkArray(condition2);
  }
  throw new Error("Condition must be a function or an array");
};
var condition = {
  check
};
var i18n = class {
  constructor(options) {
    this.locales = options.locales;
    this.locale = options.locale;
    this.fallbackLocale = options.fallbackLocale;
  }
  $t(expr) {
    var data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var tag = get_1(this.locales[this.locale], expr) || expr;
    if (tag === expr) {
      tag = get_1(this.locales[this.fallbackLocale], expr) || expr;
    }
    each(data, (value, key) => {
      tag = tag.replace(":" + key, value);
    });
    each(data, (value, key) => {
      tag = tag.replace("{" + key + "}", value);
    });
    return tag;
  }
};
var Columns = class {
  constructor(options, hasLabel, getClass, presets) {
    _defineProperty$2(this, "defaultBreakpoint", "default");
    this.presets = presets;
    this.configPresetColumns = this.serialize(this.columnsFromPresets(options.configPresetColumns) || {});
    this.configColumns = this.serialize(options.configColumns || {});
    this.formPresetColumns = this.serialize(this.columnsFromPresets(options.formPresetColumns) || {});
    this.formColumns = this.serialize(options.formColumns || {});
    this.presetColumns = this.serialize(this.columnsFromPresets(options.elementPresetColumns) || {});
    this.columns = this.serialize(options.elementColumns || {});
    this.hasLabel = hasLabel;
    this.getClass = getClass;
    this.cols = this.getCols();
  }
  get classes() {
    return {
      container: this.getClasses("container"),
      label: this.getClasses("label"),
      innerContainer: this.getClasses("innerContainer"),
      wrapper: this.getClasses("wrapper")
    };
  }
  serialize(columns) {
    if (["number", "string"].indexOf(typeof columns) !== -1) {
      return {
        [this.defaultBreakpoint]: {
          container: columns
        }
      };
    }
    if (typeof columns === "object" && ["container", "label", "wrapper"].indexOf(Object.keys(columns)[0]) !== -1) {
      var serialized = {};
      each(columns, (size2, type) => {
        if (["number", "string"].indexOf(typeof size2) !== -1) {
          if (serialized[this.defaultBreakpoint] === void 0) {
            serialized[this.defaultBreakpoint] = {};
          }
          serialized[this.defaultBreakpoint][type] = size2;
        } else {
          each(size2, (s, breakpoint) => {
            if (serialized[breakpoint] === void 0) {
              serialized[breakpoint] = {};
            }
            serialized[breakpoint][type] = s;
          });
        }
      });
      return serialized;
    } else {
      var _serialized = {};
      each(columns, (size2, breakpoint) => {
        if (["number", "string"].indexOf(typeof size2) !== -1) {
          if (_serialized[breakpoint] === void 0) {
            _serialized[breakpoint] = {};
          }
          _serialized[breakpoint].container = size2;
        } else {
          _serialized[breakpoint] = size2;
        }
      });
      return _serialized;
    }
  }
  columnsFromPresets(presets) {
    var columns;
    each(presets, (presetName) => {
      var preset = this.presets[presetName];
      if (!preset || !preset.columns) {
        return;
      }
      columns = preset.columns;
    });
    return columns;
  }
  getNullClass() {
    return [this.getClass(this.defaultBreakpoint, 0)];
  }
  getClasses(type) {
    var classes = [];
    Object.keys(this.cols).forEach((breakpoint) => {
      var size2;
      if (type === "innerContainer") {
        size2 = this.cols[breakpoint].label;
        size2 = size2 >= 12 || !this.hasLabel ? 12 : 12 - size2;
      } else {
        size2 = this.cols[breakpoint][type];
        if (type === "label" && !this.hasLabel) {
          size2 = 0;
        }
      }
      if (size2 !== void 0 && !isNaN(size2)) {
        classes.push(this.getClass(breakpoint, size2));
      }
    });
    return classes;
  }
  getCols() {
    return merge_1({}, {
      [this.defaultBreakpoint]: {
        container: 12,
        label: 12,
        wrapper: 12
      }
    }, this.configPresetColumns || {}, this.configColumns || {}, this.formPresetColumns || {}, this.formColumns || {}, this.presetColumns || {}, this.columns || {});
  }
};
var CaptchaProviderInterface = class {
  constructor(element2, options, el$) {
  }
  init() {
  }
  render() {
  }
  reset() {
  }
  getResponse() {
  }
  validate(response) {
    return _asyncToGenerator(function* () {
    })();
  }
};
var Recaptcha2Provider = class extends CaptchaProviderInterface {
  constructor(element2, options, el$) {
    super(element2, options, el$);
    _defineProperty$2(this, "src", "https://www.google.com/recaptcha/api.js?onload=recaptcha2LoadCallback&render=explicit");
    _defineProperty$2(this, "element", void 0);
    _defineProperty$2(this, "options", {});
    _defineProperty$2(this, "el$", {});
    _defineProperty$2(this, "id", void 0);
    _defineProperty$2(this, "rendered", false);
    _defineProperty$2(this, "interval", void 0);
    this.element = element2;
    this.options = options;
    this.el$ = el$;
    this.init();
  }
  init() {
    this.loadScript();
  }
  render() {
    this.id = window.grecaptcha.render(this.element, _objectSpread2$1({
      callback: (token2) => {
        this.el$.update(token2);
      },
      "expired-callback": () => {
        this.el$.clear();
      },
      "error-callback": () => {
        this.el$.clear();
      }
    }, this.options));
    this.rendered = true;
  }
  reset() {
    if (!this.rendered) {
      return;
    }
    return window.grecaptcha.reset(this.id);
  }
  getResponse() {
    return window.grecaptcha.getResponse(this.id);
  }
  validate(response) {
    return _asyncToGenerator(function* () {
      return !!response;
    })();
  }
  loadScript() {
    if (this.isCaptchaLoaded()) {
      this.render();
      return;
    }
    if (this.isScriptAdded()) {
      this.interval = setInterval(() => {
        if (this.isCaptchaLoaded()) {
          this.render();
          clearInterval(this.interval);
        }
      }, 500);
      return;
    }
    window.recaptcha2LoadCallback = () => {
      this.render();
    };
    var script = document.createElement("script");
    script.src = this.src;
    script.async = true;
    script.defer = true;
    document.head.appendChild(script);
    script.onload = () => {
    };
    script.onerror = () => {
      console.error("Error loading reCAPTCHA!");
    };
  }
  isCaptchaLoaded() {
    return typeof window !== "undefined" && window.grecaptcha;
  }
  isScriptAdded() {
    var scripts2 = document.getElementsByTagName("script");
    for (var i = 0; i < scripts2.length; i++) {
      if (scripts2[i].src.includes("https://www.google.com/recaptcha/api.js")) {
        return true;
      }
    }
    return false;
  }
};
var config = {
  /**
   * General
   */
  env: "development",
  plugins: [],
  elements: [],
  /**
   * Theme & layout
   */
  theme: {},
  templates: {},
  views: {},
  size: "md",
  addClasses: {},
  removeClasses: {},
  replaceClasses: {},
  overrideClasses: {},
  presets: {},
  usePresets: [],
  classHelpers: false,
  columns: {},
  forceLabels: false,
  floatPlaceholders: true,
  displayErrors: true,
  displayMessages: true,
  breakpoints: ["sm", "md", "lg", "xl", "2xl"],
  /**
   * Localization
   */
  languages: {
    en: "English"
  },
  language: "en",
  locales: {},
  locale: null,
  fallbackLocale: "en",
  /**
   * Sorting
   */
  orderFrom: 1,
  /**
   * Validation
   */
  rules: {},
  validateOn: "change|step",
  /**
   * Data
   */
  forceNumbers: false,
  /**
   * Submitting
   */
  endpoints: {
    submit: {
      url: "/vueform/process",
      method: "post"
    },
    uploadTempFile: {
      url: "/vueform/file/upload-temp",
      method: "post"
    },
    removeTempFile: {
      url: "/vueform/file/remove-temp",
      method: "post"
    },
    removeFile: {
      url: "/vueform/file/remove",
      method: "post"
    },
    attachment: {
      url: "/vueform/editor/attachment",
      method: "post"
    },
    activeUrl: {
      url: "/vueform/validators/active_url",
      method: "post"
    },
    unique: {
      url: "/vueform/validators/unique",
      method: "post"
    },
    exists: {
      url: "/vueform/validators/exists",
      method: "post"
    }
  },
  formData(form$) {
    return form$.convertFormData(_objectSpread2$1(_objectSpread2$1({}, form$.requestData), form$.formKey ? {
      formKey: form$.formKey
    } : {}));
  },
  beforeSend: null,
  axios: {},
  /**
   * Services
   */
  locationProvider: "google",
  providers: {
    captcha: {
      recaptcha2: Recaptcha2Provider
    }
  },
  useProviders: {
    captcha: "recaptcha2"
  },
  providerOptions: {
    recaptcha2: {
      sitekey: "6LeIxAcTAAAAAJcZVRqyHh71UMIEGNQ_MXjiZKhI"
    }
  },
  services: {
    algolia: {
      app_id: "",
      api_key: ""
    }
  }
};
function installer() {
  var config$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : config;
  var components2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var rules2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var Vueform = class {
    constructor() {
      this.options = {
        config: omit_1(config$1, ["theme", "templates", "locales", "rules", "plugins"]),
        templates: config$1.templates || {},
        components: config$1.components || {},
        theme: config$1.theme || {},
        rules: _objectSpread2$1(_objectSpread2$1({}, rules2), config$1.rules || {}),
        locales: config$1.locales || {},
        plugins: config$1.plugins || [],
        i18n: null,
        vueVersion: null,
        services: {
          validation,
          axios: axios_default,
          messageBag,
          autosize: n,
          location: location$4,
          condition,
          columns: Columns
        },
        version: packageJson.version
      };
    }
    config(config2) {
      each(["theme", "templates", "locales", "rules"], (attr) => {
        if (config2[attr] !== void 0) {
          this.options[attr] = Object.assign({}, this.options[attr], config2[attr]);
        }
      });
      each(["plugins", "components"], (attr) => {
        if (config2[attr] !== void 0) {
          this.options[attr] = config2[attr];
        }
      });
      each(["languages", "services", "presets", "views"], (attr) => {
        if (config2[attr] !== void 0) {
          this.options.config[attr] = Object.assign({}, this.options.config[attr], config2[attr]);
        }
      });
      each(["addClasses", "removeClasses", "replaceClasses", "overrideClasses"], (attr) => {
        if (config2[attr] !== void 0) {
          this.options.config[attr] = typeof config2[attr] === "function" ? config2[attr] : Object.assign({}, this.options.config[attr], config2[attr]);
        }
      });
      each(["endpoints", "providers", "useProviders", "providerOptions"], (attr) => {
        if (config2[attr] !== void 0) {
          this.options.config[attr] = merge_1({}, this.options.config[attr], config2[attr]);
        }
      });
      each(["columns", "forceLabels", "displayErrors", "floatPlaceholders", "displayErrors", "displayMessages", "language", "locale", "fallbackLocale", "orderFrom", "validateOn", "formData", "beforeSend", "locationProvider", "classHelpers", "env", "usePresets", "plugins", "size", "apiKey", "forceNumbers"], (attr) => {
        if (config2[attr] !== void 0) {
          this.options.config[attr] = config2[attr];
        }
      });
      if (config2.elements) {
        config2.elements.forEach((element2) => {
          components2[element2.name] = omit_1(element2, ["render", "staticRenderFns", "components"]);
        });
        config2.elements.forEach((element2) => {
          if (this.options.templates[element2.name] === void 0) {
            this.options.templates[element2.name] = pick_1(element2, ["render", "staticRenderFns", "components"]);
          }
        });
      }
      if (config2.axios !== void 0) {
        if (typeof config2.axios === "function") {
          this.options.services.axios = config2.axios;
        } else {
          this.options.config.axios = config2.axios;
        }
      }
    }
    registerComponents(appOrVue) {
      each(components2, (comp, name2) => {
        if (comp.register === false) {
          return;
        }
        var component = _objectSpread2$1({}, comp);
        component.setup = (props, context) => {
          context = Object.assign({}, context, {
            name: ref(name2),
            emits: component.emits
          });
          var setup = comp.setup(props, context);
          this.options.plugins.forEach((p) => {
            if (typeof p === "function") {
              p = p();
            }
            p = Array.isArray(p) ? p : [p];
            p.forEach((plugin) => {
              var pluginOptions = typeof plugin === "function" ? plugin() : plugin;
              if (pluginOptions.setup && shouldApplyPlugin(name2, pluginOptions)) {
                setup = pluginOptions.setup(props, context, setup);
              }
            });
          });
          return setup;
        };
        if (component.components === void 0) {
          var _this$options$templat, _this$options$theme$t;
          component.components = ((_this$options$templat = this.options.templates[name2]) === null || _this$options$templat === void 0 ? void 0 : _this$options$templat.components) || ((_this$options$theme$t = this.options.theme.templates[name2]) === null || _this$options$theme$t === void 0 ? void 0 : _this$options$theme$t.components) || {};
        }
        component.render = function() {
          return this.template.render.apply(this, arguments);
        };
        component.staticRenderFns = function() {
          return this.template.staticRenderFns;
        };
        this.options.plugins.forEach((p) => {
          if (typeof p === "function") {
            p = p();
          }
          p = Array.isArray(p) ? p : [p];
          p.forEach((plugin) => {
            var pluginOptions = typeof plugin === "function" ? plugin() : plugin;
            each(without_1(Object.keys(pluginOptions), "setup", "apply", "config", "install"), (key) => {
              if (pluginOptions[key] && shouldApplyPlugin(name2, pluginOptions)) {
                if (Array.isArray(pluginOptions[key])) {
                  var base79 = component[key] || [];
                  component[key] = base79.concat(pluginOptions[key]);
                } else if (isPlainObject_1(pluginOptions[key])) {
                  component[key] = Object.assign({}, component[key] || {}, pluginOptions[key]);
                } else {
                  component[key] = pluginOptions[key];
                }
              }
            });
          });
        });
        appOrVue.component(name2, component);
      });
    }
    initAxios() {
      var $axios = this.options.services.axios;
      var axiosConfig = this.options.config.axios;
      var axiosConfigFlat = flatten(this.options.config.axios);
      Object.keys(axiosConfigFlat).forEach((key) => {
        var value = axiosConfigFlat[key];
        if (["onUnauthenticated"].indexOf(key) === -1 && key.indexOf("csrfRequest.") === -1) {
          set_1($axios.defaults, key, value);
        }
      });
      $axios.interceptors.response.use((r2) => r2, (error) => {
        if (!error.response) {
          return Promise.reject(error);
        }
        return new Promise((resolve, reject) => {
          var response = error.response;
          var originalRequest = response.config;
          if ([401, 419].indexOf(error.response.status) !== -1) {
            if (axiosConfig.csrfRequest && !originalRequest.CSRF) {
              $axios.request(_objectSpread2$1(_objectSpread2$1({}, axiosConfig.csrfRequest), {}, {
                CSRF: true
              })).then(() => {
                resolve($axios.request(_objectSpread2$1(_objectSpread2$1({}, originalRequest), {}, {
                  CSRF: true
                })));
              }).catch((error2) => {
                reject(error2);
              });
            } else if (axiosConfig.onUnauthenticated) {
              axiosConfig.onUnauthenticated(originalRequest);
            } else {
              reject(error);
            }
          } else {
            reject(error);
          }
        });
      });
    }
    initI18n() {
      this.options.i18n = new i18n({
        locales: this.options.locales,
        locale: this.options.config.locale,
        fallbackLocale: this.options.config.fallbackLocale
      });
    }
    install(appOrVue) {
      var _this$options$theme;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var version2 = parseInt(appOrVue.version.split(".")[0]);
      var minor = parseInt(appOrVue.version.split(".")[1]);
      this.options.vueVersion = version2;
      var plugins2 = options.plugins || [];
      plugins2.forEach((p) => {
        if (typeof p === "function") {
          p = p();
        }
        p = Array.isArray(p) ? p : [p];
        p.forEach((plugin) => {
          var pluginOptions = typeof plugin === "function" ? plugin() : plugin;
          if (pluginOptions.config) {
            pluginOptions.config(options);
          }
        });
      });
      if (options) {
        this.config(options);
      }
      this.options.plugins.forEach((p) => {
        if (typeof p === "function") {
          p = p();
        }
        p = Array.isArray(p) ? p : [p];
        p.forEach((plugin) => {
          var pluginOptions = typeof plugin === "function" ? plugin() : plugin;
          if (pluginOptions.install) {
            pluginOptions.install(appOrVue, this.options);
          }
        });
      });
      if (typeof config$1.axios !== "function") {
        this.initAxios();
      }
      this.initI18n();
      Object.keys(this.options.components).forEach((componentName) => {
        components2[componentName] = this.options.components[componentName];
      });
      this.registerComponents(appOrVue);
      var themeTemplates = ((_this$options$theme = this.options.theme) === null || _this$options$theme === void 0 ? void 0 : _this$options$theme.templates) || {};
      Object.keys(themeTemplates).forEach((componentName) => {
        themeTemplates[componentName] = markRaw(themeTemplates[componentName]);
      });
      var $vueform = ref(_objectSpread2$1(_objectSpread2$1({}, this.options), {}, {
        theme: _objectSpread2$1(_objectSpread2$1({}, this.options.theme), {}, {
          templates: themeTemplates
        })
      }));
      switch (version2) {
        case 2:
          appOrVue.config.ignoredElements = ["trix-editor"];
          appOrVue.config.unwrapInjectedRef = true;
          if (!appOrVue.prototype.$vueform) {
            appOrVue.prototype.$vueform = new Proxy($vueform, {
              get: (target, prop, receiver) => {
                return target.value[prop];
              }
            });
          }
          if (!appOrVue.__VUEFORM__) {
            appOrVue.__VUEFORM__ = true;
            appOrVue.mixin({
              methods: {
                __: (expr, data) => {
                  if (!data) {
                    console.warn("DEPRECATED: __ method should be no longer used for translating labels, only if they contain variables. For general translation use form$.translation.TAG instead.");
                  }
                  return this.options.i18n.$t(expr, data);
                }
              }
            });
          }
          break;
        case 3:
          if (minor < 3) {
            appOrVue.config.unwrapInjectedRef = true;
          }
          appOrVue.config.globalProperties.$vueform = new Proxy($vueform, {
            get: (target, prop, receiver) => {
              return target.value[prop];
            }
          });
          appOrVue.provide("$vueform", $vueform);
          appOrVue.mixin({
            methods: {
              $set(obj, key, value) {
                obj[key] = value;
              },
              $delete(obj, key) {
                delete obj[key];
              },
              __: (expr, data) => {
                if (!data) {
                  console.warn("DEPRECATED: __ method should be no longer used for translating labels, only if they contain variables. For general translation use form$.translation.TAG instead.");
                }
                return this.options.i18n.$t(expr, data);
              }
            }
          });
          break;
      }
    }
  };
  return new Vueform();
}
var base$19 = function base4(props, context, dependencies2) {
  var form$ = inject("form$");
  return {
    form$
  };
};
var base$18 = function base5(props, context, dependencies2) {
  var theme = inject("theme");
  return {
    theme
  };
};
var base$17 = function base6(props, context, dependencies2) {
  var Size = inject("Size");
  return {
    Size
  };
};
var base$16 = function base7(props, context, dependencies2) {
  var {
    view
  } = toRefs(props);
  var componentName = context.name;
  var Views = inject("Views") || ref({});
  var ViewInject = inject("View", ref(void 0));
  var View = computed(() => {
    if (view && view.value) {
      return view.value;
    }
    if (Views.value[componentName.value]) {
      return Views.value[componentName.value];
    }
    return ViewInject.value;
  });
  return {
    View
  };
};
var base$15 = function base8(props, context, dependencies2) {
  var componentName = context.name;
  var {
    form$
  } = base$19();
  var {
    theme
  } = base$18();
  var {
    Size
  } = base$17();
  var {
    View
  } = base$16(props, context);
  var component$ = computed(() => {
    return getCurrentInstance().proxy;
  });
  var classesInstance = computed(() => {
    return new MergeClasses({
      component: componentName.value,
      component$,
      theme: theme.value,
      config: form$.value.$vueform.config,
      templates: Templates.value,
      view: View.value,
      merge: [form$.value.options]
    });
  });
  var classes = computed(() => {
    return classesInstance.value.classes;
  });
  var Templates = computed(() => {
    return theme.value.templates;
  });
  var template = computed(() => {
    return View.value && Templates.value["".concat(componentName.value, "_").concat(View.value)] ? Templates.value["".concat(componentName.value, "_").concat(View.value)] : Templates.value[componentName.value];
  });
  return {
    form$,
    theme,
    Size,
    View,
    classesInstance,
    classes,
    Templates,
    template
  };
};
var FormErrors = {
  name: "FormErrors",
  props: {
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$15(props, context);
    var errors = computed(() => {
      return form$.value.formErrors;
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      errors
    };
  }
};
var FormMessages = {
  name: "FormMessages",
  props: {
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$15(props, context);
    var messages = computed(() => {
      return form$.value.formMessages;
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      messages
    };
  }
};
var FormLanguages = {
  name: "FormLanguages",
  props: {
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$15(props, context);
    var language = computed(() => {
      return form$.value.selectedLanguage;
    });
    var languages = computed(() => {
      return form$.value.options.languages;
    });
    var select6 = (code) => {
      form$.value.setLanguage(code);
    };
    var handleSelect = (code) => {
      select6(code);
    };
    provide("View", View);
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      language,
      languages,
      select: select6,
      handleSelect
    };
  }
};
var FormLanguage = {
  name: "FormLanguage",
  emits: ["select"],
  props: {
    language: {
      type: String,
      required: true
    },
    code: {
      type: String,
      required: true
    },
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      code
    } = toRefs(props);
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$15(props, context);
    var selectedLanguage = computed(() => {
      return form$.value.selectedLanguage;
    });
    var selected = computed(() => {
      return selectedLanguage.value == code.value;
    });
    var select6 = () => {
      context.emit("select", code.value);
    };
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      selectedLanguage,
      selected,
      classes,
      Templates,
      template,
      select: select6
    };
  }
};
var baseIteratee$3 = _baseIteratee;
var isArrayLike = isArrayLike_1;
var keys2 = keys_1;
function createFind$2(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee$3(predicate);
      collection = keys2(collection);
      predicate = function(key) {
        return iteratee(iterable[key], key, iterable);
      };
    }
    var index2 = findIndexFunc(collection, predicate, fromIndex);
    return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
  };
}
var _createFind = createFind$2;
var baseFindIndex$1 = _baseFindIndex;
var baseIteratee$2 = _baseIteratee;
var toInteger$1 = toInteger_1;
var nativeMax$1 = Math.max;
function findIndex$1(array4, predicate, fromIndex) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return -1;
  }
  var index2 = fromIndex == null ? 0 : toInteger$1(fromIndex);
  if (index2 < 0) {
    index2 = nativeMax$1(length + index2, 0);
  }
  return baseFindIndex$1(array4, baseIteratee$2(predicate), index2);
}
var findIndex_1 = findIndex$1;
var createFind$1 = _createFind;
var findIndex = findIndex_1;
var find$1 = createFind$1(findIndex);
var find_1 = find$1;
var baseFindIndex = _baseFindIndex;
var baseIteratee$1 = _baseIteratee;
var toInteger = toInteger_1;
var nativeMax = Math.max;
var nativeMin = Math.min;
function findLastIndex$1(array4, predicate, fromIndex) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return -1;
  }
  var index2 = length - 1;
  if (fromIndex !== void 0) {
    index2 = toInteger(fromIndex);
    index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
  }
  return baseFindIndex(array4, baseIteratee$1(predicate), index2, true);
}
var findLastIndex_1 = findLastIndex$1;
var createFind = _createFind;
var findLastIndex = findLastIndex_1;
var findLast = createFind(findLastIndex);
var findLast_1 = findLast;
var FormTabs = {
  name: "FormTabs",
  emits: ["select"],
  props: {
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var $this = getCurrentInstance().proxy;
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$15(props, context);
    var {
      events,
      listeners,
      on: on2,
      off: off2,
      fire
    } = base$1c(props, context, {
      form$
    }, {
      events: context.emits
    });
    var tabs$Array = ref([]);
    var exists2 = ref(true);
    var elements$ = computed(() => {
      return form$.value.elements$;
    });
    var tabs = computed(() => {
      return form$.value.options.tabs;
    });
    var tabs$ = computed(() => {
      var tabList$ = {};
      each(tabs$Array.value, (formTab$) => {
        tabList$[formTab$.name] = formTab$;
      });
      return tabList$;
    });
    var visible$ = computed(() => {
      var tabList$ = {};
      each(tabs$.value, (tab$2) => {
        if (tab$2.visible) {
          tabList$[tab$2.name] = tab$2;
        }
      });
      return tabList$;
    });
    var current$ = computed(() => {
      var current = find_1(tabs$.value, {
        active: true
      });
      return current !== void 0 ? current : {};
    });
    var first$ = computed(() => {
      return find_1(visible$.value, (tab) => {
        return tab.visible;
      });
    });
    var last$ = computed(() => {
      return Object.values(visible$.value).pop();
    });
    var next$ = computed(() => {
      return find_1(visible$.value, (tab) => {
        return tab.index > current$.value.index && tab.visible;
      });
    });
    var previous$ = computed(() => {
      return findLast_1(visible$.value, (tab) => {
        return tab.index < current$.value.index && tab.visible;
      });
    });
    var goTo = (name2) => {
      var tab$2 = visible$.value[name2];
      tab$2.select();
    };
    var select6 = (tab$2) => {
      var curr$ = current$.value;
      each(elements$.value, (element$) => {
        element$.deactivate();
      });
      each(tabs$.value, (tab$3) => {
        tab$3.deactivate();
      });
      fire("select", tab$2, curr$);
    };
    var tab$ = (name2) => {
      return find_1(tabs$.value, {
        name: name2
      });
    };
    var reset = () => {
      first$.value.select();
    };
    var assignToParent = ($parent, assignToParent2) => {
      if ($parent.tabs$ !== void 0) {
        form$.value.$set($parent, "tabs$", $this);
      } else {
        assignToParent2($parent.$parent, assignToParent2);
      }
    };
    var removeFromParent = ($parent, removeFromParent2) => {
      if ($parent.tabs$ !== void 0) {
        form$.value.$set($parent, "tabs$", null);
      } else {
        removeFromParent2($parent.$parent, removeFromParent2);
      }
    };
    provide("View", View);
    watch(elements$, (newValue, oldValue) => {
      var newElements$ = difference_1(keys_1(newValue), keys_1(oldValue));
      each(newElements$, (newElement$) => {
        elements$.value[newElement$].deactivate();
      });
    }, {
      deep: false,
      lazy: true
    });
    watch(tabs, _asyncToGenerator(function* () {
      yield nextTick();
      yield nextTick();
      if ((current$.value === void 0 || current$.value.index === void 0) && first$.value) {
        first$.value.select();
      }
    }), {
      deep: true,
      lazy: true
    });
    watch(tabs, (newValue) => {
      var newTabs$Array = [];
      each(newValue, (t2, name2) => {
        newTabs$Array.push(tabs$Array.value[tabs$Array.value.map((t$) => normalize(t$.name)).indexOf(normalize(name2))]);
      });
      tabs$Array.value = newTabs$Array;
    }, {
      flush: "post"
    });
    onBeforeMount(() => {
      assignToParent($this.$parent, assignToParent);
    });
    onBeforeUnmount(() => {
      removeFromParent($this.$parent, removeFromParent);
    });
    onMounted(() => {
      nextTick(() => {
        if (!find_1(tabs$.value, {
          active: true
        })) {
          first$.value.select();
        }
      });
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      tabs,
      elements$,
      tabs$Array,
      events,
      listeners,
      exists: exists2,
      classes,
      Templates,
      template,
      tabs$,
      visible$,
      current$,
      first$,
      last$,
      next$,
      previous$,
      goTo,
      select: select6,
      tab$,
      reset,
      on: on2,
      off: off2,
      fire
    };
  }
};
var base$14 = function base9(props, context, dependencies2) {
  var {
    parent: parent2,
    conditions
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var path = dependencies2.path || ref(null);
  var el$ = dependencies2.el$ || ref(void 0);
  var conditionList = ref(conditions.value);
  var additionalConditions = ref({});
  var available = computed(() => {
    if (!form$.value.conditions) {
      return true;
    }
    if (parent2 && parent2.value && parent2.value.available !== void 0 && !parent2.value.available) {
      return false;
    }
    if (!conditionList.value || !conditionList.value.length) {
      return true;
    }
    return !some_1(conditionList.value, (condition2) => {
      return !form$.value.$vueform.services.condition.check(condition2, path.value, form$.value, el$.value);
    });
  });
  var updateConditions = () => {
    conditionList.value = Object.values(additionalConditions.value).reduce((prev, curr) => {
      return prev.concat(curr);
    }, conditions.value);
  };
  var addConditions = (key, conditions2) => {
    additionalConditions.value[key] = conditions2;
    updateConditions();
  };
  var removeConditions = (key) => {
    delete additionalConditions.value[key];
    updateConditions();
  };
  return {
    conditionList,
    available,
    additionalConditions,
    updateConditions,
    addConditions,
    removeConditions
  };
};
var list$5 = function list(props, context, dependencies2) {
  var {
    conditionList,
    available,
    additionalConditions,
    addConditions,
    removeConditions
  } = base$14(props, context, dependencies2);
  var {
    conditions
  } = toRefs(props);
  var children$Array = dependencies2.children$Array;
  var updateConditions = () => {
    conditionList.value = Object.values(additionalConditions.value).reduce((prev, curr) => {
      return prev.concat(curr);
    }, conditions.value);
    children$Array.value.forEach((child$) => {
      child$.updateConditions();
    });
  };
  return {
    conditionList,
    available,
    updateConditions,
    addConditions,
    removeConditions
  };
};
var object$8 = list$5;
var group$8 = list$5;
var {
  hasOwnProperty: hasOwnProperty2,
  toString: toString4
} = Object.prototype;
function isNonEmptyString(value) {
  return typeof value === "string" && value.trim().length > 0;
}
function isFunction3(value) {
  return typeof value === "function";
}
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}
function isNonNullObject(value) {
  return !!value;
}
function isElement(value) {
  return isNonNullObject(value) && value.nodeType === 1 && toString4.call(value).indexOf("Element") > -1;
}
function isVueComponent(value) {
  return isPlainObject_1(value) && (isNonEmptyString(value.template) || isFunction3(value.render) || isNonEmptyString(value.el) || isElement(value.el) || isVueComponent(value.extends) || isNonEmptyArray(value.mixins) && value.mixins.some((val) => isVueComponent(val))) || typeof value === "function" && value.prototype && value.prototype.constructor.name === "VueComponent";
}
function localize(object9, $config, form$) {
  var locale2 = form$.locale$ || $config.i18n.locale;
  if (!locale2) {
    return object9;
  }
  return object9 && typeof object9 === "object" ? (object9 === null || object9 === void 0 ? void 0 : object9[locale2]) || (object9 === null || object9 === void 0 ? void 0 : object9[locale2.toUpperCase()]) || (object9 === null || object9 === void 0 ? void 0 : object9[$config.i18n.fallbackLocale]) || (object9 === null || object9 === void 0 ? void 0 : object9[$config.i18n.fallbackLocale.toUpperCase()]) || (object9 === null || object9 === void 0 ? void 0 : object9[Object.keys(object9)[0]]) || "" : object9;
}
var base$13 = function base10(props, context, dependencies2) {
  var labelDefinition = dependencies2.labelDefinition;
  var component$ = dependencies2.component$ || ref(null);
  var form$ = inject("form$");
  var config$ = inject("config$");
  var baseLabel = computed(() => {
    return labelDefinition.value;
  });
  var isLabelFunction = computed(() => {
    return typeof baseLabel.value === "function" && (!baseLabel.value.prototype || !baseLabel.value.prototype.constructor || baseLabel.value.prototype.constructor && baseLabel.value.prototype.constructor.name !== "VueComponent");
  });
  var isLabelComponent = computed(() => {
    return isVueComponent(baseLabel.value);
  });
  var label = computed(() => {
    var label2 = isLabelFunction.value ? baseLabel.value(component$.value) : baseLabel.value || null;
    if (!isLabelComponent.value) {
      label2 = localize(label2, config$.value, form$.value);
    }
    return label2;
  });
  return {
    label,
    isLabelComponent
  };
};
var FormTab = {
  name: "FormTab",
  emits: ["activate", "inactivate"],
  slots: ["default"],
  props: {
    /**
     * Name of tab within [tabs](reference/frontend-form#prop-tabs) object.
     */
    name: {
      type: [String, Number],
      required: true
    },
    label: {
      type: [String, Object, Function],
      required: false,
      default: null
    },
    elements: {
      type: [Array],
      required: false,
      default: () => []
    },
    conditions: {
      type: [Array],
      required: false,
      default: () => []
    },
    addClass: {
      required: false,
      type: [Array, Object, String],
      default: null
    },
    removeClass: {
      required: false,
      type: [Array, Object],
      default: null
    },
    replaceClass: {
      required: false,
      type: [Object],
      default: null
    },
    overrideClass: {
      required: false,
      type: [Array, Object, String],
      default: null
    },
    view: {
      required: false,
      type: [String],
      default: void 0
    },
    onActivate: {
      type: [Function],
      required: false,
      default: null,
      private: true
    },
    onInactivate: {
      type: [Function],
      required: false,
      default: null,
      private: true
    }
  },
  setup(props, context) {
    var {
      name: name2,
      label,
      elements
    } = toRefs(props);
    var $this = getCurrentInstance().proxy;
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$15(props, context);
    var {
      available,
      conditionList,
      updateConditions
    } = base$14(props, context, {
      form$
    });
    var {
      isLabelComponent,
      label: tabLabel_
    } = base$13(props, context, {
      component$: form$,
      labelDefinition: label
    });
    var {
      events,
      listeners,
      on: on2,
      off: off2,
      fire
    } = base$1c(props, context, {
      form$
    }, {
      events: context.emits
    });
    var active = ref(false);
    var tabLabel = ref(tabLabel_.value && typeof tabLabel_.value === "object" ? markRaw(tabLabel_.value) : tabLabel_.value);
    var elements$ = computed(() => {
      return form$.value.elements$;
    });
    var tabs$ = computed(() => {
      return form$.value.tabs$;
    });
    var index2 = computed(() => {
      var _tabs$$value;
      return Object.keys((tabs$ === null || tabs$ === void 0 || (_tabs$$value = tabs$.value) === null || _tabs$$value === void 0 ? void 0 : _tabs$$value.tabs$) || /* istanbul ignore next: tab can not stand by itself */
      {}).indexOf(name2.value);
    });
    var isFirst = computed(() => {
      return index2.value === 0;
    });
    var isLast = computed(() => {
      return tabs$.value.last$.name === name2.value;
    });
    var children$ = computed(() => {
      return filter_1(elements$.value, (element$, key) => {
        return elements.value.indexOf(key) !== -1;
      });
    });
    var visible = computed(() => {
      return available.value;
    });
    var invalid = computed(() => {
      return some_1(children$.value, {
        available: true,
        invalid: true
      });
    });
    var tab$ = computed(() => {
      return form$.value.tabs$.tabs$[name2.value];
    });
    var select6 = () => {
      var _tabs$$value2, _tabs$$value3;
      if (active.value || !((_tabs$$value2 = tabs$.value) !== null && _tabs$$value2 !== void 0 && _tabs$$value2.select)) {
        return;
      }
      (_tabs$$value3 = tabs$.value) === null || _tabs$$value3 === void 0 || _tabs$$value3.select(tab$.value);
      activate();
    };
    var activate = () => {
      if (active.value) {
        return;
      }
      active.value = true;
      each(children$.value, (element$) => {
        element$.activate();
      });
      fire("activate");
    };
    var deactivate = () => {
      if (!active.value) {
        return;
      }
      active.value = false;
      each(children$.value, (element$) => {
        element$.deactivate();
      });
      fire("inactivate");
    };
    var addChildConditions = () => {
      if (conditionList.value.length == 0) {
        return;
      }
      Object.values(children$.value).forEach((element$) => {
        element$.addConditions("tab", conditionList.value);
      });
    };
    var removeChildConditions = () => {
      Object.values(children$.value).forEach((element$) => {
        element$.removeConditions("tab");
      });
    };
    var resetChildConditions = () => {
      removeChildConditions();
      addChildConditions();
    };
    var assignToParent = ($parent, assignToParent2) => {
      if ($parent.tabs$Array) {
        $parent.tabs$Array.push($this);
      } else {
        assignToParent2($parent.$parent, assignToParent2);
      }
    };
    var removeFromParent = ($parent, removeFromParent2) => {
      if ($parent.tabs$Array) {
        $parent.tabs$Array.splice($parent.tabs$Array.map((t$) => normalize(t$.name)).indexOf(normalize(name2.value)), 1);
      } else {
        removeFromParent2($parent.$parent, removeFromParent2);
      }
    };
    watch(children$, () => {
      if (!active.value) {
        return;
      }
      each(children$.value, (element$) => {
        element$.activate();
      });
    }, {
      deep: false,
      lazy: true
    });
    watch(tabLabel_, () => {
      tabLabel.value = tabLabel_.value && typeof tabLabel_.value === "object" ? markRaw(tabLabel_.value) : tabLabel_.value;
    });
    watch(conditionList, (n2, o2) => {
      if (!(n2 !== null && n2 !== void 0 && n2.length)) {
        removeChildConditions();
      } else {
        addChildConditions();
      }
    });
    onMounted(() => {
      nextTick(() => {
        addChildConditions();
      });
    });
    onBeforeMount(() => {
      assignToParent($this.$parent, assignToParent);
    });
    onBeforeUnmount(() => {
      removeChildConditions();
      removeFromParent($this.$parent, removeFromParent);
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      elements$,
      index: index2,
      isFirst,
      isLast,
      active,
      events,
      listeners,
      children$,
      visible,
      invalid,
      classes,
      Templates,
      template,
      available,
      isLabelComponent,
      tabLabel,
      tab$,
      tabs$,
      conditionList,
      select: select6,
      activate,
      deactivate,
      on: on2,
      off: off2,
      fire,
      addChildConditions,
      removeChildConditions,
      resetChildConditions,
      updateConditions
    };
  }
};
var FormSteps = {
  name: "FormSteps",
  emits: ["select", "next", "previous", "finish"],
  props: {
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var $this = getCurrentInstance().proxy;
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$15(props, context);
    var {
      events,
      listeners,
      on: on2,
      off: off2,
      fire
    } = base$1c(props, context, {
      form$
    }, {
      events: context.emits
    });
    var steps$Array = ref([]);
    var unwatchInvalid = ref(null);
    var exists2 = ref(true);
    var steps = computed(() => {
      return form$.value.options.steps;
    });
    var elements$ = computed(() => {
      return form$.value.elements$;
    });
    var pending = computed(() => {
      return some_1(visible$.value, {
        pending: true
      });
    });
    var debouncing = computed(() => {
      return some_1(visible$.value, {
        debouncing: true
      });
    });
    var invalid = computed(() => {
      return some_1(visible$.value, {
        invalid: true
      });
    });
    var done = computed(() => {
      return !some_1(visible$.value, {
        done: false
      });
    });
    var busy = computed(() => {
      return pending.value || debouncing.value;
    });
    var steps$ = computed(() => {
      var steps$2 = {};
      each(steps$Array.value, (step$2) => {
        steps$2[step$2.name] = step$2;
      });
      return steps$2;
    });
    var visible$ = computed(() => {
      var stepList$ = {};
      each(steps$.value, (step$2) => {
        if (step$2.visible) {
          stepList$[step$2.name] = step$2;
        }
      });
      return stepList$;
    });
    var first$ = computed(() => {
      return find_1(visible$.value, (step) => {
        return step.visible;
      });
    });
    var last$ = computed(() => {
      return Object.values(visible$.value).pop();
    });
    var current$ = computed(() => {
      var current = find_1(steps$.value, {
        active: true
      });
      return current !== void 0 ? current : {};
    });
    var next$ = computed(() => {
      return find_1(visible$.value, (step) => {
        return step.index > current$.value.index && step.visible;
      });
    });
    var previous$ = computed(() => {
      return findLast_1(visible$.value, (step) => {
        return step.index < current$.value.index && step.visible;
      });
    });
    var firstInvalid$ = computed(() => {
      return find_1(visible$.value, {
        invalid: true
      });
    });
    var firstNonDone$ = computed(() => {
      return find_1(visible$.value, {
        done: false
      });
    });
    var lastEnabled$ = computed(() => {
      return findLast_1(visible$.value, {
        isDisabled: false
      });
    });
    var isAtLastStep = computed(() => {
      var last2 = findLast_1(visible$.value, {
        visible: true
      });
      if (!current$.value || !last2) {
        return false;
      }
      return last2.index === current$.value.index;
    });
    var isAtFirstStep = computed(() => {
      return current$.value.index === 0;
    });
    var goTo = function goTo2(name2) {
      var enableUntil2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var step = visible$.value[name2];
      step.enable();
      step.select();
      if (enableUntil2) {
        nextTick(() => {
          enableUntilLastEnabled();
        });
      }
    };
    var next = () => {
      fire("next", next$.value);
      next$.value.enable();
      next$.value.select();
    };
    var previous = () => {
      fire("previous", previous$.value);
      previous$.value.select();
    };
    var complete = () => {
      each(steps$.value, (step$2) => {
        step$2.complete();
      });
    };
    var step$ = (name2) => {
      return find_1(visible$.value, {
        name: name2
      });
    };
    var reset = () => {
      each(steps$.value, (step$2) => {
        step$2.uncomplete();
        step$2.disable();
      });
      first$.value.enable();
      first$.value.select();
    };
    var enableAllSteps = () => {
      each(steps$.value, (step$2) => {
        step$2.enable();
      });
    };
    var submit = function() {
      var _ref = _asyncToGenerator(function* () {
        yield form$.value.submit();
        if (invalid.value) {
          firstInvalid$.value.select();
          return;
        }
        unwatchInvalid.value = watch(invalid, (isInvalid) => {
          if (isInvalid) {
            firstInvalid$.value.select();
          }
          unwatchInvalid.value();
        });
      });
      return function submit2() {
        return _ref.apply(this, arguments);
      };
    }();
    var select6 = (step$2) => {
      var curr$ = current$.value;
      each(elements$.value, (element$) => {
        element$.deactivate();
      });
      each(steps$.value, (step$3) => {
        step$3.deactivate();
      });
      fire("select", step$2, curr$);
    };
    var enableUntil = (index2) => {
      each(steps$.value, (step$2) => {
        if (step$2.index <= index2 && step$2.visible) {
          step$2.enable();
        }
      });
    };
    var enableUntilCurrent = () => {
      enableUntil(current$.value.index);
    };
    var enableUntilLastEnabled = () => {
      if (!lastEnabled$.value && !first$.value) {
        return;
      }
      enableUntil(lastEnabled$.value !== void 0 ? lastEnabled$.value.index : first$.value.index);
    };
    var assignToParent = ($parent, assignToParent2) => {
      if ($parent.steps$ !== void 0) {
        form$.value.$set($parent, "steps$", $this);
      } else {
        assignToParent2($parent.$parent, assignToParent2);
      }
    };
    var removeFromParent = ($parent, removeFromParent2) => {
      if ($parent.steps$ !== void 0) {
        form$.value.$set($parent, "steps$", null);
      } else {
        removeFromParent2($parent.$parent, removeFromParent2);
      }
    };
    provide("View", View);
    watch(elements$, (newValue, oldValue) => {
      var newElements$ = difference_1(keys_1(newValue), keys_1(oldValue));
      each(newElements$, (newElement$) => {
        elements$.value[newElement$].deactivate();
      });
    }, {
      deep: false,
      lazy: true
    });
    watch(steps, () => {
      nextTick(() => {
        if (lastEnabled$.value === void 0)
          ;
        if (current$.value.index === void 0 && first$.value) {
          first$.value.select();
        }
      });
    }, {
      deep: true,
      lazy: true
    });
    watch(steps, (newValue) => {
      var newSteps$Array = [];
      each(newValue, (t2, name2) => {
        newSteps$Array.push(steps$Array.value[steps$Array.value.map((t$) => normalize(t$.name)).indexOf(normalize(name2))]);
      });
      steps$Array.value = newSteps$Array;
    }, {
      flush: "post"
    });
    onBeforeMount(() => {
      assignToParent($this.$parent, assignToParent);
    });
    onBeforeUnmount(() => {
      removeFromParent($this.$parent, removeFromParent);
    });
    onMounted(() => {
      nextTick(() => {
        if (current$.value === void 0 || current$.value.index === void 0) {
          first$.value.enable();
          first$.value.select();
        }
        enableUntilCurrent();
        watch(visible$, () => {
          enableUntilLastEnabled();
        }, {
          flush: "post"
        });
      });
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      steps,
      elements$,
      steps$Array,
      events,
      listeners,
      exists: exists2,
      classes,
      Templates,
      template,
      steps$,
      pending,
      debouncing,
      invalid,
      done,
      busy,
      visible$,
      first$,
      last$,
      current$,
      next$,
      previous$,
      firstInvalid$,
      firstNonDone$,
      lastEnabled$,
      isAtLastStep,
      isAtFirstStep,
      goTo,
      next,
      previous,
      complete,
      step$,
      reset,
      enableAllSteps,
      submit,
      select: select6,
      enableUntil,
      enableUntilCurrent,
      enableUntilLastEnabled,
      on: on2,
      off: off2,
      fire
    };
  }
};
var FormStepsControls = {
  name: "FormStepsControls",
  slots: ["previous", "next", "finish"],
  props: {
    labels: {
      type: Boolean,
      required: false,
      default: true
    },
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$15(props, context);
    provide("View", View);
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    };
  }
};
var FormStepsControl = {
  name: "FormStepsControl",
  slots: ["default"],
  props: {
    type: {
      type: [String],
      required: true
    },
    labels: {
      type: [Boolean],
      required: false,
      default: true,
      private: true
    },
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      type,
      labels
    } = toRefs(props);
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$15(props, context);
    var baseLabel = computed(() => {
      if (!labels.value) {
        return null;
      }
      var stepLabels = current$ && current$.value ? current$.value.labels : (
        /* istanbul ignore next: failsafe only */
        null
      );
      switch (type.value) {
        case "previous":
          return stepLabels && stepLabels.previous ? stepLabels.previous : form$.value.translations.vueform.steps.previous;
        case "next":
          return stepLabels && stepLabels.next ? stepLabels.next : form$.value.translations.vueform.steps.next;
        case "finish":
          return stepLabels && stepLabels.finish ? stepLabels.finish : stepLabels && stepLabels.next ? stepLabels.next : form$.value.translations.vueform.steps.finish;
      }
    });
    var {
      isLabelComponent,
      label
    } = base$13(props, context, {
      component$: form$,
      labelDefinition: baseLabel
    });
    var steps$ = computed(() => {
      return form$.value.steps$;
    });
    var current$ = computed(() => {
      return steps$.value ? steps$.value.current$ : (
        /* istanbul ignore next: failsafe only */
        void 0
      );
    });
    var visible = computed(() => {
      var buttons = current$ && current$.value ? current$.value.buttons : (
        /* istanbul ignore next: failsafe only */
        null
      );
      switch (type.value) {
        case "previous":
          return !buttons ? true : buttons.previous !== false;
        case "next":
          return steps$.value && !steps$.value.isAtLastStep && (!buttons || buttons.next !== false);
        case "finish":
          return steps$.value && steps$.value.isAtLastStep && (!buttons || buttons.finish !== false);
      }
    });
    var isDisabled = computed(() => {
      switch (type.value) {
        case "previous":
          return steps$.value && steps$.value.isAtFirstStep;
        case "next":
          return current$.value !== void 0 && current$.value.index !== void 0 && // only disable next because of invalidity
          // if element validations are triggered on
          // change, otherwise it might occur that the
          // step has invalid fields, which values have
          // changed to valid, but still marked as invalid
          (current$.value.invalid && form$.value.shouldValidateOnChange || current$.value.busy || form$.value.isLoading);
        case "finish":
          return steps$.value.invalid && form$.value.shouldValidateOnChange || steps$.value.busy || form$.value.submitting || form$.value.isDisabled || form$.value.isLoading;
      }
    });
    var isLoading = computed(() => {
      return type.value === "previous" ? false : form$.value.isLoading || form$.value.submitting;
    });
    var previous = () => {
      steps$.value.previous();
    };
    var next = function() {
      var _ref = _asyncToGenerator(function* () {
        if (form$.value.shouldValidateOnStep) {
          yield current$.value.validate();
        }
        if (current$.value.invalid) {
          return;
        }
        current$.value.complete();
        steps$.value.next();
      });
      return function next2() {
        return _ref.apply(this, arguments);
      };
    }();
    var finish = function() {
      var _ref2 = _asyncToGenerator(function* () {
        steps$.value.fire("finish");
        steps$.value.complete();
        steps$.value.submit();
      });
      return function finish2() {
        return _ref2.apply(this, arguments);
      };
    }();
    var handleClick = (e2) => {
      switch (type.value) {
        case "previous":
          previous();
          break;
        case "next":
          next();
          if (e2.key === "Enter" || e2.key === " ") {
            nextTick(() => {
              nextTick(() => {
                var _current$$value$child;
                var firstEl$ = current$ === null || current$ === void 0 || (_current$$value$child = current$.value.children$) === null || _current$$value$child === void 0 ? void 0 : _current$$value$child.find((el$) => {
                  var _current$$value$eleme;
                  return el$.name === (current$ === null || current$ === void 0 || (_current$$value$eleme = current$.value.elements) === null || _current$$value$eleme === void 0 ? void 0 : _current$$value$eleme[0]);
                });
                if (!firstEl$) {
                  return;
                }
                firstEl$.focus();
              });
            });
          }
          break;
        case "finish":
          finish();
          break;
      }
    };
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      steps$,
      classes,
      Templates,
      template,
      visible,
      isDisabled,
      isLoading,
      current$,
      label,
      isLabelComponent,
      previous,
      next,
      finish,
      handleClick
    };
  }
};
var FormStep = {
  name: "FormStep",
  emits: ["activate", "inactivate", "enable", "disable", "complete"],
  slots: ["default"],
  props: {
    name: {
      type: [String, Number],
      required: true
    },
    label: {
      type: [String, Object, Function],
      required: false,
      default: null
    },
    labels: {
      type: [Object],
      required: false,
      default: () => ({})
    },
    buttons: {
      type: [Object],
      required: false,
      default: () => ({})
    },
    elements: {
      type: [Array],
      required: false,
      default: () => []
    },
    conditions: {
      type: [Array],
      required: false,
      default: () => []
    },
    addClass: {
      required: false,
      type: [Array, Object, String],
      default: null
    },
    removeClass: {
      required: false,
      type: [Array, Object],
      default: null
    },
    replaceClass: {
      required: false,
      type: [Object],
      default: null
    },
    overrideClass: {
      required: false,
      type: [Array, Object, String],
      default: null
    },
    view: {
      required: false,
      type: [String],
      default: void 0
    },
    onActivate: {
      type: [Function],
      required: false,
      default: null,
      private: true
    },
    onInactivate: {
      type: [Function],
      required: false,
      default: null,
      private: true
    },
    onDisable: {
      type: [Function],
      required: false,
      default: null,
      private: true
    },
    onEnable: {
      type: [Function],
      required: false,
      default: null,
      private: true
    }
  },
  setup(props, context) {
    var {
      name: name2,
      label,
      elements
    } = toRefs(props);
    var $this = getCurrentInstance().proxy;
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$15(props, context);
    var {
      available,
      conditionList,
      updateConditions
    } = base$14(props, context, {
      form$
    });
    var {
      isLabelComponent,
      label: stepLabel_
    } = base$13(props, context, {
      component$: form$,
      labelDefinition: label
    });
    var {
      events,
      listeners,
      on: on2,
      off: off2,
      fire
    } = base$1c(props, context, {
      form$
    }, {
      events: context.emits
    });
    var stepLabel = ref(stepLabel_.value && typeof stepLabel_.value === "object" ? markRaw(stepLabel_.value) : stepLabel_.value);
    var active = ref(false);
    var isDisabled = ref(true);
    var completed2 = ref(false);
    var elements$ = computed(() => {
      return form$.value.elements$;
    });
    var steps$ = computed(() => {
      return form$.value.steps$ || /* istanbul ignore next: failsafe only, step can not exist by itself */
      {};
    });
    var baseLabel = computed(() => {
      return label.value;
    });
    var index2 = computed(() => {
      var _steps$$value;
      return Object.keys((steps$ === null || steps$ === void 0 || (_steps$$value = steps$.value) === null || _steps$$value === void 0 ? void 0 : _steps$$value.steps$) || /* istanbul ignore next: failsafe only, step can not exist by itself */
      {}).indexOf(name2.value);
    });
    var isFirst = computed(() => {
      return index2.value === 0;
    });
    var isLast = computed(() => {
      return steps$.value.last$.name === name2.value;
    });
    var children$ = computed(() => {
      return filter_1(elements$.value, (element$, key) => {
        return elements.value.indexOf(key) !== -1;
      });
    });
    var visible = computed(() => {
      return available.value;
    });
    var invalid = computed(() => {
      return some_1(children$.value, {
        available: true,
        invalid: true
      });
    });
    var pending = computed(() => {
      return some_1(children$.value, {
        available: true,
        pending: true
      });
    });
    var debouncing = computed(() => {
      return some_1(children$.value, {
        available: true,
        debouncing: true
      });
    });
    var validated = computed(() => {
      return !some_1(children$.value, {
        available: true,
        validated: false
      });
    });
    var busy = computed(() => {
      return pending.value || debouncing.value;
    });
    var done = computed(() => {
      return completed2.value && validated.value && !invalid.value && !pending.value;
    });
    var step$ = computed(() => {
      var _form$$value$steps$;
      return (_form$$value$steps$ = form$.value.steps$) === null || _form$$value$steps$ === void 0 ? void 0 : _form$$value$steps$.steps$[name2.value];
    });
    var validate = function() {
      var _ref = _asyncToGenerator(function* () {
        if (validated.value && !invalid.value && form$.value.shouldValidateOnChange) {
          return;
        }
        yield asyncForEach(children$.value, function() {
          var _ref2 = _asyncToGenerator(function* (element$) {
            if ((!element$.validated || element$.invalid || !form$.value.shouldValidateOnChange) && element$.available && !element$.isStatic) {
              yield element$.validate();
            }
          });
          return function(_x) {
            return _ref2.apply(this, arguments);
          };
        }());
      });
      return function validate2() {
        return _ref.apply(this, arguments);
      };
    }();
    var activate = () => {
      if (active.value) {
        return;
      }
      active.value = true;
      fire("activate");
    };
    var deactivate = () => {
      if (!active.value) {
        return;
      }
      active.value = false;
      fire("inactivate");
    };
    var enable = () => {
      if (!isDisabled.value) {
        return;
      }
      isDisabled.value = false;
      fire("enable");
    };
    var disable = () => {
      if (isDisabled.value) {
        return;
      }
      isDisabled.value = true;
      fire("disable");
    };
    var complete = () => {
      if (completed2.value) {
        return;
      }
      completed2.value = true;
      fire("complete");
    };
    var uncomplete = () => {
      completed2.value = false;
    };
    var select6 = () => {
      var _steps$$value2, _steps$$value3;
      if (isDisabled.value || !((_steps$$value2 = steps$.value) !== null && _steps$$value2 !== void 0 && _steps$$value2.select)) {
        return;
      }
      (_steps$$value3 = steps$.value) === null || _steps$$value3 === void 0 || _steps$$value3.select(step$.value);
      each(children$.value, (element$) => {
        element$.activate();
      });
      activate();
    };
    var addChildConditions = () => {
      if (conditionList.value.length == 0) {
        return;
      }
      Object.values(children$.value).forEach((element$) => {
        element$.addConditions("step", conditionList.value);
      });
    };
    var removeChildConditions = () => {
      Object.values(children$.value).forEach((element$) => {
        element$.removeConditions("step");
      });
    };
    var resetChildConditions = () => {
      removeChildConditions();
      addChildConditions();
    };
    var assignToParent = ($parent, assignToParent2) => {
      if ($parent.steps$Array) {
        $parent.steps$Array.push($this);
      } else {
        assignToParent2($parent.$parent, assignToParent2);
      }
    };
    var removeFromParent = ($parent, removeFromParent2) => {
      if ($parent.steps$Array) {
        $parent.steps$Array.splice($parent.steps$Array.map((t$) => normalize(t$.name)).indexOf(normalize(name2.value)), 1);
      } else {
        removeFromParent2($parent.$parent, removeFromParent2);
      }
    };
    watch(visible, (val) => {
      if (val && index2.value < form$.value.steps$.current$.index) {
        enable();
      }
    });
    watch(children$, () => {
      if (!active.value) {
        return;
      }
      each(children$.value, (element$) => {
        element$.activate();
      });
    }, {
      deep: false,
      lazy: true
    });
    watch(stepLabel_, () => {
      stepLabel.value = stepLabel_.value && typeof stepLabel_.value === "object" ? markRaw(stepLabel_.value) : stepLabel_.value;
    });
    watch(conditionList, (n2, o2) => {
      if (!(n2 !== null && n2 !== void 0 && n2.length)) {
        removeChildConditions();
      } else {
        addChildConditions();
      }
    });
    onMounted(() => {
      nextTick(() => {
        addChildConditions();
      });
    });
    onBeforeMount(() => {
      assignToParent($this.$parent, assignToParent);
    });
    onBeforeUnmount(() => {
      removeChildConditions();
      removeFromParent($this.$parent, removeFromParent);
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      steps$,
      elements$,
      active,
      isDisabled,
      isFirst,
      isLast,
      completed: completed2,
      events,
      listeners,
      children$,
      visible,
      invalid,
      pending,
      classes,
      Templates,
      template,
      available,
      baseLabel,
      debouncing,
      validated,
      busy,
      done,
      step$,
      isLabelComponent,
      stepLabel,
      index: index2,
      conditionList,
      validate,
      activate,
      deactivate,
      enable,
      disable,
      complete,
      uncomplete,
      select: select6,
      on: on2,
      off: off2,
      fire,
      addChildConditions,
      removeChildConditions,
      resetChildConditions,
      updateConditions
    };
  }
};
var base$12 = function base11(props, context, dependencies2) {
  var component = (element2) => {
    return "".concat(upperFirst_1(camelCase_1(element2.type)), "Element");
  };
  return {
    component
  };
};
var FormElements = {
  name: "FormElements",
  slots: ["default"],
  props: {
    view: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    var {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    } = base$15(props, context);
    var {
      component
    } = base$12();
    var schema = computed(() => {
      return form$.value.options.schema;
    });
    return {
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      schema,
      component
    };
  }
};
var base$11 = function base12(props, context, dependencies2) {
  var el$ = inject("el$");
  return {
    el$
  };
};
var base$10 = function base13(props, context, dependencies2) {
  var componentName = context.name;
  var {
    form$
  } = base$19();
  var {
    el$
  } = base$11();
  var {
    theme
  } = base$18();
  var {
    Size
  } = base$17();
  var {
    View
  } = base$16(props, context);
  var component$ = computed(() => {
    return getCurrentInstance().proxy;
  });
  var classesInstance = computed(() => {
    return new MergeClasses({
      component: componentName.value,
      component$,
      theme: theme.value,
      config: form$.value.$vueform.config,
      templates: Templates.value,
      view: View.value,
      merge: [form$.value.options, el$.value]
    });
  });
  var classes = computed(() => {
    return classesInstance.value.classes;
  });
  var Templates = computed(() => {
    return el$.value.Templates;
  });
  var template = computed(() => {
    return View.value && Templates.value["".concat(componentName.value, "_").concat(View.value)] ? Templates.value["".concat(componentName.value, "_").concat(View.value)] : Templates.value[componentName.value];
  });
  return {
    el$,
    form$,
    theme,
    Size,
    View,
    classesInstance,
    classes,
    Templates,
    template
  };
};
var ElementLayout = {
  name: "ElementLayout",
  slots: ["field", "label", "info", "description", "before", "between", "after"],
  props: {
    multiple: {
      type: [Boolean],
      required: false,
      default: false
    },
    view: {
      type: [String],
      required: false,
      default: void 0
    }
  },
  setup(props, context) {
    var {
      form$,
      el$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var visible = computed(() => {
      return el$.value.visible;
    });
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      Templates,
      template,
      classes,
      visible
    };
  }
};
var ElementLayoutInline = {
  name: "ElementLayoutInline",
  slots: ["field", "label", "info", "description", "before", "between", "after"],
  setup(props, context) {
    var {
      form$,
      el$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var visible = computed(() => {
      return el$.value.visible;
    });
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      Templates,
      template,
      classes,
      visible
      // hasLabel,
    };
  }
};
var ElementLoader = {
  name: "ElementLoader",
  setup(props, context) {
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template
    };
  }
};
var ElementLabelFloating = {
  name: "ElementLabelFloating",
  props: {
    visible: {
      type: Boolean,
      default: false
    }
  },
  setup(props, context) {
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var config$ = inject("config$");
    var floating = computed(() => {
      return localize(el$.value.floating || /* istanbul ignore next: tested, but not covered */
      (form$.value.options.floatPlaceholders ? el$.value.placeholder : null), config$.value, form$.value);
    });
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      floating
    };
  }
};
var ElementLabel = {
  name: "ElementLabel",
  slots: ["default", "info"],
  setup(props, context) {
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var {
      label,
      isLabelComponent
    } = base$13(props, context, {
      labelDefinition: computed(() => {
        return el$.value.label;
      }),
      component$: el$
    });
    var name2 = computed(() => {
      return el$.value.fieldId;
    });
    var id = computed(() => {
      return el$.value.labelId;
    });
    var hasLabel = computed(() => {
      return el$.value.hasLabel;
    });
    var isSlot = computed(() => {
      var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
      return !!((_el$$value$slots = el$.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots.label || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots.label || /* istanbul ignore next: Vue2 is not checked */
      form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo.label);
    });
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      label,
      isLabelComponent,
      name: name2,
      id,
      hasLabel,
      isSlot
    };
  }
};
function isInViewport(element2) {
  var rect = element2.getBoundingClientRect();
  return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
}
var ElementInfo = {
  name: "ElementInfo",
  slots: ["default"],
  setup(props, context) {
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var config$ = inject("config$");
    var position = ref(el$.value.infoPosition);
    var info = computed(() => {
      return localize(el$.value.info, config$.value, form$.value);
    });
    var id = computed(() => {
      return el$.value.infoId;
    });
    var isSlot = computed(() => {
      var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
      return !!((_el$$value$slots = el$.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots.info || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots.info || /* istanbul ignore next: Vue2 is not checked */
      form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo.info);
    });
    var handleMouseOver = function() {
      var _ref = _asyncToGenerator(function* (e2) {
        if (position.value !== el$.value.infoPosition) {
          return;
        }
        yield nextTick();
        var wrapper = e2.target.querySelector("div");
        if (!wrapper) {
          return;
        }
        if (!isInViewport(wrapper)) {
          position.value = "right";
        }
        yield nextTick();
        if (!isInViewport(wrapper)) {
          position.value = "top";
        }
        yield nextTick();
        if (!isInViewport(wrapper)) {
          position.value = "left";
        }
        yield nextTick();
        if (!isInViewport(wrapper)) {
          position.value = "bottom";
        }
      });
      return function handleMouseOver2(_x) {
        return _ref.apply(this, arguments);
      };
    }();
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      info,
      isSlot,
      position,
      id,
      handleMouseOver
    };
  }
};
var ElementDescription = {
  name: "ElementDescription",
  slots: ["default"],
  setup(props, context) {
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var config$ = inject("config$");
    var description2 = computed(() => {
      return localize(el$.value.description, config$.value, form$.value);
    });
    var id = computed(() => {
      return el$.value.descriptionId;
    });
    var isSlot = computed(() => {
      var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
      return !!((_el$$value$slots = el$.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots.description || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots.description || /* istanbul ignore next: Vue2 is not checked */
      form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo.description);
    });
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      description: description2,
      isSlot,
      id
    };
  }
};
var ElementError = {
  name: "ElementError",
  setup(props, context) {
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var error = computed(() => {
      return el$.value.error;
    });
    var id = computed(() => {
      return el$.value.errorId;
    });
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      error,
      id
    };
  }
};
var ElementMessage = {
  name: "ElementMessage",
  setup(props, context) {
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var message = computed(() => {
      return el$.value.messageBag ? el$.value.messageBag.message : (
        /* istanbul ignore next: messageBag itself will always be defined */
        null
      );
    });
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      message
    };
  }
};
var ElementText = {
  name: "ElementText",
  slots: ["default"],
  props: {
    type: {
      type: String,
      required: true
    }
  },
  setup(props, context) {
    var {
      type
    } = toRefs(props);
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var config$ = inject("config$");
    var content = computed(() => {
      return localize(el$.value[type.value], config$.value, form$.value);
    });
    var isSlot = computed(() => {
      var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
      return !!((_el$$value$slots = el$.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots[type.value] || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots[type.value] || /* istanbul ignore next: Vue2 is not checked */
      form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo[type.value]);
    });
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      content,
      isSlot
    };
  }
};
var DragAndDrop = {
  name: "DragAndDrop",
  emits: ["click", "drop"],
  props: {
    title: {
      type: String,
      required: true
    },
    description: {
      type: String,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  setup(props, context) {
    var {
      disabled
    } = toRefs(props);
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var dragging = ref(false);
    var area = ref(null);
    var handleClick = () => {
      context.emit("click");
    };
    onMounted(() => {
      each(["drag", "dragstart", "dragend", "dragover", "dragenter", "dragleave", "drop"], (event) => {
        area.value.addEventListener(event, (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
        });
      });
      area.value.addEventListener("drop", (e2) => {
        if (disabled.value) {
          return;
        }
        context.emit("drop", e2);
        dragging.value = false;
      });
      area.value.addEventListener("dragover", (e2) => {
        if (disabled.value) {
          return;
        }
        if (dragging.value !== true) {
          dragging.value = true;
        }
      });
      area.value.addEventListener("dragleave", (e2) => {
        if (disabled.value) {
          return;
        }
        dragging.value = false;
      });
      area.value.addEventListener("dragend", (e2) => {
        if (disabled.value) {
          return;
        }
        dragging.value = false;
      });
    });
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme,
      dragging,
      area,
      handleClick
    };
  }
};
var ElementAddon = {
  name: "ElementAddon",
  slots: ["default"],
  props: {
    type: {
      required: true,
      type: String
    }
  },
  setup(props, context) {
    var {
      type
    } = toRefs(props);
    var {
      form$,
      el$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var config$ = inject("config$");
    var baseAddon = computed(() => {
      return el$.value.addons[type.value];
    });
    var addon = computed(() => {
      var addon2 = isAddonFunction.value ? baseAddon.value(el$.value) : baseAddon.value || /* istanbul ignore next: failsafe */
      null;
      if (!isAddonComponent.value) {
        addon2 = localize(addon2, config$.value, form$.value);
      }
      return addon2;
    });
    var isAddonFunction = computed(() => {
      return typeof baseAddon.value === "function" && (!baseAddon.value.prototype || !baseAddon.value.prototype.constructor || baseAddon.value.prototype.constructor && baseAddon.value.prototype.constructor.name !== "VueComponent");
    });
    var isAddonComponent = computed(() => {
      return isVueComponent(baseAddon.value);
    });
    var isSlot = computed(() => {
      var _el$$value$slots, _el$$value$$slots, _el$$value$$scopedSlo;
      return !!((_el$$value$slots = el$.value.slots) !== null && _el$$value$slots !== void 0 && _el$$value$slots["addon-".concat(type.value)] || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots["addon-".concat(type.value)] || /* istanbul ignore next: Vue2 is not checked */
      form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo["addon-".concat(type.value)] || /* istanbul ignore next */
      el$.value.slots["addon-".concat(type.value)]);
    });
    return {
      el$,
      form$,
      theme,
      Size,
      View,
      classesInstance,
      Templates,
      template,
      classes,
      addon,
      isAddonComponent,
      isSlot
    };
  }
};
var ElementAddonOptions = {
  name: "ElementAddonOptions",
  emits: ["select", "open", "close"],
  props: {
    options: {
      type: Array,
      required: false,
      default: () => []
    },
    placeholder: {
      type: [String, Number, Object],
      required: false,
      default: ""
    }
  },
  setup(props, context) {
    var {
      options
    } = toRefs(props);
    var {
      form$,
      el$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var {
      events,
      listeners,
      on: on2,
      off: off2,
      fire
    } = base$1c(props, context, {
      form$
    }, {
      events: context.emits
    });
    var isOpen = ref(false);
    var selector = ref(null);
    var dropdown = ref(null);
    var left = ref(void 0);
    var right = ref(void 0);
    var top = ref(void 0);
    var bottom = ref(void 0);
    var search = ref("");
    var searchTimeout = ref(null);
    var resizeTimeout = ref(null);
    var hoverDisabled = ref(false);
    var fullHeight = ref(false);
    var selected = ref({});
    var pointed = ref({});
    var focused = computed(() => {
      if (!search.value) {
        return {};
      }
      return options.value.find((o2) => o2.label.toLowerCase().startsWith(search.value.toString().toLowerCase()));
    });
    var style = computed(() => {
      return {
        left: left.value !== void 0 ? "".concat(left.value, "px") : void 0,
        right: right.value !== void 0 ? "".concat(right.value, "px") : void 0,
        top: top.value !== void 0 ? "".concat(top.value, "px") : void 0,
        bottom: bottom.value !== void 0 ? "".concat(bottom.value, "px") : "auto"
      };
    });
    var close = () => {
      top.value = void 0;
      bottom.value = void 0;
      fullHeight.value = false;
      isOpen.value = false;
      document.removeEventListener("click", handleClickOutside);
      document.removeEventListener("keydown", handleKeydown);
      window.removeEventListener("resize", handleResize);
      window.removeEventListener("scroll", handleScroll);
      search.value = "";
      context.emit("close");
    };
    var open = function() {
      var _ref = _asyncToGenerator(function* () {
        isOpen.value = true;
        yield nextTick();
        var selectorRect = selector.value.getBoundingClientRect();
        if (selector.value.closest('[dir="rtl"]')) {
          left.value = void 0;
          right.value = window.innerWidth - (selectorRect.left + selectorRect.width);
        } else {
          right.value = void 0;
          left.value = selectorRect.left;
        }
        resizeDropdown();
        scrollToSelected();
        setTimeout(() => {
          document.addEventListener("click", handleClickOutside);
          document.addEventListener("keydown", handleKeydown);
          window.addEventListener("resize", handleResize);
          window.addEventListener("scroll", handleScroll);
        }, 0);
        context.emit("open");
      });
      return function open2() {
        return _ref.apply(this, arguments);
      };
    }();
    var scrollToOption = (option2) => {
      if (fullHeight.value) {
        var selectorRect = selector.value.getBoundingClientRect();
        var optionRect = option2.getBoundingClientRect();
        var targetCenterY = selectorRect.top + selectorRect.height / 2;
        var optionCenterY = optionRect.top + optionRect.height / 2;
        var centerDiff = targetCenterY - optionCenterY;
        var newScrollTop = dropdown.value.scrollTop - centerDiff;
        dropdown.value.scrollTop = newScrollTop;
      } else {
        var _optionRect = option2.getBoundingClientRect();
        var dropdownRect = dropdown.value.getBoundingClientRect();
        var optionTopWithinDiv = _optionRect.top - dropdownRect.top;
        dropdown.value.scrollTop = optionTopWithinDiv + dropdown.value.scrollTop;
      }
    };
    var scrollToSelected = function() {
      var _ref2 = _asyncToGenerator(function* () {
        yield nextTick();
        var option2 = document.querySelector('[data-dropdown-for="'.concat(el$.value.fieldId, '"] [data-selected="true"]'));
        if (!option2) {
          return;
        }
        scrollToOption(option2);
      });
      return function scrollToSelected2() {
        return _ref2.apply(this, arguments);
      };
    }();
    var resizeDropdown = () => {
      if (dropdown.value.getBoundingClientRect().height >= window.innerHeight - 32) {
        fullHeight.value = true;
        top.value = 16;
        bottom.value = 16;
      } else {
        fullHeight.value = false;
        top.value = selector.value.getBoundingClientRect().top;
        if (dropdown.value.getBoundingClientRect().height > window.innerHeight - selector.value.getBoundingClientRect().top - 16) {
          bottom.value = 16;
        } else {
          bottom.value = void 0;
        }
      }
    };
    var selectOption = (option2) => {
      selected.value = option2;
      fire("select", option2);
    };
    var reset = () => {
      selected.value = {};
      fire("select", {});
    };
    var handleOptionPoint = (option2) => {
      if (hoverDisabled.value) {
        return;
      }
      pointed.value = option2;
    };
    var handleOptionClick = (option2) => {
      selectOption(option2);
      close();
      el$.value.input.focus();
    };
    var handleSelectorClick = (e2) => {
      open();
    };
    var handleSelectorKeydown = function() {
      var _ref3 = _asyncToGenerator(function* (e2) {
        if (isOpen.value) {
          return;
        }
        if (["Enter", " ", "ArrowDown", "ArrowUp"].indexOf(e2.key) !== -1) {
          e2.preventDefault();
          open();
          yield nextTick();
          var index2 = selected.value.index !== void 0 ? selected.value.index : pointed.value.index || 0;
          var option2 = document.querySelector('[data-dropdown-for="'.concat(el$.value.fieldId, '"] [data-index="').concat(index2, '"]'));
          pointed.value = options.value.find((c) => c.index === index2);
          option2.focus();
        }
      });
      return function handleSelectorKeydown2(_x) {
        return _ref3.apply(this, arguments);
      };
    }();
    var handleClickOutside = (e2) => {
      if (!dropdown.value.contains(e2.target)) {
        close();
      }
    };
    var handleKeydown = (e2) => {
      var _pointed$value;
      if (e2.key === "Escape") {
        close();
        selector.value.focus();
        return;
      }
      if (["Enter", " "].indexOf(e2.key) !== -1 && ((_pointed$value = pointed.value) === null || _pointed$value === void 0 ? void 0 : _pointed$value.index) !== void 0) {
        e2.preventDefault();
        selectOption(pointed.value);
        close();
        el$.value.input.focus();
        return;
      }
      if (e2.key === "Tab") {
        e2.preventDefault();
        close();
        el$.value.input.focus();
        return;
      }
      if (e2.key === "ArrowDown") {
        e2.preventDefault();
        var index2 = pointed.value.index === void 0 ? -1 : pointed.value.index;
        var nextIndex = index2 + 1;
        if (options.value.length < nextIndex + 1) {
          nextIndex = 0;
        }
        hoverDisabled.value = true;
        pointed.value = options.value.find((c) => c.index === nextIndex);
        var option2 = document.querySelector('[data-dropdown-for="'.concat(el$.value.fieldId, '"] [data-index="').concat(nextIndex, '"]'));
        scrollToOption(option2);
        option2.focus();
        setTimeout(() => {
          hoverDisabled.value = false;
        }, 2);
        return;
      }
      if (e2.key === "ArrowUp") {
        e2.preventDefault();
        var _index = pointed.value.index || 0;
        var prevIndex = _index - 1;
        if (prevIndex < 0) {
          prevIndex = options.value.length - 1;
        }
        hoverDisabled.value = true;
        pointed.value = options.value.find((c) => c.index === prevIndex);
        var _option = document.querySelector('[data-dropdown-for="'.concat(el$.value.fieldId, '"] [data-index="').concat(prevIndex, '"]'));
        scrollToOption(_option);
        _option.focus();
        setTimeout(() => {
          hoverDisabled.value = false;
        }, 0);
        return;
      }
      if (e2.key === "Backspace" && search.value.length) {
        search.value = search.value.slice(0, -1);
        return;
      }
      if (e2.key.length === 1 && !e2.ctrlKey && !e2.metaKey && !e2.altKey) {
        search.value += e2.key;
        hoverDisabled.value = true;
        if (searchTimeout.value) {
          clearTimeout(searchTimeout.value);
        }
        searchTimeout.value = setTimeout(() => {
          search.value = "";
        }, 1e3);
        setTimeout(() => {
          hoverDisabled.value = false;
        }, 0);
      }
    };
    var handleResize = () => {
      close();
    };
    var handleScroll = () => {
      if (resizeTimeout.value) {
        clearTimeout(resizeTimeout.value);
      }
      resizeTimeout.value = setTimeout(() => {
        resizeDropdown();
      }, 50);
    };
    onBeforeUnmount(() => {
      close();
    });
    watch(focused, (option2) => {
      if (!option2 || option2.index === void 0) {
        return;
      }
      var optionEl = document.querySelector('[data-dropdown-for="'.concat(el$.value.fieldId, '"] [data-index="').concat(option2.index, '"]'));
      scrollToOption(optionEl);
      pointed.value = option2;
      optionEl.focus();
    });
    return {
      form$,
      el$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme,
      events,
      listeners,
      on: on2,
      off: off2,
      fire,
      isOpen,
      selector,
      dropdown,
      left,
      right,
      top,
      bottom,
      style,
      search,
      searchTimeout,
      hoverDisabled,
      selected,
      pointed,
      focused,
      close,
      scrollToOption,
      scrollToSelected,
      selectOption,
      reset,
      handleOptionPoint,
      handleOptionClick,
      handleSelectorClick,
      handleSelectorKeydown,
      handleClickOutside,
      handleKeydown,
      handleResize
    };
  }
};
var HOOKS = [
  "onChange",
  "onClose",
  "onDayCreate",
  "onDestroy",
  "onKeyDown",
  "onMonthChange",
  "onOpen",
  "onParseConfig",
  "onReady",
  "onValueUpdate",
  "onYearChange",
  "onPreCalendarPosition"
];
var defaults$1 = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function(err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function(givenDate) {
    var date6 = new Date(givenDate.getTime());
    date6.setHours(0, 0, 0, 0);
    date6.setDate(date6.getDate() + 3 - (date6.getDay() + 6) % 7);
    var week1 = new Date(date6.getFullYear(), 0, 4);
    return 1 + Math.round(((date6.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: /* @__PURE__ */ new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: void 0,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};
var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  },
  months: {
    shorthand: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    longhand: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function(nth) {
    var s = nth % 100;
    if (s > 3 && s < 21)
      return "th";
    switch (s % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
var pad = function(number, length) {
  if (length === void 0) {
    length = 2;
  }
  return ("000" + number).slice(length * -1);
};
var int = function(bool) {
  return bool === true ? 1 : 0;
};
function debounce(fn, wait) {
  var t2;
  return function() {
    var _this = this;
    var args = arguments;
    clearTimeout(t2);
    t2 = setTimeout(function() {
      return fn.apply(_this, args);
    }, wait);
  };
}
var arrayify = function(obj) {
  return obj instanceof Array ? obj : [obj];
};
function toggleClass$1(elem, className, bool) {
  if (bool === true)
    return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content) {
  var e2 = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e2.className = className;
  if (content !== void 0)
    e2.textContent = content;
  return e2;
}
function clearNode(node) {
  while (node.firstChild)
    node.removeChild(node.firstChild);
}
function findParent(node, condition2) {
  if (condition2(node))
    return node;
  else if (node.parentNode)
    return findParent(node.parentNode, condition2);
  return void 0;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== void 0)
    for (var key in opts)
      numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      var path = event.composedPath();
      return path[0];
    }
    return event.target;
  } catch (error) {
    return event.target;
  }
}
var doNothing = function() {
  return void 0;
};
var monthToStr = function(monthNumber, shorthand, locale2) {
  return locale2.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function(dateObj, monthName, locale2) {
    dateObj.setMonth(locale2.months.longhand.indexOf(monthName));
  },
  G: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function(dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function(dateObj, amPM, locale2) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale2.amPM[1], "i").test(amPM)));
  },
  M: function(dateObj, shortMonth, locale2) {
    dateObj.setMonth(locale2.months.shorthand.indexOf(shortMonth));
  },
  S: function(dateObj, seconds2) {
    dateObj.setSeconds(parseFloat(seconds2));
  },
  U: function(_, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1e3);
  },
  W: function(dateObj, weekNum, locale2) {
    var weekNumber = parseInt(weekNum);
    var date6 = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date6.setDate(date6.getDate() - date6.getDay() + locale2.firstDayOfWeek);
    return date6;
  },
  Y: function(dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function(_, ISODate) {
    return new Date(ISODate);
  },
  d: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function(dateObj, minutes2) {
    dateObj.setMinutes(parseFloat(minutes2));
  },
  j: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function(dateObj, seconds2) {
    dateObj.setSeconds(parseFloat(seconds2));
  },
  u: function(_, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function(dateObj, year) {
    dateObj.setFullYear(2e3 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function(date6) {
    return date6.toISOString();
  },
  D: function(date6, locale2, options) {
    return locale2.weekdays.shorthand[formats.w(date6, locale2, options)];
  },
  F: function(date6, locale2, options) {
    return monthToStr(formats.n(date6, locale2, options) - 1, false, locale2);
  },
  G: function(date6, locale2, options) {
    return pad(formats.h(date6, locale2, options));
  },
  H: function(date6) {
    return pad(date6.getHours());
  },
  J: function(date6, locale2) {
    return locale2.ordinal !== void 0 ? date6.getDate() + locale2.ordinal(date6.getDate()) : date6.getDate();
  },
  K: function(date6, locale2) {
    return locale2.amPM[int(date6.getHours() > 11)];
  },
  M: function(date6, locale2) {
    return monthToStr(date6.getMonth(), true, locale2);
  },
  S: function(date6) {
    return pad(date6.getSeconds());
  },
  U: function(date6) {
    return date6.getTime() / 1e3;
  },
  W: function(date6, _, options) {
    return options.getWeek(date6);
  },
  Y: function(date6) {
    return pad(date6.getFullYear(), 4);
  },
  d: function(date6) {
    return pad(date6.getDate());
  },
  h: function(date6) {
    return date6.getHours() % 12 ? date6.getHours() % 12 : 12;
  },
  i: function(date6) {
    return pad(date6.getMinutes());
  },
  j: function(date6) {
    return date6.getDate();
  },
  l: function(date6, locale2) {
    return locale2.weekdays.longhand[date6.getDay()];
  },
  m: function(date6) {
    return pad(date6.getMonth() + 1);
  },
  n: function(date6) {
    return date6.getMonth() + 1;
  },
  s: function(date6) {
    return date6.getSeconds();
  },
  u: function(date6) {
    return date6.getTime();
  },
  w: function(date6) {
    return date6.getDay();
  },
  y: function(date6) {
    return String(date6.getFullYear()).substring(2);
  }
};
var createDateFormatter = function(_a) {
  var _b = _a.config, config2 = _b === void 0 ? defaults$1 : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
  return function(dateObj, frmt, overrideLocale) {
    var locale2 = overrideLocale || l10n;
    if (config2.formatDate !== void 0 && !isMobile) {
      return config2.formatDate(dateObj, frmt, locale2);
    }
    return frmt.split("").map(function(c, i, arr) {
      return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale2, config2) : c !== "\\" ? c : "";
    }).join("");
  };
};
var createDateParser = function(_a) {
  var _b = _a.config, config2 = _b === void 0 ? defaults$1 : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
  return function(date6, givenFormat, timeless, customLocale) {
    if (date6 !== 0 && !date6)
      return void 0;
    var locale2 = customLocale || l10n;
    var parsedDate;
    var dateOrig = date6;
    if (date6 instanceof Date)
      parsedDate = new Date(date6.getTime());
    else if (typeof date6 !== "string" && date6.toFixed !== void 0)
      parsedDate = new Date(date6);
    else if (typeof date6 === "string") {
      var format2 = givenFormat || (config2 || defaults$1).dateFormat;
      var datestr = String(date6).trim();
      if (datestr === "today") {
        parsedDate = /* @__PURE__ */ new Date();
        timeless = true;
      } else if (config2 && config2.parseDate) {
        parsedDate = config2.parseDate(date6, format2);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date6);
      } else {
        var matched = void 0, ops = [];
        for (var i = 0, matchIndex = 0, regexStr = ""; i < format2.length; i++) {
          var token2 = format2[i];
          var isBackSlash = token2 === "\\";
          var escaped = format2[i - 1] === "\\" || isBackSlash;
          if (tokenRegex[token2] && !escaped) {
            regexStr += tokenRegex[token2];
            var match = new RegExp(regexStr).exec(date6);
            if (match && (matched = true)) {
              ops[token2 !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token2],
                val: match[++matchIndex]
              });
            }
          } else if (!isBackSlash)
            regexStr += ".";
        }
        parsedDate = !config2 || !config2.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
        ops.forEach(function(_a2) {
          var fn = _a2.fn, val = _a2.val;
          return parsedDate = fn(parsedDate, val, locale2) || parsedDate;
        });
        parsedDate = matched ? parsedDate : void 0;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config2.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return void 0;
    }
    if (timeless === true)
      parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date22, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date22.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date22.getTime();
}
var isBetween2 = function(ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function(hours2, minutes2, seconds2) {
  return hours2 * 3600 + minutes2 * 60 + seconds2;
};
var parseSeconds = function(secondsSinceMidnight) {
  var hours2 = Math.floor(secondsSinceMidnight / 3600), minutes2 = (secondsSinceMidnight - hours2 * 3600) / 60;
  return [hours2, minutes2, secondsSinceMidnight - hours2 * 3600 - minutes2 * 60];
};
var duration = {
  DAY: 864e5
};
function getDefaultHours(config2) {
  var hours2 = config2.defaultHour;
  var minutes2 = config2.defaultMinute;
  var seconds2 = config2.defaultSeconds;
  if (config2.minDate !== void 0) {
    var minHour = config2.minDate.getHours();
    var minMinutes = config2.minDate.getMinutes();
    var minSeconds = config2.minDate.getSeconds();
    if (hours2 < minHour) {
      hours2 = minHour;
    }
    if (hours2 === minHour && minutes2 < minMinutes) {
      minutes2 = minMinutes;
    }
    if (hours2 === minHour && minutes2 === minMinutes && seconds2 < minSeconds)
      seconds2 = config2.minDate.getSeconds();
  }
  if (config2.maxDate !== void 0) {
    var maxHr = config2.maxDate.getHours();
    var maxMinutes = config2.maxDate.getMinutes();
    hours2 = Math.min(hours2, maxHr);
    if (hours2 === maxHr)
      minutes2 = Math.min(maxMinutes, minutes2);
    if (hours2 === maxHr && minutes2 === maxMinutes)
      seconds2 = config2.maxDate.getSeconds();
  }
  return { hours: hours2, minutes: minutes2, seconds: seconds2 };
}
if (typeof Object.assign !== "function") {
  Object.assign = function(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function(source2) {
      if (source2) {
        Object.keys(source2).forEach(function(key) {
          return target[key] = source2[key];
        });
      }
    };
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var source = args_1[_a];
      _loop_1(source);
    }
    return target;
  };
}
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __spreadArrays = function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r2[k] = a[j];
  return r2;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element2, instanceConfig) {
  var self2 = {
    config: __assign(__assign({}, defaults$1), flatpickr.defaultConfig),
    l10n: english
  };
  self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  self2._handlers = [];
  self2.pluginElements = [];
  self2.loadedPlugins = [];
  self2._bind = bind2;
  self2._setHoursFromDate = setHoursFromDate;
  self2._positionCalendar = positionCalendar;
  self2.changeMonth = changeMonth;
  self2.changeYear = changeYear;
  self2.clear = clear;
  self2.close = close;
  self2.onMouseOver = onMouseOver;
  self2._createElement = createElement;
  self2.createDay = createDay;
  self2.destroy = destroy2;
  self2.isEnabled = isEnabled;
  self2.jumpToDate = jumpToDate;
  self2.updateValue = updateValue;
  self2.open = open;
  self2.redraw = redraw;
  self2.set = set3;
  self2.setDate = setDate;
  self2.toggle = toggle3;
  function setupHelperFunctions() {
    self2.utils = {
      getDaysInMonth: function(month, yr) {
        if (month === void 0) {
          month = self2.currentMonth;
        }
        if (yr === void 0) {
          yr = self2.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
          return 29;
        return self2.l10n.daysInMonth[month];
      }
    };
  }
  function init() {
    self2.element = self2.input = element2;
    self2.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self2.isMobile)
      build();
    bindEvents();
    if (self2.selectedDates.length || self2.config.noCalendar) {
      if (self2.config.enableTime) {
        setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self2.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function getClosestActiveElement() {
    var _a;
    return ((_a = self2.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn) {
    return fn.bind(self2);
  }
  function setCalendarWidth() {
    var config2 = self2.config;
    if (config2.weekNumbers === false && config2.showMonths === 1) {
      return;
    } else if (config2.noCalendar !== true) {
      window.requestAnimationFrame(function() {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.style.visibility = "hidden";
          self2.calendarContainer.style.display = "block";
        }
        if (self2.daysContainer !== void 0) {
          var daysWidth = (self2.days.offsetWidth + 1) * config2.showMonths;
          self2.daysContainer.style.width = daysWidth + "px";
          self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
          self2.calendarContainer.style.removeProperty("visibility");
          self2.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e2) {
    if (self2.selectedDates.length === 0) {
      var defaultDate = self2.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
      var defaults4 = getDefaultHours(self2.config);
      defaultDate.setHours(defaults4.hours, defaults4.minutes, defaults4.seconds, defaultDate.getMilliseconds());
      self2.selectedDates = [defaultDate];
      self2.latestSelectedDateObj = defaultDate;
    }
    if (e2 !== void 0 && e2.type !== "blur") {
      timeWrapper(e2);
    }
    var prevValue = self2._input.value;
    setHoursFromInputs();
    updateValue();
    if (self2._input.value !== prevValue) {
      self2._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self2.hourElement === void 0 || self2.minuteElement === void 0)
      return;
    var hours2 = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes2 = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds2 = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
    if (self2.amPM !== void 0) {
      hours2 = ampm2military(hours2, self2.amPM.textContent);
    }
    var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
    var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
    if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours2, minutes2, seconds2);
      if (currentTime > maxBound && currentTime < minBound) {
        var result = parseSeconds(minBound);
        hours2 = result[0];
        minutes2 = result[1];
        seconds2 = result[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
        hours2 = Math.min(hours2, maxTime.getHours());
        if (hours2 === maxTime.getHours())
          minutes2 = Math.min(minutes2, maxTime.getMinutes());
        if (minutes2 === maxTime.getMinutes())
          seconds2 = Math.min(seconds2, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
        hours2 = Math.max(hours2, minTime.getHours());
        if (hours2 === minTime.getHours() && minutes2 < minTime.getMinutes())
          minutes2 = minTime.getMinutes();
        if (minutes2 === minTime.getMinutes())
          seconds2 = Math.max(seconds2, minTime.getSeconds());
      }
    }
    setHours(hours2, minutes2, seconds2);
  }
  function setHoursFromDate(dateObj) {
    var date6 = dateObj || self2.latestSelectedDateObj;
    if (date6 && date6 instanceof Date) {
      setHours(date6.getHours(), date6.getMinutes(), date6.getSeconds());
    }
  }
  function setHours(hours2, minutes2, seconds2) {
    if (self2.latestSelectedDateObj !== void 0) {
      self2.latestSelectedDateObj.setHours(hours2 % 24, minutes2, seconds2 || 0, 0);
    }
    if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
      return;
    self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours2) % 12 + 12 * int(hours2 % 12 === 0) : hours2);
    self2.minuteElement.value = pad(minutes2);
    if (self2.amPM !== void 0)
      self2.amPM.textContent = self2.l10n.amPM[int(hours2 >= 12)];
    if (self2.secondElement !== void 0)
      self2.secondElement.value = pad(seconds2);
  }
  function onYearInput(event) {
    var eventTarget = getEventTarget(event);
    var year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind2(element3, event, handler, options) {
    if (event instanceof Array)
      return event.forEach(function(ev) {
        return bind2(element3, ev, handler, options);
      });
    if (element3 instanceof Array)
      return element3.forEach(function(el) {
        return bind2(el, event, handler, options);
      });
    element3.addEventListener(event, handler, options);
    self2._handlers.push({
      remove: function() {
        return element3.removeEventListener(event, handler, options);
      }
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self2.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function(evt) {
        Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
          return bind2(el, "click", self2[evt]);
        });
      });
    }
    if (self2.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce(onResize, 50);
    self2._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
      bind2(self2.daysContainer, "mouseover", function(e2) {
        if (self2.config.mode === "range")
          onMouseOver(getEventTarget(e2));
      });
    bind2(self2._input, "keydown", onKeyDown);
    if (self2.calendarContainer !== void 0) {
      bind2(self2.calendarContainer, "keydown", onKeyDown);
    }
    if (!self2.config.inline && !self2.config.static)
      bind2(window, "resize", debouncedResize);
    if (window.ontouchstart !== void 0)
      bind2(window.document, "touchstart", documentClick);
    else
      bind2(window.document, "mousedown", documentClick);
    bind2(window.document, "focus", documentClick, { capture: true });
    if (self2.config.clickOpens === true) {
      bind2(self2._input, "focus", self2.open);
      bind2(self2._input, "click", self2.open);
    }
    if (self2.daysContainer !== void 0) {
      bind2(self2.monthNav, "click", onMonthNavClick);
      bind2(self2.monthNav, ["keyup", "increment"], onYearInput);
      bind2(self2.daysContainer, "click", selectDate);
    }
    if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
      var selText = function(e2) {
        return getEventTarget(e2).select();
      };
      bind2(self2.timeContainer, ["increment"], updateTime);
      bind2(self2.timeContainer, "blur", updateTime, { capture: true });
      bind2(self2.timeContainer, "click", timeIncrement);
      bind2([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
      if (self2.secondElement !== void 0)
        bind2(self2.secondElement, "focus", function() {
          return self2.secondElement && self2.secondElement.select();
        });
      if (self2.amPM !== void 0) {
        bind2(self2.amPM, "click", function(e2) {
          updateTime(e2);
        });
      }
    }
    if (self2.config.allowInput) {
      bind2(self2._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange2) {
    var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
    var oldYear = self2.currentYear;
    var oldMonth = self2.currentMonth;
    try {
      if (jumpTo !== void 0) {
        self2.currentYear = jumpTo.getFullYear();
        self2.currentMonth = jumpTo.getMonth();
      }
    } catch (e2) {
      e2.message = "Invalid date supplied: " + jumpTo;
      self2.config.errorHandler(e2);
    }
    if (triggerChange2 && self2.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self2.redraw();
  }
  function timeIncrement(e2) {
    var eventTarget = getEventTarget(e2);
    if (~eventTarget.className.indexOf("arrow"))
      incrementNumInput(e2, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e2, delta, inputElem) {
    var target = e2 && getEventTarget(e2);
    var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event = createEvent("increment");
    event.delta = delta;
    input && input.dispatchEvent(event);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self2.calendarContainer = createElement("div", "flatpickr-calendar");
    self2.calendarContainer.tabIndex = -1;
    if (!self2.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self2.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self2.config.weekNumbers) {
        var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
        self2.innerContainer.appendChild(weekWrapper);
        self2.weekNumbers = weekNumbers;
        self2.weekWrapper = weekWrapper;
      }
      self2.rContainer = createElement("div", "flatpickr-rContainer");
      self2.rContainer.appendChild(buildWeekdays());
      if (!self2.daysContainer) {
        self2.daysContainer = createElement("div", "flatpickr-days");
        self2.daysContainer.tabIndex = -1;
      }
      buildDays();
      self2.rContainer.appendChild(self2.daysContainer);
      self2.innerContainer.appendChild(self2.rContainer);
      fragment.appendChild(self2.innerContainer);
    }
    if (self2.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass$1(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
    toggleClass$1(self2.calendarContainer, "animate", self2.config.animate === true);
    toggleClass$1(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
    self2.calendarContainer.appendChild(fragment);
    var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
    if (self2.config.inline || self2.config.static) {
      self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
      if (self2.config.inline) {
        if (!customAppend && self2.element.parentNode)
          self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
        else if (self2.config.appendTo !== void 0)
          self2.config.appendTo.appendChild(self2.calendarContainer);
      }
      if (self2.config.static) {
        var wrapper = createElement("div", "flatpickr-wrapper");
        if (self2.element.parentNode)
          self2.element.parentNode.insertBefore(wrapper, self2.element);
        wrapper.appendChild(self2.element);
        if (self2.altInput)
          wrapper.appendChild(self2.altInput);
        wrapper.appendChild(self2.calendarContainer);
      }
    }
    if (!self2.config.static && !self2.config.inline)
      (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
  }
  function createDay(className, date6, _dayNumber, i) {
    var dateIsEnabled = isEnabled(date6, true), dayElement = createElement("span", className, date6.getDate().toString());
    dayElement.dateObj = date6;
    dayElement.$i = i;
    dayElement.setAttribute("aria-label", self2.formatDate(date6, self2.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date6, self2.now) === 0) {
      self2.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date6)) {
        dayElement.classList.add("selected");
        self2.selectedDateElem = dayElement;
        if (self2.config.mode === "range") {
          toggleClass$1(dayElement, "startRange", self2.selectedDates[0] && compareDates(date6, self2.selectedDates[0], true) === 0);
          toggleClass$1(dayElement, "endRange", self2.selectedDates[1] && compareDates(date6, self2.selectedDates[1], true) === 0);
          if (className === "nextMonthDay")
            dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self2.config.mode === "range") {
      if (isDateInRange(date6) && !isDateSelected(date6))
        dayElement.classList.add("inRange");
    }
    if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i % 7 === 6) {
      self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date6) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self2.config.mode === "range")
      onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    for (var m = startMonth; m != endMonth; m += delta) {
      var month = self2.daysContainer.children[m];
      var startIndex = delta > 0 ? 0 : month.children.length - 1;
      var endIndex = delta > 0 ? month.children.length : -1;
      for (var i = startIndex; i != endIndex; i += delta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
          return c;
      }
    }
    return void 0;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m = givenMonth - self2.currentMonth; m != endMonth; m += loopDelta) {
      var month = self2.daysContainer.children[m];
      var startIndex = givenMonth - self2.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta))
          return focusOnDayElem(c);
      }
    }
    self2.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return void 0;
  }
  function focusOnDay(current, offset2) {
    var activeElement = getClosestActiveElement();
    var dayFocused = isInView(activeElement || document.body);
    var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset2 > 0 ? 1 : -1);
    if (startElem === void 0) {
      self2._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset2);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth2 = self2.utils.getDaysInMonth(month, year), days2 = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days2.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth2; dayNumber++, dayIndex++) {
      days2.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth2 + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days2.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth2), dayNum, dayIndex));
    }
    var dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days2);
    return dayContainer;
  }
  function buildDays() {
    if (self2.daysContainer === void 0) {
      return;
    }
    clearNode(self2.daysContainer);
    if (self2.weekNumbers)
      clearNode(self2.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i = 0; i < self2.config.showMonths; i++) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self2.daysContainer.appendChild(frag);
    self2.days = self2.daysContainer.firstChild;
    if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
      return;
    var shouldBuildMonth = function(month2) {
      if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
        return false;
      }
      return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
    };
    self2.monthsDropdownContainer.tabIndex = -1;
    self2.monthsDropdownContainer.innerHTML = "";
    for (var i = 0; i < 12; i++) {
      if (!shouldBuildMonth(i))
        continue;
      var month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self2.currentYear, i).getMonth().toString();
      month.textContent = monthToStr(i, self2.config.shorthandCurrentMonth, self2.l10n);
      month.tabIndex = -1;
      if (self2.currentMonth === i) {
        month.selected = true;
      }
      self2.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container = createElement("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
      bind2(self2.monthsDropdownContainer, "change", function(e2) {
        var target = getEventTarget(e2);
        var selectedMonth = parseInt(target.value, 10);
        self2.changeMonth(selectedMonth - self2.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self2.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
    if (self2.config.minDate) {
      yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
    }
    if (self2.config.maxDate) {
      yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
    }
    var currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container,
      yearElement,
      monthElement
    };
  }
  function buildMonths() {
    clearNode(self2.monthNav);
    self2.monthNav.appendChild(self2.prevMonthNav);
    if (self2.config.showMonths) {
      self2.yearElements = [];
      self2.monthElements = [];
    }
    for (var m = self2.config.showMonths; m--; ) {
      var month = buildMonth();
      self2.yearElements.push(month.yearElement);
      self2.monthElements.push(month.monthElement);
      self2.monthNav.appendChild(month.container);
    }
    self2.monthNav.appendChild(self2.nextMonthNav);
  }
  function buildMonthNav() {
    self2.monthNav = createElement("div", "flatpickr-months");
    self2.yearElements = [];
    self2.monthElements = [];
    self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self2.prevMonthNav.innerHTML = self2.config.prevArrow;
    self2.nextMonthNav = createElement("span", "flatpickr-next-month");
    self2.nextMonthNav.innerHTML = self2.config.nextArrow;
    buildMonths();
    Object.defineProperty(self2, "_hidePrevMonthArrow", {
      get: function() {
        return self2.__hidePrevMonthArrow;
      },
      set: function(bool) {
        if (self2.__hidePrevMonthArrow !== bool) {
          toggleClass$1(self2.prevMonthNav, "flatpickr-disabled", bool);
          self2.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self2, "_hideNextMonthArrow", {
      get: function() {
        return self2.__hideNextMonthArrow;
      },
      set: function(bool) {
        if (self2.__hideNextMonthArrow !== bool) {
          toggleClass$1(self2.nextMonthNav, "flatpickr-disabled", bool);
          self2.__hideNextMonthArrow = bool;
        }
      }
    });
    self2.currentYearElement = self2.yearElements[0];
    updateNavigationCurrentMonth();
    return self2.monthNav;
  }
  function buildTime() {
    self2.calendarContainer.classList.add("hasTime");
    if (self2.config.noCalendar)
      self2.calendarContainer.classList.add("noCalendar");
    var defaults4 = getDefaultHours(self2.config);
    self2.timeContainer = createElement("div", "flatpickr-time");
    self2.timeContainer.tabIndex = -1;
    var separator = createElement("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self2.l10n.hourAriaLabel
    });
    self2.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self2.l10n.minuteAriaLabel
    });
    self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
    self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults4.hours : military2ampm(defaults4.hours));
    self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults4.minutes);
    self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
    self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
    self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
    self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
    self2.hourElement.setAttribute("maxlength", "2");
    self2.minuteElement.setAttribute("min", "0");
    self2.minuteElement.setAttribute("max", "59");
    self2.minuteElement.setAttribute("maxlength", "2");
    self2.timeContainer.appendChild(hourInput);
    self2.timeContainer.appendChild(separator);
    self2.timeContainer.appendChild(minuteInput);
    if (self2.config.time_24hr)
      self2.timeContainer.classList.add("time24hr");
    if (self2.config.enableSeconds) {
      self2.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self2.secondElement = secondInput.getElementsByTagName("input")[0];
      self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults4.seconds);
      self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
      self2.secondElement.setAttribute("min", "0");
      self2.secondElement.setAttribute("max", "59");
      self2.secondElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self2.timeContainer.appendChild(secondInput);
    }
    if (!self2.config.time_24hr) {
      self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
      self2.amPM.title = self2.l10n.toggleTitle;
      self2.amPM.tabIndex = -1;
      self2.timeContainer.appendChild(self2.amPM);
    }
    return self2.timeContainer;
  }
  function buildWeekdays() {
    if (!self2.weekdayContainer)
      self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
    else
      clearNode(self2.weekdayContainer);
    for (var i = self2.config.showMonths; i--; ) {
      var container = createElement("div", "flatpickr-weekdaycontainer");
      self2.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self2.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self2.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self2.l10n.firstDayOfWeek;
    var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
    }
    for (var i = self2.config.showMonths; i--; ) {
      self2.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self2.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
    var weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper,
      weekNumbers
    };
  }
  function changeMonth(value, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value : value - self2.currentMonth;
    if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
      return;
    self2.currentMonth += delta;
    if (self2.currentMonth < 0 || self2.currentMonth > 11) {
      self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
      self2.currentMonth = (self2.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self2.input.value = "";
    if (self2.altInput !== void 0)
      self2.altInput.value = "";
    if (self2.mobileInput !== void 0)
      self2.mobileInput.value = "";
    self2.selectedDates = [];
    self2.latestSelectedDateObj = void 0;
    if (toInitial === true) {
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
    }
    if (self2.config.enableTime === true) {
      var _a = getDefaultHours(self2.config), hours2 = _a.hours, minutes2 = _a.minutes, seconds2 = _a.seconds;
      setHours(hours2, minutes2, seconds2);
    }
    self2.redraw();
    if (triggerChangeEvent)
      triggerEvent("onChange");
  }
  function close() {
    self2.isOpen = false;
    if (!self2.isMobile) {
      if (self2.calendarContainer !== void 0) {
        self2.calendarContainer.classList.remove("open");
      }
      if (self2._input !== void 0) {
        self2._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy2() {
    if (self2.config !== void 0)
      triggerEvent("onDestroy");
    for (var i = self2._handlers.length; i--; ) {
      self2._handlers[i].remove();
    }
    self2._handlers = [];
    if (self2.mobileInput) {
      if (self2.mobileInput.parentNode)
        self2.mobileInput.parentNode.removeChild(self2.mobileInput);
      self2.mobileInput = void 0;
    } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
      if (self2.config.static && self2.calendarContainer.parentNode) {
        var wrapper = self2.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild)
            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else
        self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
    }
    if (self2.altInput) {
      self2.input.type = "text";
      if (self2.altInput.parentNode)
        self2.altInput.parentNode.removeChild(self2.altInput);
      delete self2.altInput;
    }
    if (self2.input) {
      self2.input.type = self2.input._type;
      self2.input.classList.remove("flatpickr-input");
      self2.input.removeAttribute("readonly");
    }
    [
      "_showTimeInput",
      "latestSelectedDateObj",
      "_hideNextMonthArrow",
      "_hidePrevMonthArrow",
      "__hideNextMonthArrow",
      "__hidePrevMonthArrow",
      "isMobile",
      "isOpen",
      "selectedDateElem",
      "minDateHasTime",
      "maxDateHasTime",
      "days",
      "daysContainer",
      "_input",
      "_positionElement",
      "innerContainer",
      "rContainer",
      "monthNav",
      "todayDateElem",
      "calendarContainer",
      "weekdayContainer",
      "prevMonthNav",
      "nextMonthNav",
      "monthsDropdownContainer",
      "currentMonthElement",
      "currentYearElement",
      "navigationCurrentMonth",
      "selectedDateElem",
      "config"
    ].forEach(function(k) {
      try {
        delete self2[k];
      } catch (_) {
      }
    });
  }
  function isCalendarElem(elem) {
    return self2.calendarContainer.contains(elem);
  }
  function documentClick(e2) {
    if (self2.isOpen && !self2.config.inline) {
      var eventTarget_1 = getEventTarget(e2);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e2.path && e2.path.indexOf && (~e2.path.indexOf(self2.input) || ~e2.path.indexOf(self2.altInput));
      var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e2.relatedTarget);
      var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self2.config.allowInput) {
          self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
        }
        if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
          updateTime();
        }
        self2.close();
        if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
          self2.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
      return;
    var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
    self2.currentYear = newYearNum || self2.currentYear;
    if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
      self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
    } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
      self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
    }
    if (isNewYear) {
      self2.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date6, timeless) {
    var _a;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self2.parseDate(date6, void 0, timeless);
    if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
      return false;
    if (!self2.config.enable && self2.config.disable.length === 0)
      return true;
    if (dateToCheck === void 0)
      return false;
    var bool = !!self2.config.enable, array4 = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
    for (var i = 0, d = void 0; i < array4.length; i++) {
      d = array4[i];
      if (typeof d === "function" && d(dateToCheck))
        return bool;
      else if (d instanceof Date && dateToCheck !== void 0 && d.getTime() === dateToCheck.getTime())
        return bool;
      else if (typeof d === "string") {
        var parsed = self2.parseDate(d, void 0, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== void 0 && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime())
        return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self2.daysContainer !== void 0)
      return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e2) {
    var isInput = e2.target === self2._input;
    var valueChanged = self2._input.value.trimEnd() !== getDateStr();
    if (isInput && valueChanged && !(e2.relatedTarget && isCalendarElem(e2.relatedTarget))) {
      self2.setDate(self2._input.value, true, e2.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
    }
  }
  function onKeyDown(e2) {
    var eventTarget = getEventTarget(e2);
    var isInput = self2.config.wrap ? element2.contains(eventTarget) : eventTarget === self2._input;
    var allowInput = self2.config.allowInput;
    var allowKeydown = self2.isOpen && (!allowInput || !isInput);
    var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
    if (e2.keyCode === 13 && isInput) {
      if (allowInput) {
        self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
        self2.close();
        return eventTarget.blur();
      } else {
        self2.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
      switch (e2.keyCode) {
        case 13:
          if (isTimeObj) {
            e2.preventDefault();
            updateTime();
            focusAndClose();
          } else
            selectDate(e2);
          break;
        case 27:
          e2.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self2.config.allowInput) {
            e2.preventDefault();
            self2.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e2.preventDefault();
            var activeElement = getClosestActiveElement();
            if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
              var delta_1 = e2.keyCode === 39 ? 1 : -1;
              if (!e2.ctrlKey)
                focusOnDay(void 0, delta_1);
              else {
                e2.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self2.hourElement)
            self2.hourElement.focus();
          break;
        case 38:
        case 40:
          e2.preventDefault();
          var delta = e2.keyCode === 40 ? 1 : -1;
          if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
            if (e2.ctrlKey) {
              e2.stopPropagation();
              changeYear(self2.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj)
              focusOnDay(void 0, delta * 7);
          } else if (eventTarget === self2.currentYearElement) {
            changeYear(self2.currentYear - delta);
          } else if (self2.config.enableTime) {
            if (!isTimeObj && self2.hourElement)
              self2.hourElement.focus();
            updateTime(e2);
            self2._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [
              self2.hourElement,
              self2.minuteElement,
              self2.secondElement,
              self2.amPM
            ].concat(self2.pluginElements).filter(function(x) {
              return x;
            });
            var i = elems.indexOf(eventTarget);
            if (i !== -1) {
              var target = elems[i + (e2.shiftKey ? -1 : 1)];
              e2.preventDefault();
              (target || self2._input).focus();
            }
          } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e2.shiftKey) {
            e2.preventDefault();
            self2._input.focus();
          }
          break;
      }
    }
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      switch (e2.key) {
        case self2.l10n.amPM[0].charAt(0):
        case self2.l10n.amPM[0].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self2.l10n.amPM[1].charAt(0):
        case self2.l10n.amPM[1].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e2);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
      return;
    var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0, maxRange = 0;
    for (var t2 = rangeStartDate; t2 < rangeEndDate; t2 += duration.DAY) {
      if (!isEnabled(new Date(t2), true)) {
        containsDisabled = containsDisabled || t2 > rangeStartDate && t2 < rangeEndDate;
        if (t2 < initialDate && (!minRange || t2 > minRange))
          minRange = t2;
        else if (t2 > initialDate && (!maxRange || t2 < maxRange))
          maxRange = t2;
      }
    }
    var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function(dayElem) {
      var date6 = dayElem.dateObj;
      var timestamp = date6.getTime();
      var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function(c) {
          dayElem.classList.remove(c);
        });
        return;
      } else if (containsDisabled && !outOfRange)
        return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c) {
        dayElem.classList.remove(c);
      });
      if (elem !== void 0) {
        elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp === initialDate)
          dayElem.classList.add("startRange");
        else if (initialDate > hoverDate && timestamp === initialDate)
          dayElem.classList.add("endRange");
        if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween2(timestamp, initialDate, hoverDate))
          dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self2.isOpen && !self2.config.static && !self2.config.inline)
      positionCalendar();
  }
  function open(e2, positionElement) {
    if (positionElement === void 0) {
      positionElement = self2._positionElement;
    }
    if (self2.isMobile === true) {
      if (e2) {
        e2.preventDefault();
        var eventTarget = getEventTarget(e2);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self2.mobileInput !== void 0) {
        self2.mobileInput.focus();
        self2.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self2._input.disabled || self2.config.inline) {
      return;
    }
    var wasOpen = self2.isOpen;
    self2.isOpen = true;
    if (!wasOpen) {
      self2.calendarContainer.classList.add("open");
      self2._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self2.config.enableTime === true && self2.config.noCalendar === true) {
      if (self2.config.allowInput === false && (e2 === void 0 || !self2.timeContainer.contains(e2.relatedTarget))) {
        setTimeout(function() {
          return self2.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function(date6) {
      var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date6, self2.config.dateFormat);
      var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== void 0) {
        self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self2.selectedDates) {
        self2.selectedDates = self2.selectedDates.filter(function(d) {
          return isEnabled(d);
        });
        if (!self2.selectedDates.length && type === "min")
          setHoursFromDate(dateObj);
        updateValue();
      }
      if (self2.daysContainer) {
        redraw();
        if (dateObj !== void 0)
          self2.currentYearElement[type] = dateObj.getFullYear().toString();
        else
          self2.currentYearElement.removeAttribute(type);
        self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = [
      "wrap",
      "weekNumbers",
      "allowInput",
      "allowInvalidPreload",
      "clickOpens",
      "time_24hr",
      "enableTime",
      "noCalendar",
      "altInput",
      "shorthandCurrentMonth",
      "inline",
      "static",
      "enableSeconds",
      "disableMobile"
    ];
    var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element2.dataset || {}))), instanceConfig);
    var formats2 = {};
    self2.config.parseDate = userConfig.parseDate;
    self2.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self2.config, "enable", {
      get: function() {
        return self2.config._enable;
      },
      set: function(dates6) {
        self2.config._enable = parseDateRules(dates6);
      }
    });
    Object.defineProperty(self2.config, "disable", {
      get: function() {
        return self2.config._disable;
      },
      set: function(dates6) {
        self2.config._disable = parseDateRules(dates6);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults$1.dateFormat;
      formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults$1.altFormat;
      formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self2.config, "minDate", {
      get: function() {
        return self2.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self2.config, "maxDate", {
      get: function() {
        return self2.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function(type) {
      return function(val) {
        self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self2.config, "minTime", {
      get: function() {
        return self2.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self2.config, "maxTime", {
      get: function() {
        return self2.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self2.config.noCalendar = true;
      self2.config.enableTime = true;
    }
    Object.assign(self2.config, formats2, userConfig);
    for (var i = 0; i < boolOpts.length; i++)
      self2.config[boolOpts[i]] = self2.config[boolOpts[i]] === true || self2.config[boolOpts[i]] === "true";
    HOOKS.filter(function(hook) {
      return self2.config[hook] !== void 0;
    }).forEach(function(hook) {
      self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
    });
    self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i = 0; i < self2.config.plugins.length; i++) {
      var pluginConf = self2.config.plugins[i](self2) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
        } else if (typeof userConfig[key] === "undefined")
          self2.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self2.config.wrap ? element2.querySelector("[data-input]") : element2;
  }
  function setupLocale() {
    if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
      self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
    self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
    tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element2.dataset || {})));
    if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
      self2.config.time_24hr = self2.l10n.time_24hr;
    }
    self2.formatDate = createDateFormatter(self2);
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self2.config.position === "function") {
      return void self2.config.position(self2, customPositionElement);
    }
    if (self2.calendarContainer === void 0)
      return;
    triggerEvent("onPreCalendarPosition");
    var positionElement = customPositionElement || self2._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
      return acc + child.offsetHeight;
    }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass$1(self2.calendarContainer, "arrowTop", !showOnTop);
    toggleClass$1(self2.calendarContainer, "arrowBottom", showOnTop);
    if (self2.config.inline)
      return;
    var left = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass$1(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass$1(self2.calendarContainer, "arrowCenter", isCenter);
    toggleClass$1(self2.calendarContainer, "arrowRight", isRight);
    var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right + calendarWidth > window.document.body.offsetWidth;
    toggleClass$1(self2.calendarContainer, "rightMost", rightMost);
    if (self2.config.static)
      return;
    self2.calendarContainer.style.top = top + "px";
    if (!rightMost) {
      self2.calendarContainer.style.left = left + "px";
      self2.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self2.calendarContainer.style.left = "auto";
      self2.calendarContainer.style.right = right + "px";
    } else {
      var doc = getDocumentStyleSheet();
      if (doc === void 0)
        return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass$1(self2.calendarContainer, "rightMost", false);
      toggleClass$1(self2.calendarContainer, "centerMost", true);
      doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self2.calendarContainer.style.left = centerLeft + "px";
      self2.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i = 0; i < document.styleSheets.length; i++) {
      var sheet = document.styleSheets[i];
      if (!sheet.cssRules)
        continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self2.config.noCalendar || self2.isMobile)
      return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self2._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
      setTimeout(self2.close, 0);
    } else {
      self2.close();
    }
  }
  function selectDate(e2) {
    e2.preventDefault();
    e2.stopPropagation();
    var isSelectable = function(day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t2 = findParent(getEventTarget(e2), isSelectable);
    if (t2 === void 0)
      return;
    var target = t2;
    var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
    self2.selectedDateElem = target;
    if (self2.config.mode === "single")
      self2.selectedDates = [selectedDate];
    else if (self2.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex)
        self2.selectedDates.splice(parseInt(selectedIndex), 1);
      else
        self2.selectedDates.push(selectedDate);
    } else if (self2.config.mode === "range") {
      if (self2.selectedDates.length === 2) {
        self2.clear(false, false);
      }
      self2.latestSelectedDateObj = selectedDate;
      self2.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
        self2.selectedDates.sort(function(a, b) {
          return a.getTime() - b.getTime();
        });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self2.currentYear !== selectedDate.getFullYear();
      self2.currentYear = selectedDate.getFullYear();
      self2.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
      focusOnDayElem(target);
    else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
      self2.selectedDateElem && self2.selectedDateElem.focus();
    }
    if (self2.hourElement !== void 0)
      self2.hourElement !== void 0 && self2.hourElement.focus();
    if (self2.config.closeOnSelect) {
      var single = self2.config.mode === "single" && !self2.config.enableTime;
      var range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
      if (single || range) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [
      function() {
        if (self2.config.clickOpens === true) {
          bind2(self2._input, "focus", self2.open);
          bind2(self2._input, "click", self2.open);
        } else {
          self2._input.removeEventListener("focus", self2.open);
          self2._input.removeEventListener("click", self2.open);
        }
      }
    ]
  };
  function set3(option2, value) {
    if (option2 !== null && typeof option2 === "object") {
      Object.assign(self2.config, option2);
      for (var key in option2) {
        if (CALLBACKS[key] !== void 0)
          CALLBACKS[key].forEach(function(x) {
            return x();
          });
      }
    } else {
      self2.config[option2] = value;
      if (CALLBACKS[option2] !== void 0)
        CALLBACKS[option2].forEach(function(x) {
          return x();
        });
      else if (HOOKS.indexOf(option2) > -1)
        self2.config[option2] = arrayify(value);
    }
    self2.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format2) {
    var dates6 = [];
    if (inputDate instanceof Array)
      dates6 = inputDate.map(function(d) {
        return self2.parseDate(d, format2);
      });
    else if (inputDate instanceof Date || typeof inputDate === "number")
      dates6 = [self2.parseDate(inputDate, format2)];
    else if (typeof inputDate === "string") {
      switch (self2.config.mode) {
        case "single":
        case "time":
          dates6 = [self2.parseDate(inputDate, format2)];
          break;
        case "multiple":
          dates6 = inputDate.split(self2.config.conjunction).map(function(date6) {
            return self2.parseDate(date6, format2);
          });
          break;
        case "range":
          dates6 = inputDate.split(self2.l10n.rangeSeparator).map(function(date6) {
            return self2.parseDate(date6, format2);
          });
          break;
      }
    } else
      self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self2.selectedDates = self2.config.allowInvalidPreload ? dates6 : dates6.filter(function(d) {
      return d instanceof Date && isEnabled(d, false);
    });
    if (self2.config.mode === "range")
      self2.selectedDates.sort(function(a, b) {
        return a.getTime() - b.getTime();
      });
  }
  function setDate(date6, triggerChange2, format2) {
    if (triggerChange2 === void 0) {
      triggerChange2 = false;
    }
    if (format2 === void 0) {
      format2 = self2.config.dateFormat;
    }
    if (date6 !== 0 && !date6 || date6 instanceof Array && date6.length === 0)
      return self2.clear(triggerChange2);
    setSelectedDate(date6, format2);
    self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
    self2.redraw();
    jumpToDate(void 0, triggerChange2);
    setHoursFromDate();
    if (self2.selectedDates.length === 0) {
      self2.clear(false);
    }
    updateValue(triggerChange2);
    if (triggerChange2)
      triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function(rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self2.parseDate(rule, void 0, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to)
        return {
          from: self2.parseDate(rule.from, void 0),
          to: self2.parseDate(rule.to, void 0)
        };
      return rule;
    }).filter(function(x) {
      return x;
    });
  }
  function setupDates() {
    self2.selectedDates = [];
    self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
    var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
    if (preloadedDate)
      setSelectedDate(preloadedDate, self2.config.dateFormat);
    self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
    self2.currentYear = self2._initialDate.getFullYear();
    self2.currentMonth = self2._initialDate.getMonth();
    if (self2.selectedDates.length > 0)
      self2.latestSelectedDateObj = self2.selectedDates[0];
    if (self2.config.minTime !== void 0)
      self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
    if (self2.config.maxTime !== void 0)
      self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
    self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
    self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self2.input = getInputElem();
    if (!self2.input) {
      self2.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self2.input._type = self2.input.type;
    self2.input.type = "text";
    self2.input.classList.add("flatpickr-input");
    self2._input = self2.input;
    if (self2.config.altInput) {
      self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
      self2._input = self2.altInput;
      self2.altInput.placeholder = self2.input.placeholder;
      self2.altInput.disabled = self2.input.disabled;
      self2.altInput.required = self2.input.required;
      self2.altInput.tabIndex = self2.input.tabIndex;
      self2.altInput.type = "text";
      self2.input.setAttribute("type", "hidden");
      if (!self2.config.static && self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
    }
    if (!self2.config.allowInput)
      self2._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self2._positionElement = self2.config.positionElement || self2._input;
  }
  function setupMobile() {
    var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
    self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
    self2.mobileInput.tabIndex = 1;
    self2.mobileInput.type = inputType;
    self2.mobileInput.disabled = self2.input.disabled;
    self2.mobileInput.required = self2.input.required;
    self2.mobileInput.placeholder = self2.input.placeholder;
    self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self2.selectedDates.length > 0) {
      self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
    }
    if (self2.config.minDate)
      self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
    if (self2.config.maxDate)
      self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
    if (self2.input.getAttribute("step"))
      self2.mobileInput.step = String(self2.input.getAttribute("step"));
    self2.input.type = "hidden";
    if (self2.altInput !== void 0)
      self2.altInput.type = "hidden";
    try {
      if (self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
    } catch (_a) {
    }
    bind2(self2.mobileInput, "change", function(e2) {
      self2.setDate(getEventTarget(e2).value, false, self2.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle3(e2) {
    if (self2.isOpen === true)
      return self2.close();
    self2.open(e2);
  }
  function triggerEvent(event, data) {
    if (self2.config === void 0)
      return;
    var hooks2 = self2.config[event];
    if (hooks2 !== void 0 && hooks2.length > 0) {
      for (var i = 0; hooks2[i] && i < hooks2.length; i++)
        hooks2[i](self2.selectedDates, self2.input.value, self2, data);
    }
    if (event === "onChange") {
      self2.input.dispatchEvent(createEvent("change"));
      self2.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name2) {
    var e2 = document.createEvent("Event");
    e2.initEvent(name2, true, true);
    return e2;
  }
  function isDateSelected(date6) {
    for (var i = 0; i < self2.selectedDates.length; i++) {
      var selectedDate = self2.selectedDates[i];
      if (selectedDate instanceof Date && compareDates(selectedDate, date6) === 0)
        return "" + i;
    }
    return false;
  }
  function isDateInRange(date6) {
    if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
      return false;
    return compareDates(date6, self2.selectedDates[0]) >= 0 && compareDates(date6, self2.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
      return;
    self2.yearElements.forEach(function(yearElement, i) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i);
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        self2.monthElements[i].textContent = monthToStr(d.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
      } else {
        self2.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
    self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format2 = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
    return self2.selectedDates.map(function(dObj) {
      return self2.formatDate(dObj, format2);
    }).filter(function(d, i, arr) {
      return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d) === i;
    }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
  }
  function updateValue(triggerChange2) {
    if (triggerChange2 === void 0) {
      triggerChange2 = true;
    }
    if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
      self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
    }
    self2.input.value = getDateStr(self2.config.dateFormat);
    if (self2.altInput !== void 0) {
      self2.altInput.value = getDateStr(self2.config.altFormat);
    }
    if (triggerChange2 !== false)
      triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e2) {
    var eventTarget = getEventTarget(e2);
    var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
    var isNextMonth = self2.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self2.changeYear(self2.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self2.changeYear(self2.currentYear - 1);
    }
  }
  function timeWrapper(e2) {
    e2.preventDefault();
    var isKeyDown = e2.type === "keydown", eventTarget = getEventTarget(e2), input = eventTarget;
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
    }
    var min4 = parseFloat(input.getAttribute("min")), max3 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e2.delta || (isKeyDown ? e2.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
      if (newValue < min4) {
        newValue = max3 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
        if (isMinuteElem)
          incrementNumInput(void 0, -1, self2.hourElement);
      } else if (newValue > max3) {
        newValue = input === self2.hourElement ? newValue - max3 - int(!self2.amPM) : min4;
        if (isMinuteElem)
          incrementNumInput(void 0, 1, self2.hourElement);
      }
      if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      input.value = pad(newValue);
    }
  }
  init();
  return self2;
}
function _flatpickr(nodeList, config2) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function(x) {
    return x instanceof HTMLElement;
  });
  var instances = [];
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    try {
      if (node.getAttribute("data-fp-omit") !== null)
        continue;
      if (node._flatpickr !== void 0) {
        node._flatpickr.destroy();
        node._flatpickr = void 0;
      }
      node._flatpickr = FlatpickrInstance(node, config2 || {});
      instances.push(node._flatpickr);
    } catch (e2) {
      console.error(e2);
    }
  }
  return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config2) {
    return _flatpickr(this, config2);
  };
  HTMLElement.prototype.flatpickr = function(config2) {
    return _flatpickr([this], config2);
  };
}
var flatpickr = function(selector, config2) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config2);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config2);
  } else {
    return _flatpickr(selector, config2);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign({}, english),
  default: __assign({}, english)
};
flatpickr.localize = function(l10n) {
  flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function(config2) {
  flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config2);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function(config2) {
    return _flatpickr(this, config2);
  };
}
Date.prototype.fp_incr = function(days2) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days2 === "string" ? parseInt(days2, 10) : days2));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}
var DatepickerWrapper = {
  name: "DatepickerWrapper",
  emits: ["change"],
  props: {
    value: {
      required: true
    },
    options: {
      type: [Object],
      required: true
    },
    id: {
      type: [Number, String],
      required: true
    },
    placeholder: {
      type: [Number, String],
      required: false
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    var {
      id,
      options,
      value
    } = toRefs(props);
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var $this = getCurrentInstance().proxy;
    var datepicker$ = ref(null);
    var input = ref(null);
    var available = computed(() => {
      return el$.value.available;
    });
    var locale2 = computed(() => {
      var _$this$$vueform$i18n$, _$this$$vueform$i18n$2;
      return ((_$this$$vueform$i18n$ = $this.$vueform.i18n.locales[$this.$vueform.i18n.locale]) === null || _$this$$vueform$i18n$ === void 0 || (_$this$$vueform$i18n$ = _$this$$vueform$i18n$.vueform) === null || _$this$$vueform$i18n$ === void 0 ? void 0 : _$this$$vueform$i18n$.datepicker) || ((_$this$$vueform$i18n$2 = $this.$vueform.i18n.locales[$this.$vueform.i18n.fallbackLocale]) === null || _$this$$vueform$i18n$2 === void 0 || (_$this$$vueform$i18n$2 = _$this$$vueform$i18n$2.vueform) === null || _$this$$vueform$i18n$2 === void 0 ? void 0 : _$this$$vueform$i18n$2.datepicker) || {};
    });
    var mode = computed(() => {
      return options.value.mode || "single";
    });
    var config2 = computed(() => {
      var config3 = {};
      each(options.value, (val, option2) => {
        if (val !== null && val !== void 0) {
          config3[option2] = val;
        }
      });
      config3.static = true;
      return config3;
    });
    var update = (val) => {
      context.emit("change", mode.value == "single" ? val[0] || null : val);
    };
    var setDatepickerId = () => {
      datepicker$.value.input.parentElement.id = "datepicker-" + id.value;
    };
    var init = function() {
      var _ref = _asyncToGenerator(function* () {
        if (!input.value) {
          yield nextTick();
        }
        datepicker$.value = flatpickr(input.value, Object.assign({}, config2.value, {
          onChange: (val) => {
            update(val);
          },
          onClose: (val) => {
            val = mode.value == "range" && val.length < 2 ? [] : val;
            update(val);
          },
          // creating a date object from a string date provided in displayFormat (to value)
          parseDate: (dateStr, format2) => {
            return moment_default(dateStr, format2, true).toDate();
          },
          // creating a date string according to displayFormat (to display)
          formatDate: (date6, format2) => {
            return moment_default(date6).format(format2);
          },
          ariaDateFormat: "MMMM D, YYYY",
          disableMobile: true,
          locale: locale2.value
        }));
        if (datepicker$.value.calendarContainer) {
          classes.value.calendarContainer.forEach((c) => {
            datepicker$.value.calendarContainer.classList.add(c);
          });
        }
        setDatepickerId();
        if (value.value !== null) {
          datepicker$.value.setDate(value.value, false);
        }
      });
      return function init2() {
        return _ref.apply(this, arguments);
      };
    }();
    watch(value, (n2, o2) => {
      var _datepicker$$value;
      (_datepicker$$value = datepicker$.value) === null || _datepicker$$value === void 0 || _datepicker$$value.setDate(n2, false);
    });
    watch(id, (n2, o2) => {
      setDatepickerId();
    }, {
      immediate: false
    });
    watch(options, (n2, o2) => {
      if (isEqual_1(n2, o2)) {
        return;
      }
      init();
    }, {
      deep: true
    });
    watch([locale2, available], (n2, o2) => {
      init();
    }, {
      deep: true
    });
    onMounted(() => {
      init();
    });
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      theme,
      classes,
      Templates,
      template,
      datepicker$,
      input,
      config: config2,
      mode,
      locale: locale2,
      update,
      init
    };
  }
};
var EditorWrapper = {
  name: "EditorWrapper",
  emits: ["input", "alert", "error", "blur"],
  props: {
    value: {
      required: false,
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Number],
      default: null
    },
    name: {
      required: false,
      type: [String, Number],
      default: null
    },
    id: {
      required: false,
      type: [String, Number],
      default: null
    },
    accept: {
      required: false,
      type: Array,
      default: () => []
    },
    acceptMimes: {
      required: false,
      type: Array,
      default: () => []
    },
    endpoint: {
      required: false,
      type: [String, Function, Promise],
      default: null
    },
    method: {
      required: false,
      type: String,
      default: "post"
    },
    disabled: {
      required: false,
      type: Boolean,
      default: false
    },
    hideTools: {
      required: false,
      type: [Array],
      default: () => []
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    var {
      value,
      disabled,
      acceptMimes,
      accept,
      endpoint,
      method,
      attrs,
      placeholder,
      id
    } = toRefs(props);
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var editor$ = ref(null);
    var resolvedEndpoint = computed(() => {
      if (endpoint.value) {
        return typeof endpoint.value === "function" ? endpoint.value : form$.value.$vueform.config.endpoints[endpoint.value] || endpoint.value;
      }
      return typeof form$.value.$vueform.config.endpoints.attachment === "function" ? form$.value.$vueform.config.endpoints.attachment : form$.value.$vueform.config.endpoints.attachment.url;
    });
    var resolvedMethod = computed(() => {
      if (typeof resolvedEndpoint.value === "function") {
        return null;
      }
      if (endpoint.value && form$.value.$vueform.config.endpoints[endpoint.value]) {
        return form$.value.$vueform.config.endpoints[endpoint.value];
      }
      return method.value || form$.value.$vueform.config.endpoints.attachment.method;
    });
    var editorComponent = computed(() => {
      return h("trix-editor", _objectSpread2$1(_objectSpread2$1({}, attrs.value), {}, {
        placeholder: placeholder.value,
        disabled: disabled.value,
        id: id.value,
        input: "editor-input-".concat(id.value),
        ref: "editor$"
      }));
    });
    var update = (val) => {
      if (typeof val == "number") {
        val = String(val);
      }
      editor$.value.editor.loadHTML(val);
    };
    var setOption = (key, val) => {
      editor$.value[key] = val;
    };
    var handleChange = () => {
      if (editor$.value.value == value.value || !editor$.value.value && !value.value) {
        return;
      }
      context.emit("input", {
        target: {
          value: editor$.value.value
        }
      });
    };
    var handleFileAccept = (e2) => {
      if (disabled.value) {
        e2.preventDefault();
        return;
      }
      if (!e2.file) {
        e2.preventDefault();
        return;
      }
      if (acceptMimes.value && acceptMimes.value.length && acceptMimes.value.indexOf(e2.file.type) === -1) {
        e2.preventDefault();
        context.emit("alert", form$.value.__(form$.value.translations.vueform.editor.acceptedMimesError, {
          mimes: acceptMimes.value.join(", ")
        }));
      }
      var extension = e2.file.name.split(".").pop();
      if (accept.value && accept.value.length && accept.value.indexOf(extension) === -1) {
        e2.preventDefault();
        context.emit("alert", form$.value.__(form$.value.translations.vueform.editor.acceptedExtensionsError, {
          extensions: accept.value.join(", ")
        }));
      }
    };
    var handleAttachmentAdd = function() {
      var _ref = _asyncToGenerator(function* (e2) {
        if (!e2.attachment.file) {
          return;
        }
        var data = new FormData();
        data.append("Content-Type", e2.attachment.file.type);
        data.append("file", e2.attachment.file);
        var response;
        try {
          if (typeof resolvedEndpoint.value === "function") {
            response = yield resolvedEndpoint.value(e2.attachment, el$.value);
          } else {
            response = yield el$.value.$vueform.services.axios.request({
              url: resolvedEndpoint.value,
              method: resolvedMethod.value,
              [resolvedMethod.value.toLowerCase() === "get" ? "params" : "data"]: data,
              onUploadProgress: (progress) => {
                e2.attachment.setUploadProgress(Math.round(progress.loaded * 100 / progress.total));
              }
            });
            response = response.data;
          }
          e2.attachment.setAttributes({
            url: response.url,
            href: response.href
          });
        } catch (error) {
          context.emit("error", error);
        }
      });
      return function handleAttachmentAdd2(_x) {
        return _ref.apply(this, arguments);
      };
    }();
    var handleBlur = () => {
      context.emit("blur");
    };
    watch(disabled, (val) => {
      editor$.value.contentEditable = !val;
    });
    onMounted(() => {
      if (disabled.value) {
        editor$.value.contentEditable = false;
      }
      editor$.value.addEventListener("trix-change", handleChange);
      editor$.value.addEventListener("trix-blur", handleBlur);
      editor$.value.addEventListener("trix-file-accept", handleFileAccept);
      editor$.value.addEventListener("trix-attachment-add", handleAttachmentAdd);
    });
    onBeforeUnmount(() => {
      var _editor$$value, _editor$$value2, _editor$$value3, _editor$$value4;
      (_editor$$value = editor$.value) === null || _editor$$value === void 0 || _editor$$value.removeEventListener("trix-change", handleChange);
      (_editor$$value2 = editor$.value) === null || _editor$$value2 === void 0 || _editor$$value2.removeEventListener("trix-blur", handleBlur);
      (_editor$$value3 = editor$.value) === null || _editor$$value3 === void 0 || _editor$$value3.removeEventListener("trix-file-accept", handleFileAccept);
      (_editor$$value4 = editor$.value) === null || _editor$$value4 === void 0 || _editor$$value4.removeEventListener("trix-attachment-add", handleAttachmentAdd);
    });
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      resolvedEndpoint,
      editorComponent,
      theme,
      classes,
      Templates,
      template,
      editor$,
      update,
      setOption,
      handleChange,
      handleFileAccept,
      handleAttachmentAdd,
      handleBlur
    };
  }
};
var base$$ = function base14(props, context, dependencies2) {
  var {
    label
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var el$ = dependencies2.el$;
  var config$ = inject("config$");
  var hasLabel = computed(() => {
    var _el$$value$$slots, _el$$value$$scopedSlo;
    return !!(form$.value.options.forceLabels || label.value || el$.value.slots.label || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots.label || /* istanbul ignore next: vue2 */
    form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo.label);
  });
  var isLabelFunction = computed(() => {
    return typeof label.value === "function" && (!label.value.prototype || !label.value.prototype.constructor || label.value.prototype.constructor && label.value.prototype.constructor.name !== "VueComponent");
  });
  var isLabelComponent = computed(() => {
    return isVueComponent(label.value);
  });
  var Label = computed(() => {
    var Label2 = isLabelFunction.value ? label.value(el$.value) : label.value || null;
    if (!isLabelComponent.value) {
      Label2 = localize(Label2, config$.value, form$.value);
    }
    return Label2;
  });
  return {
    hasLabel,
    Label
  };
};
var base$_ = function base15(props, context, dependencies2) {
  var {
    columns,
    presets
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var theme = dependencies2.theme;
  var hasLabel = dependencies2.hasLabel;
  var Columns2 = ref(cloneDeep_1(columns.value));
  var columnsClassesService = computed(() => {
    var config2 = form$.value.$vueform.config;
    return new form$.value.$vueform.services.columns({
      configPresetColumns: config2.usePresets,
      configColumns: config2.columns,
      formPresetColumns: form$.value.options.presets,
      formColumns: form$.value.options.columns,
      elementPresetColumns: presets.value,
      elementColumns: Columns2.value
    }, hasLabel.value, theme.value.columns, config2.presets);
  });
  var columnsClasses = computed(() => {
    return columnsClassesService.value.classes;
  });
  var cols = computed(() => {
    return columnsClassesService.value.cols;
  });
  var updateColumns = (v) => {
    Columns2.value = cloneDeep_1(v);
  };
  watch(columns, (v) => {
    Columns2.value = cloneDeep_1(v);
  }, {
    immediate: false,
    deep: true
  });
  return {
    cols,
    columnsClassesService,
    columnsClasses,
    updateColumns
  };
};
var base$Z = function base16(props, context, dependencies2) {
  var {
    size: size2,
    view,
    views,
    presets
  } = toRefs(props);
  var componentName = context.name;
  var available = dependencies2.available;
  var active = dependencies2.active;
  var form$ = dependencies2.form$;
  var parent2 = dependencies2.parent;
  var hidden = ref(false);
  var visible = computed(() => {
    return available.value && !hidden.value && active.value;
  });
  var Size = computed(() => {
    var Size2;
    if (size2.value) {
      Size2 = size2.value;
    } else {
      each(presets.value, (presetName) => {
        var preset = form$.value.$vueform.config.presets[presetName];
        if (!preset || !preset.size) {
          return;
        }
        Size2 = preset.size;
      });
    }
    if (!Size2) {
      if (parent2.value) {
        Size2 = parent2.value.Size;
      } else {
        Size2 = form$.value.Size;
      }
    }
    return Size2;
  });
  var View = computed(() => {
    if (view.value) {
      return view.value;
    }
    return Views.value[componentName.value];
  });
  var Views = computed(() => {
    var Views2 = form$.value.Views;
    each(presets.value, (presetName) => {
      var preset = form$.value.$vueform.config.presets[presetName];
      if (!preset || !preset.views) {
        return;
      }
      Views2 = Object.assign({}, Views2, preset.views);
    });
    Views2 = Object.assign({}, Views2, views.value);
    return Views2;
  });
  var hide = () => {
    hidden.value = true;
  };
  var show = () => {
    hidden.value = false;
  };
  provide("Size", Size);
  provide("View", View);
  provide("Views", Views);
  return {
    hidden,
    visible,
    Size,
    View,
    Views,
    hide,
    show
  };
};
var captcha$1 = function captcha(props, context, dependencies2) {
  var {
    hidden,
    visible: baseVisible,
    Size,
    View,
    Views,
    hide,
    show
  } = base$Z(props, context, dependencies2);
  var {
    shouldVerify
  } = dependencies2;
  var visible = computed(() => {
    return baseVisible.value && shouldVerify.value;
  });
  return {
    hidden,
    visible,
    Size,
    View,
    Views,
    hide,
    show
  };
};
var base$Y = function base17(props, context, dependencies2) {
  var {
    templates,
    presets
  } = toRefs(props);
  var componentName = context.name;
  var theme = dependencies2.theme;
  var View = dependencies2.View;
  var form$ = dependencies2.form$;
  var Templates = computed(() => {
    var presetTemplates = {};
    each(presets ? presets.value : [], (presetName) => {
      var preset = form$.value.$vueform.config.presets[presetName];
      if (!preset || !preset.templates) {
        return;
      }
      presetTemplates = Object.assign({}, presetTemplates, preset.templates);
    });
    return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, theme.value.templates), presetTemplates), templates ? templates.value : {});
  });
  var template = computed(() => {
    return View && View.value && Templates.value["".concat(componentName.value, "_").concat(View.value)] ? Templates.value["".concat(componentName.value, "_").concat(View.value)] : Templates.value[componentName.value];
  });
  return {
    Templates,
    template
  };
};
var base$X = function base18(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  toRefs(props);
  var el$ = dependencies2.el$;
  var defaultElementSlots = ["label", "info", "description", "before", "between", "after"];
  var defaultFieldSlots = ["checkbox", "radio", "option", "single-label", "multiple-label", "tag", "no-results", "no-options", "after-list", "before-list", "placeholder", "group-label", "caret", "clear", "spinner", "option", "default", "addon-before", "addon-after"];
  var elementSlots = computed(() => {
    var elementSlots2 = {};
    defaultElementSlots.filter((s) => options.slots.indexOf(s) !== -1).forEach((s) => {
      var slot = el$.value.slots[s] || el$.value.slots[camelCase_1(s)];
      if (typeof slot === "object") {
        if (slot.props && (Array.isArray(slot.props) && slot.props.indexOf("el$") === -1 || !Array.isArray(slot.props) && Object.keys(slot.props).indexOf("el$") === -1)) {
          if (Array.isArray(slot.props)) {
            slot.props.push("el$");
          } else {
            slot.props.el$ = {
              type: Object,
              required: true
            };
          }
        } else if (!slot.props) {
          slot.props = ["el$"];
        }
      }
      elementSlots2[s] = slot;
    });
    return elementSlots2;
  });
  var fieldSlots = computed(() => {
    var fieldSlots2 = {};
    defaultFieldSlots.filter((s) => options.slots.indexOf(s) !== -1).forEach((s) => {
      var slot = el$.value.slots[s] || el$.value.slots[camelCase_1(s)];
      if (typeof slot === "object") {
        if (slot.props && (Array.isArray(slot.props) && slot.props.indexOf("el$") === -1 || !Array.isArray(slot.props) && Object.keys(slot.props).indexOf("el$") === -1)) {
          if (Array.isArray(slot.props)) {
            slot.props.push("el$");
          } else {
            slot.props.el$ = {
              type: Object,
              required: true
            };
          }
        } else if (!slot.props) {
          slot.props = ["el$"];
        }
      }
      fieldSlots2[s] = slot;
    });
    return fieldSlots2;
  });
  return {
    elementSlots,
    fieldSlots
  };
};
var base$W = function base19(props, context, dependencies2) {
  var {
    buttonLabel,
    buttonType,
    href,
    target,
    loading,
    onClick,
    resets,
    submits
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var isDisabled = dependencies2.isDisabled;
  var fieldId = dependencies2.fieldId;
  var fire = dependencies2.fire;
  var el$ = dependencies2.el$;
  var isLoading = computed(() => {
    if (typeof loading.value === "function") {
      return loading.value(form$.value, el$.value);
    }
    if (submits.value && (form$.value.submitting || form$.value.preparing || form$.value.isLoading)) {
      return true;
    }
    return loading.value;
  });
  var isButtonLabelComponent = computed(() => {
    return buttonLabel.value !== null && typeof buttonLabel.value === "object";
  });
  var button4 = computed(() => {
    var button5 = {
      id: fieldId.value
    };
    switch (buttonType.value) {
      case "anchor":
        button5.href = href.value;
        button5.target = target.value;
        break;
      case "button":
        button5.disabled = isDisabled.value;
        break;
    }
    if (isLoading.value) {
      button5.tabindex = void 0;
    }
    return button5;
  });
  var handleClick = (e2) => {
    if (buttonType.value === "anchor" && !href.value) {
      e2.preventDefault();
    }
    if (isDisabled.value || isLoading.value) {
      e2.preventDefault();
      return;
    }
    if (resets.value) {
      form$.value.reset();
    }
    if (submits.value) {
      form$.value.submit();
    }
    fire("click", form$.value, el$.value, e2);
  };
  return {
    isButtonLabelComponent,
    button: button4,
    isLoading,
    handleClick
  };
};
var base$V = function base20(props, context, dependencies2) {
  var {
    layout,
    inline
  } = toRefs(props);
  var elementLayout = computed(() => {
    return inline.value || !layout.value ? "ElementLayoutInline" : layout.value;
  });
  return {
    elementLayout
  };
};
var base$U = function base21(props, context, dependencies2) {
  var {
    id,
    name: name2
  } = toRefs(props);
  var parent2 = dependencies2.parent;
  var fieldId = computed(() => {
    var _parent$value, _parent$value2;
    return id.value || ((_parent$value = parent2.value) !== null && _parent$value !== void 0 && _parent$value.fieldId ? "".concat((_parent$value2 = parent2.value) === null || _parent$value2 === void 0 ? void 0 : _parent$value2.fieldId, ".").concat(name2.value) : name2.value);
  });
  return {
    fieldId
  };
};
var base$T = function base22(props, context, dependencies2) {
  var {
    container
  } = dependencies2;
  var focus = () => {
    var _container$value, _el$querySelector;
    var el = ((_container$value = container.value) === null || _container$value === void 0 ? void 0 : _container$value.$el) || container.value;
    el === null || el === void 0 || (_el$querySelector = el.querySelector("a[href],area[href],input:not([disabled]),select:not([disabled]),textarea:not([disabled]),button:not([disabled]),iframe,[tabindex],[contentEditable=true],trix-editor")) === null || _el$querySelector === void 0 || _el$querySelector.focus();
  };
  return {
    focus
  };
};
var editor$1 = function editor(props, context, dependencies2) {
  var {
    input
  } = dependencies2;
  var focus = () => {
    input.value.editor$.focus();
  };
  return {
    focus
  };
};
var baseClone = _baseClone;
var CLONE_SYMBOLS_FLAG = 4;
function clone$12(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}
var clone_1 = clone$12;
var base$S = function base23(props, context, dependencies2) {
  var {
    disabled
  } = toRefs(props);
  var localDisabled = ref(null);
  var isDisabled = computed(() => {
    return disabled.value && localDisabled.value !== false || localDisabled.value === true;
  });
  var disable = () => {
    localDisabled.value = true;
  };
  var enable = () => {
    localDisabled.value = false;
  };
  return {
    localDisabled,
    isDisabled,
    disable,
    enable
  };
};
var checkboxgroup$3 = function checkboxgroup(props, context, dependencies2) {
  var {
    disables
  } = toRefs(props);
  var {
    localDisabled,
    isDisabled
  } = base$S(props);
  var disabledItems = ref([]);
  var disable = (values2) => {
    if (!isArray_1(values2)) {
      values2 = [values2];
    }
    var disablesList = clone_1(disabledItems.value);
    each(values2, (item) => {
      item = String(item);
      if (disablesList.indexOf(item) === -1) {
        disablesList.push(item);
      }
    });
    disabledItems.value = disablesList;
  };
  var enable = (values2) => {
    if (!isArray_1(values2)) {
      values2 = [values2];
    }
    var disablesList = clone_1(disabledItems.value);
    each(values2, (item) => {
      item = String(item);
      var index2 = disablesList.indexOf(item);
      if (index2 !== -1) {
        disablesList.splice(index2, 1);
      }
    });
    disabledItems.value = disablesList;
  };
  var disableAll = () => {
    localDisabled.value = true;
  };
  var enableAll = () => {
    localDisabled.value = false;
    disabledItems.value = [];
  };
  disabledItems.value = map_1(disables.value || /* istanbul ignore next: can't fall into this, because it is hardwired to be `[]` if undefined */
  [], (d) => {
    return String(d);
  });
  return {
    disabledItems,
    isDisabled,
    disableAll,
    enableAll,
    disable,
    enable
  };
};
var button$1 = function button(props, context, dependencies2) {
  var {
    disabled,
    submits
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var el$ = dependencies2.el$;
  var isDisabled = computed(() => {
    if (typeof disabled.value === "function") {
      return disabled.value(el$.value, form$.value);
    }
    if (submits.value && (form$.value.invalid && form$.value.shouldValidateOnChange || form$.value.busy || form$.value.isDisabled)) {
      return true;
    }
    return disabled.value;
  });
  return {
    isDisabled
  };
};
var radiogroup$2 = checkboxgroup$3;
var base$R = function base24(props, context, dependencies2) {
  var fieldId = dependencies2.fieldId;
  var invalid = dependencies2.invalid;
  var isDisabled = dependencies2.isDisabled;
  var busy = dependencies2.busy;
  var labelId = computed(() => {
    return "".concat(fieldId.value, "__label");
  });
  var descriptionId = computed(() => {
    return "".concat(fieldId.value, "__description");
  });
  var infoId = computed(() => {
    return "".concat(fieldId.value, "__info");
  });
  var errorId = computed(() => {
    return "".concat(fieldId.value, "__error");
  });
  var aria = computed(() => {
    return {
      "aria-labelledby": labelId.value,
      "aria-describedby": "".concat(descriptionId.value, " ").concat(infoId.value),
      "aria-invalid": invalid.value,
      "aria-errormessage": errorId.value,
      "aria-disabled": isDisabled === null || isDisabled === void 0 ? void 0 : isDisabled.value,
      "aria-busy": busy.value
    };
  });
  return {
    descriptionId,
    labelId,
    infoId,
    errorId,
    aria
  };
};
var checkbox$1 = function checkbox(props, context, dependencies2) {
  var {
    text: text5
  } = toRefs(props);
  var {
    descriptionId,
    labelId,
    infoId,
    errorId
  } = base$R(props, context, dependencies2);
  var invalid = dependencies2.invalid;
  var isDisabled = dependencies2.isDisabled;
  var busy = dependencies2.busy;
  var aria = computed(() => {
    var aria2 = {
      "aria-label": text5.value,
      "aria-describedby": "".concat(labelId.value, " ").concat(descriptionId.value, " ").concat(infoId.value),
      "aria-invalid": invalid.value,
      "aria-errormessage": errorId.value,
      "aria-disabled": isDisabled.value,
      "aria-busy": busy.value
    };
    if (!aria2["aria-label"]) {
      aria2["aria-labelledby"] = labelId.value;
    }
    return aria2;
  });
  return {
    descriptionId,
    labelId,
    infoId,
    errorId,
    aria
  };
};
var checkboxgroup$2 = function checkboxgroup2(props, context, dependencies2) {
  var {
    descriptionId,
    labelId,
    infoId,
    errorId
  } = base$R(props, context, dependencies2);
  var invalid = dependencies2.invalid;
  var isDisabled = dependencies2.isDisabled;
  var busy = dependencies2.busy;
  var aria = computed(() => {
    return {
      "aria-describedby": "".concat(descriptionId.value, " ").concat(infoId.value),
      "aria-invalid": invalid.value,
      "aria-errormessage": errorId.value,
      "aria-disabled": isDisabled.value,
      "aria-busy": busy.value
    };
  });
  return {
    descriptionId,
    labelId,
    infoId,
    errorId,
    aria
  };
};
var button2 = function button3(props, context, dependencies2) {
  var {
    descriptionId,
    labelId,
    infoId,
    errorId
  } = base$R(props, context, dependencies2);
  var isDisabled = dependencies2.isDisabled;
  var aria = computed(() => {
    return {
      "aria-labelledby": labelId.value,
      "aria-describedby": "".concat(descriptionId.value, " ").concat(infoId.value),
      "aria-disabled": isDisabled.value
    };
  });
  return {
    descriptionId,
    labelId,
    infoId,
    errorId,
    aria
  };
};
var static_$3 = function static_(props, context, dependencies2) {
  var {
    descriptionId,
    labelId,
    infoId,
    errorId
  } = base$R(props, context, dependencies2);
  var aria = computed(() => {
    return {
      "aria-labelledby": labelId.value,
      "aria-describedby": "".concat(descriptionId.value, " ").concat(infoId.value)
    };
  });
  return {
    descriptionId,
    labelId,
    infoId,
    errorId,
    aria
  };
};
var radiogroup$1 = checkboxgroup$2;
var radio = checkbox$1;
var toggle$1 = checkbox$1;
var file$4 = checkboxgroup$2;
var createCaseFirst = _createCaseFirst;
var lowerFirst = createCaseFirst("toLowerCase");
var lowerFirst_1 = lowerFirst;
var base$Q = function base25(props, context, dependencies2) {
  var {
    name: name2
  } = toRefs(props);
  var currentInstance = getCurrentInstance();
  var form$ = dependencies2.form$;
  var assignToParent = ($parent, assignToParent2) => {
    if ($parent.children$Array) {
      $parent.children$Array.push(currentInstance.proxy);
    } else if ($parent.elements$) {
      form$.value.$set($parent.elements$, name2.value, currentInstance.proxy);
    } else {
      assignToParent2($parent.$parent, assignToParent2);
    }
  };
  var removeFromParent = ($parent, removeFromParent2) => {
    if ($parent.children$Array) {
      $parent.children$Array.splice($parent.children$Array.map((e$) => normalize(e$.name)).indexOf(normalize(name2.value)), 1);
    } else if ($parent.elements$) {
      form$.value.$delete($parent.elements$, name2.value);
    } else {
      removeFromParent2($parent.$parent, removeFromParent2);
    }
  };
  return {
    assignToParent,
    removeFromParent
  };
};
var base$P = function base26(props, context, dependencies2) {
  var instantHooks = ["onBeforeCreate", "onCreated"];
  var hooks2 = {
    onBeforeMount,
    onMounted,
    onBeforeUpdate,
    onUpdated,
    onBeforeUnmount,
    onUnmounted
  };
  var currentInstance = getCurrentInstance();
  var form$ = dependencies2.form$;
  var fire = dependencies2.fire;
  var {
    assignToParent,
    removeFromParent
  } = base$Q(props, context, {
    form$
  });
  var container = ref(null);
  var mounted = ref(false);
  var active = ref(true);
  var isStatic = computed(() => {
    return false;
  });
  var isFileType = computed(() => {
    return false;
  });
  var isImageType = computed(() => {
    return false;
  });
  var isArrayType = computed(() => {
    return false;
  });
  var isObjectType = computed(() => {
    return false;
  });
  var isGroupType = computed(() => {
    return false;
  });
  var isListType = computed(() => {
    return false;
  });
  var isActive = computed(() => {
    return active.value;
  });
  var el$ = computed(() => {
    return currentInstance.proxy;
  });
  var activate = () => {
    active.value = true;
  };
  var deactivate = () => {
    active.value = false;
  };
  provide("el$", el$);
  onBeforeMount(() => {
    assignToParent(currentInstance.proxy.$parent, assignToParent);
  });
  onMounted(() => {
    mounted.value = true;
  });
  onBeforeUnmount(() => {
    removeFromParent(currentInstance.proxy.$parent, removeFromParent);
  });
  Object.values(instantHooks).forEach((hook) => {
    fire(lowerFirst_1(hook.replace("on", "")), el$.value);
  });
  Object.keys(hooks2).forEach((hook) => {
    hooks2[hook](() => {
      fire(lowerFirst_1(hook.replace("on", "")), el$.value);
    });
  });
  return {
    el$,
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  };
};
var list$4 = function list2(props, context, dependencies2) {
  var {
    el$,
    isStatic,
    isFileType,
    isImageType,
    isObjectType,
    isGroupType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  } = base$P(props, context, dependencies2);
  var isArrayType = computed(() => {
    return true;
  });
  var isListType = computed(() => {
    return true;
  });
  return {
    el$,
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  };
};
var object$7 = function object(props, context, dependencies2) {
  var {
    el$,
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  } = base$P(props, context, dependencies2);
  var isObjectType = computed(() => {
    return true;
  });
  return {
    el$,
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  };
};
var group$7 = function group(props, context, dependencies2) {
  var {
    el$,
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  } = base$P(props, context, dependencies2);
  var isGroupType = computed(() => {
    return true;
  });
  return {
    el$,
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  };
};
var file$3 = function file(props, context, dependencies2) {
  var {
    view
  } = toRefs(props);
  var {
    el$,
    isStatic,
    isArrayType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  } = base$P(props, context, dependencies2);
  var isFileType = computed(() => {
    return true;
  });
  var isImageType = computed(() => {
    return ["gallery", "image"].indexOf(view.value) !== -1;
  });
  return {
    el$,
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  };
};
var static_$2 = function static_2(props, context, dependencies2) {
  var {
    el$,
    isArrayType,
    isFileType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  } = base$P(props, context, dependencies2);
  var isStatic = computed(() => {
    return true;
  });
  return {
    el$,
    isStatic,
    isFileType,
    isArrayType,
    isImageType,
    isObjectType,
    isGroupType,
    isListType,
    isActive,
    active,
    mounted,
    container,
    activate,
    deactivate
  };
};
var checkboxgroup$1 = list$4;
var dates$5 = list$4;
var multiselect$4 = list$4;
var tags$4 = list$4;
var base$O = function base27(props, context, dependencies2) {
  var {
    name: name2
  } = toRefs(props);
  var currentInstance = getCurrentInstance();
  var {
    form$
  } = dependencies2;
  var parent2 = computed(() => {
    var getParent = (parent3, getParent2) => {
      if (parent3 && (form$.value.$vueform.vueVersion === 3 && parent3.$options.name && parent3.$options.name.match(/^[a-zA-Z\-]*Element$/) || form$.value.$vueform.vueVersion === 2 && parent3.hasOwnProperty("el$") && typeof parent3.el$ !== "function")) {
        return parent3.el$;
      } else if (parent3.$parent) {
        return getParent2(parent3.$parent, getParent2);
      } else {
        return null;
      }
    };
    return getParent(form$.value.$vueform.vueVersion === 3 ? currentInstance.parent.proxy : currentInstance.proxy.$parent, getParent);
  });
  var path = computed(() => {
    return parent2.value && parent2.value.path ? parent2.value.path + "." + name2.value : name2.value;
  });
  var dataPath = computed(() => {
    return parent2.value && parent2.value.dataPath ? parent2.value.dataPath + "." + name2.value : name2.value;
  });
  var flat = computed(() => {
    return false;
  });
  return {
    parent: parent2,
    path,
    dataPath,
    flat
  };
};
var group$6 = function group2(props, context, dependencies2) {
  var {
    path,
    parent: parent2
  } = base$O(props, context, dependencies2);
  var dataPath = computed(() => {
    return parent2.value && parent2.value.dataPath ? parent2.value.dataPath : null;
  });
  var flat = computed(() => {
    return true;
  });
  return {
    path,
    dataPath,
    flat,
    parent: parent2
  };
};
var static_$1 = function static_3(props, context, dependencies2) {
  var {
    path,
    parent: parent2,
    flat
  } = base$O(props, context, dependencies2);
  return {
    path,
    flat,
    parent: parent2
  };
};
function resolveDeps(props, context, options) {
  var deps = options.deps || {};
  options = _objectSpread2$1(_objectSpread2$1({}, options), {}, {
    events: context.emits,
    slots: context.slots
  });
  context.features.forEach((feature) => {
    each(feature(props, context, deps, options), (featureDep, key) => {
      deps[key] = featureDep;
    });
  });
  return deps;
}
var base$N = function base28(props, context) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var deps = resolveDeps(props, context, options);
  onMounted(() => {
    if (deps.initWatcher) {
      deps.initWatcher();
    }
    if (deps.initMessageBag) {
      deps.initMessageBag();
    }
    if (deps.initValidation) {
      deps.initValidation();
    }
  });
  return _objectSpread2$1({}, deps);
};
var static_4 = function static_5(props, context) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var deps = resolveDeps(props, context, options);
  return _objectSpread2$1({}, deps);
};
var multilingual$8 = function multilingual(props, context) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var deps = resolveDeps(props, context, options);
  onMounted(() => {
    deps.initWatcher();
    deps.initState();
    deps.initMessageBag();
    deps.initValidation();
  });
  return _objectSpread2$1({}, deps);
};
var location$3 = function location(props, context) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var {
    displayKey
  } = toRefs(props);
  var deps = resolveDeps(props, context, options);
  onMounted(() => {
    if (deps.value.value[displayKey.value]) {
      deps.input.value.value = deps.value.value[displayKey.value];
    }
  });
  onMounted(() => {
    deps.initWatcher();
    deps.initMessageBag();
    deps.initValidation();
  });
  return _objectSpread2$1({}, deps);
};
var BaseElement = {
  props: {
    name: {
      required: true,
      type: [String, Number]
    },
    conditions: {
      required: false,
      type: [Array],
      default: () => []
    },
    onBeforeCreate: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onCreated: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onBeforeMount: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onMounted: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onBeforeUpdate: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onUpdated: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onBeforeUnmount: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onUnmounted: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  }
};
var HasView = {
  props: {
    inline: {
      required: false,
      type: [Boolean],
      default: false
    },
    layout: {
      required: false,
      type: [String, Object, Boolean],
      default: "ElementLayout",
      private: true
    },
    addClass: {
      required: false,
      type: [Array, Object, String, Function],
      default: null
    },
    removeClass: {
      required: false,
      type: [Array, Object, Function],
      default: null
    },
    replaceClass: {
      required: false,
      type: [Object, Function],
      default: null
    },
    overrideClass: {
      required: false,
      type: [Array, Object, String, Function],
      default: null
    },
    addClasses: {
      required: false,
      type: [Object, Function],
      default: () => ({})
    },
    replaceClasses: {
      required: false,
      type: [Object, Function],
      default: () => ({})
    },
    removeClasses: {
      required: false,
      type: [Object, Function],
      default: () => ({})
    },
    overrideClasses: {
      required: false,
      type: [Object, Function],
      default: () => ({})
    },
    presets: {
      required: false,
      type: [Array],
      default: () => []
    },
    view: {
      required: false,
      type: [String],
      default: void 0
    },
    views: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    size: {
      required: false,
      type: [String],
      default: void 0
    },
    columns: {
      required: false,
      type: [Object, String, Number],
      default: null
    },
    templates: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    description: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    info: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    infoPosition: {
      required: false,
      type: [String],
      default: "right"
    },
    label: {
      required: false,
      type: [String, Object, Function],
      localized: true,
      default: null
    },
    before: {
      required: false,
      type: [Object, String, Number],
      localized: true,
      default: null
    },
    between: {
      required: false,
      type: [Object, String, Number],
      localized: true,
      default: null
    },
    after: {
      required: false,
      type: [Object, String, Number],
      localized: true,
      default: null
    },
    slots: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  }
};
var ButtonElement = {
  name: "ButtonElement",
  mixins: [BaseElement, HasView],
  emits: ["click", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "button",
      private: true
    },
    buttonLabel: {
      required: false,
      type: [String, Object, Function],
      default: null
    },
    buttonType: {
      required: false,
      type: [String],
      default: "button"
      // button|anchor
    },
    buttonClass: {
      required: false,
      type: [String, Array, Object],
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    disabled: {
      required: false,
      type: [Function, Boolean],
      default: false
    },
    loading: {
      required: false,
      type: [Function, Boolean],
      default: false
    },
    href: {
      required: false,
      type: [String],
      default: ""
    },
    target: {
      required: false,
      type: [String],
      default: null
    },
    onClick: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    resets: {
      required: false,
      type: [Boolean],
      default: false
    },
    submits: {
      required: false,
      type: [Boolean],
      default: false
    },
    secondary: {
      required: false,
      type: [Boolean],
      default: false
    },
    danger: {
      required: false,
      type: [Boolean],
      default: false
    },
    full: {
      required: false,
      type: [Boolean],
      default: false
    },
    align: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, static_$1, base$1c, static_$2, button$1, base$14, base$$, base$Z, base$Y, base$U, base$W, base$1a, base$_, base$X, button2, base$T];
    context.slots = ["label", "info", "description", "before", "between", "after", "default"];
    return _objectSpread2$1({}, static_4(props, context));
  }
};
var base$M = function base29(props, context, dependencies2) {
  var input = ref(null);
  return {
    input
  };
};
function checkDateFormat(format2, date6) {
  if (!(date6 instanceof Date) && moment_default(date6, format2).format(format2) !== date6) {
    console.warn('Wrong formatted date. Expected format: "'.concat(format2, '", received: "').concat(date6, '"'));
  }
}
var base$L = function base30(props, context, dependencies2) {
  var _options$value, _options$value2;
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    name: name2,
    type
  } = toRefs(props);
  var parent2 = dependencies2.parent;
  var defaultValue = dependencies2.defaultValue;
  var dataPath = dependencies2.dataPath;
  var form$ = dependencies2.form$;
  dependencies2.isObject;
  dependencies2.isGroup;
  dependencies2.isList;
  var initialValue = ref(void 0);
  if (form$.value.isSync) {
    initialValue.value = get_1(form$.value.model, dataPath.value);
  } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType || parent2.value.isListType)) {
    initialValue.value = parent2.value.value[name2.value];
  }
  var internalValue = ref(defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value));
  var value = computed({
    get: ((_options$value = options.value) === null || _options$value === void 0 ? void 0 : _options$value.get) || function() {
      var value2;
      if (form$.value.isSync) {
        value2 = get_1(form$.value.model, dataPath.value);
      } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType || parent2.value.isListType)) {
        value2 = parent2.value.value[name2.value];
      } else {
        value2 = internalValue.value;
      }
      return value2 !== void 0 ? value2 : (
        /* istanbul ignore next: value is never undefined if default is set */
        defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value)
      );
    },
    set: ((_options$value2 = options.value) === null || _options$value2 === void 0 ? void 0 : _options$value2.set) || function(val) {
      if (form$.value.isSync) {
        form$.value.updateModel(dataPath.value, val);
      } else if (parent2.value && parent2.value.isListType) {
        var newValue = parent2.value.value.map((v, k) => k == name2.value ? val : v);
        parent2.value.update(newValue);
      } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
        parent2.value.value = Object.assign({}, parent2.value.value, {
          [name2.value]: val
        });
      } else {
        internalValue.value = val;
      }
    }
  });
  var model = computed({
    get() {
      return value.value;
    },
    set(val) {
      value.value = val;
    }
  });
  if (options.init === void 0 || options.init !== false) {
    if (initialValue.value === void 0) {
      value.value = defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value);
    }
  }
  var isDefault = computed(() => {
    return isEqual_1(value.value, defaultValue.value);
  });
  watch(type, () => {
    value.value = defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value);
  });
  return {
    initialValue,
    internalValue,
    value,
    model,
    isDefault
  };
};
var list$3 = function list3(props, context, dependencies2) {
  var {
    initialValue,
    internalValue,
    value,
    model,
    isDefault
  } = base$L(props, context, dependencies2, {
    init: false
  });
  return {
    initialValue,
    internalValue,
    value,
    model,
    isDefault
  };
};
var object$6 = function object2(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    initialValue,
    internalValue,
    value,
    isDefault
  } = base$L(props, context, dependencies2, {
    init: false
  });
  var defaultValue = dependencies2.defaultValue;
  if (options.init === void 0 || /* istanbul ignore next: init will always be false */
  options.init !== false) {
    if (initialValue.value === void 0) {
      value.value = defaultValue.value;
    } else {
      value.value = Object.assign({}, defaultValue.value, value.value);
    }
  }
  return {
    internalValue,
    value,
    isDefault
  };
};
var group$5 = function group3(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var parent2 = dependencies2.parent;
  var dataPath = dependencies2.dataPath;
  var defaultValue = dependencies2.defaultValue;
  var children$Array = dependencies2.children$Array;
  var form$ = dependencies2.form$;
  dependencies2.isObject;
  dependencies2.isGroup;
  dependencies2.isList;
  var internalValue = ref(cloneDeep_1(defaultValue.value));
  var value = computed(options.value || {
    get() {
      var value2;
      if (form$.value.isSync) {
        value2 = dataPath.value ? get_1(form$.value.model, dataPath.value) || {} : form$.value.model;
      } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
        value2 = parent2.value.value;
      } else {
        value2 = internalValue.value;
      }
      var childKeys = children$Array.value.reduce((all3, child$) => {
        if (child$.isStatic || !child$) {
          return all3;
        }
        var keys3 = [];
        if (!child$.flat) {
          keys3.push(child$.name);
        } else {
          var addGroupKeys = (children$Array2) => {
            children$Array2.forEach((child$2) => {
              if (!child$2.isStatic && child$2.flat) {
                addGroupKeys(child$2.children$Array);
              } else if (!child$2.isStatic) {
                keys3.push(child$2.name);
              }
            });
          };
          addGroupKeys(child$.children$Array);
        }
        return all3.concat(keys3);
      }, []);
      var tempValue = {};
      childKeys.forEach((key) => {
        if (value2[key] !== void 0) {
          tempValue[key] = value2[key];
        }
      });
      value2 = tempValue;
      return value2 !== void 0 ? value2 : (
        /* istanbul ignore next: will never reach, internalValue is assigned at the beginning */
        cloneDeep_1(defaultValue.value)
      );
    },
    set(val) {
      if (form$.value.isSync) {
        form$.value.updateModel(dataPath.value, val);
      } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
        parent2.value.value = Object.assign({}, parent2.value.value, val);
      } else {
        internalValue.value = val;
      }
    }
  });
  var isDefault = computed(() => {
    return isEqual_1(value.value, defaultValue.value);
  });
  return {
    value,
    isDefault
  };
};
var multilingual$7 = function multilingual2(props, context, dependencies2) {
  var {
    value,
    isDefault
  } = base$L(props, context, dependencies2);
  var language = dependencies2.language;
  var model = computed({
    get() {
      return value.value[language.value];
    },
    set(val) {
      value.value = Object.assign({}, value.value, {
        [language.value]: val
      });
    }
  });
  return {
    value,
    model,
    isDefault
  };
};
var date$3 = function date(props, context, dependencies2) {
  var {
    name: name2
  } = toRefs(props);
  var parent2 = dependencies2.parent;
  var valueDateFormat = dependencies2.valueDateFormat;
  var defaultValue = dependencies2.defaultValue;
  var dataPath = dependencies2.dataPath;
  var form$ = dependencies2.form$;
  dependencies2.isObject;
  dependencies2.isGroup;
  dependencies2.isList;
  var internalValue = ref(defaultValue.value instanceof File ? (
    /* istanbul ignore next: @todo:adam date type will never have file instance default value */
    defaultValue.value
  ) : cloneDeep_1(defaultValue.value));
  var {
    value,
    initialValue,
    isDefault
  } = base$L(props, context, dependencies2, {
    value: {
      get() {
        var value2;
        if (form$.value.isSync) {
          value2 = get_1(form$.value.model, dataPath.value);
        } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType || parent2.value.isListType)) {
          value2 = parent2.value.value[name2.value];
        } else {
          value2 = internalValue.value;
        }
        return value2 !== void 0 ? value2 : (
          /* istanbul ignore next: can not be undefined @todo:adam can not be file */
          defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value)
        );
      },
      set(val) {
        if (!isEmpty_1(val) && !(val instanceof Date) && valueDateFormat.value !== false) {
          checkDateFormat(valueDateFormat.value, val);
        }
        val = val && val instanceof Date && valueDateFormat.value !== false ? moment_default(val).format(valueDateFormat.value) : val;
        if (form$.value.isSync) {
          form$.value.updateModel(dataPath.value, val);
        } else if (parent2.value && parent2.value.isListType) {
          var newValue = parent2.value.value.map((v, k) => k == name2.value ? val : v);
          parent2.value.update(newValue);
        } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
          parent2.value.value = Object.assign({}, parent2.value.value, {
            [name2.value]: val
          });
        } else {
          internalValue.value = val;
        }
      }
    }
  });
  var model = computed(() => {
    return value.value instanceof Date || !value.value ? value.value : moment_default(value.value, valueDateFormat.value).toDate();
  });
  return {
    value,
    model,
    initialValue,
    internalValue,
    isDefault
  };
};
var dates$4 = function dates(props, context, dependencies2) {
  var {
    name: name2
  } = toRefs(props);
  var parent2 = dependencies2.parent;
  var valueDateFormat = dependencies2.valueDateFormat;
  var defaultValue = dependencies2.defaultValue;
  var dataPath = dependencies2.dataPath;
  var form$ = dependencies2.form$;
  dependencies2.isObject;
  dependencies2.isGroup;
  dependencies2.isList;
  var internalValue = ref(defaultValue.value instanceof File ? (
    /* istanbul ignore next: @todo:adam date type will never have file instance default value */
    defaultValue.value
  ) : cloneDeep_1(defaultValue.value));
  var {
    value,
    initialValue,
    isDefault
  } = base$L(props, context, dependencies2, {
    value: {
      get() {
        var value2;
        if (form$.value.isSync) {
          value2 = get_1(form$.value.model, dataPath.value);
        } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType || parent2.value.isListType)) {
          value2 = parent2.value.value[name2.value];
        } else {
          value2 = internalValue.value;
        }
        return value2 !== void 0 ? value2 : (
          /* istanbul ignore next: can not be undefined @todo:adam can not be file */
          defaultValue.value instanceof File ? defaultValue.value : cloneDeep_1(defaultValue.value)
        );
      },
      set(val) {
        if (!Array.isArray(val)) {
          val = [val];
        }
        val = val.map((v) => {
          if (!isEmpty_1(v) && !(v instanceof Date) && valueDateFormat.value !== false) {
            checkDateFormat(valueDateFormat.value, v);
          }
          return v && v instanceof Date && valueDateFormat.value !== false ? moment_default(v).format(valueDateFormat.value) : v;
        });
        if (form$.value.isSync) {
          form$.value.updateModel(dataPath.value, val);
        } else if (parent2.value && parent2.value.isListType) {
          var newValue = parent2.value.value.map((v, k) => k == name2.value ? val : v);
          parent2.value.update(newValue);
        } else if (parent2.value && (parent2.value.isObjectType || parent2.value.isGroupType)) {
          parent2.value.value = Object.assign({}, parent2.value.value, {
            [name2.value]: val
          });
        } else {
          internalValue.value = val;
        }
      }
    }
  });
  var model = computed(() => {
    return value.value.map((v) => {
      return v instanceof Date || !v ? v : moment_default(v, valueDateFormat.value).toDate();
    });
  });
  return {
    value,
    model,
    initialValue,
    internalValue,
    isDefault
  };
};
var base$K = function base31(props, context, dependencies2) {
  var nullValue = computed(() => {
    return null;
  });
  return {
    nullValue
  };
};
var array$1 = function array(props, context, dependencies2) {
  var nullValue = computed(() => {
    return [];
  });
  return {
    nullValue
  };
};
var boolean = function boolean2(props, context, dependencies2) {
  var {
    falseValue
  } = toRefs(props);
  var nullValue = computed(() => {
    return falseValue.value;
  });
  return {
    nullValue
  };
};
var min2 = function min3(props, context, dependencies2) {
  var {
    min: min4,
    default: default_
  } = toRefs(props);
  var nullValue = computed(() => {
    return default_.value !== void 0 && isArray_1(default_.value) ? default_.value.map((v) => min4.value) : min4.value;
  });
  return {
    nullValue
  };
};
var object$5 = function object3(props, context, dependencies2) {
  var nullValue = computed(() => {
    return {};
  });
  return {
    nullValue
  };
};
var location$2 = function location2(props, context, dependencies2) {
  var nullValue = computed(() => {
    return {
      country: null,
      country_code: null,
      state: null,
      state_code: null,
      city: null,
      zip: null,
      address: null,
      formatted_address: null,
      lat: null,
      lng: null
    };
  });
  return {
    nullValue
  };
};
var multilingual$6 = function multilingual3(props, context, dependencies2) {
  var languages = dependencies2.languages;
  var nullValue = computed(() => {
    var value = {};
    each(languages.value, (code) => {
      value[code] = null;
    });
    return value;
  });
  return {
    nullValue
  };
};
var generic = function generic2(props, context, dependencies2) {
  var nullValue = computed(() => {
    return context.nullValue !== void 0 ? context.nullValue : null;
  });
  return {
    nullValue
  };
};
var base$J = function base32(props, context, dependencies2) {
  var {
    name: name2,
    floating,
    placeholder,
    label,
    fieldName
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var Label = dependencies2.Label;
  var config$ = inject("config$");
  var genericName = computed(() => {
    if (fieldName && fieldName.value) {
      return localize(fieldName.value, config$.value, form$.value);
    } else if (label && label.value) {
      return Label.value;
    } else if (floating && floating.value) {
      return localize(floating.value, config$.value, form$.value);
    } else if (placeholder && placeholder.value && form$.value.options.floatPlaceholders) {
      return localize(placeholder.value, config$.value, form$.value);
    } else {
      return upperFirst_1(name2.value).replace(/_|-/g, " ");
    }
  });
  return {
    genericName
  };
};
var file$2 = function file2(props, context, dependencies2) {
  var {
    name: name2,
    embed,
    label,
    fieldName
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var Label = dependencies2.Label;
  var filename = dependencies2.filename || /* istanbul ignore next: failsafe only */
  ref(null);
  var config$ = inject("config$");
  var genericName = computed(() => {
    if (embed.value && filename.value) {
      return filename.value;
    } else if (fieldName && fieldName.value) {
      return localize(fieldName.value, config$.value, form$.value);
    } else if (label.value) {
      return Label.value;
    } else {
      return /^\d+$/.test(name2.value) ? form$.value.translations.vueform.elements.file.defaultName : upperFirst_1(name2.value).replace(/_|-/g, " ");
    }
  });
  return {
    genericName
  };
};
var base$I = function base33(props, context, dependencies2) {
  var value = dependencies2.value;
  var nullValue = dependencies2.nullValue;
  var empty = computed(() => {
    return isEqual_1(value.value, nullValue.value) || [void 0, null, ""].indexOf(value.value) !== -1;
  });
  return {
    empty
  };
};
var multilingual$5 = function multilingual4(props, context, dependencies2) {
  var value = dependencies2.value;
  var nullValue = dependencies2.nullValue;
  var language = dependencies2.language;
  var empty = computed(() => {
    return value.value[language.value] == nullValue.value[language.value] || value.value[language.value] === "";
  });
  return {
    empty
  };
};
var array2 = function array3(props, context, dependencies2) {
  var value = dependencies2.value;
  var nullValue = dependencies2.nullValue;
  var empty = computed(() => {
    return isEqual_1(value.value, nullValue.value) || [void 0, null, ""].indexOf(value.value) !== -1 || value.value.length == 0;
  });
  return {
    empty
  };
};
var base$H = function base34(props, context, dependencies2) {
  var {
    loading
  } = toRefs(props);
  var pending = dependencies2.pending;
  var isLoading = computed(() => {
    return pending.value || loading.value;
  });
  return {
    isLoading
  };
};
var base$G = function base35(props, context, dependencies2) {
  var {
    floating,
    placeholder
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var hasFloating = computed(() => {
    return !!(!!floating.value || placeholder.value && form$.value.options.floatPlaceholders) && floating.value !== false;
  });
  return {
    hasFloating
  };
};
var base$F = function base36(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var el$ = dependencies2.el$;
  var fire = dependencies2.fire;
  var dirt = dependencies2.dirt;
  var validate = dependencies2.validate;
  var value = dependencies2.value;
  var initWatcher = () => {
    watch(value, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      fire("change", n2, o2, el$.value);
      if (dirt) {
        dirt();
      }
      if (validate && form$.value.shouldValidateOnChange) {
        validate();
      }
    }, {
      immediate: false,
      deep: true
    });
  };
  return {
    initWatcher
  };
};
var multilingual$4 = function multilingual5(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var el$ = dependencies2.el$;
  var fire = dependencies2.fire;
  var dirt = dependencies2.dirt;
  var value = dependencies2.value;
  var language = dependencies2.language;
  var validateLanguage = dependencies2.validateLanguage;
  var initWatcher = () => {
    watch(value, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      fire("change", n2, o2, el$.value);
      if (dirt) {
        dirt();
      }
      if (form$.value.shouldValidateOnChange) {
        validateLanguage(language.value);
      }
    }, {
      immediate: false,
      deep: true
    });
  };
  return {
    initWatcher
  };
};
var list$2 = function list4(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var el$ = dependencies2.el$;
  var fire = dependencies2.fire;
  var dirt = dependencies2.dirt;
  var validateValidators = dependencies2.validateValidators;
  var value = dependencies2.value;
  var initWatcher = () => {
    watch(value, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      fire("change", n2, o2, el$.value);
      if (dirt) {
        dirt();
      }
      if (validateValidators && form$.value.shouldValidateOnChange) {
        validateValidators();
      }
    }, {
      immediate: false,
      deep: true
    });
  };
  return {
    initWatcher
  };
};
var object$4 = function object4(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var fire = dependencies2.fire;
  var value = dependencies2.value;
  var el$ = dependencies2.el$;
  var dirt = dependencies2.dirt;
  var validateValidators = dependencies2.validateValidators;
  var initWatcher = () => {
    watch(value, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      fire("change", n2, o2, el$.value);
      if (dirt) {
        dirt();
      }
      if (validateValidators && form$.value.shouldValidateOnChange) {
        validateValidators();
      }
    }, {
      immediate: false,
      deep: true
    });
  };
  return {
    initWatcher
  };
};
var location$1 = function location3(props, context, dependencies2) {
  var {
    displayKey
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var el$ = dependencies2.el$;
  var fire = dependencies2.fire;
  var dirt = dependencies2.dirt;
  var validate = dependencies2.validate;
  var value = dependencies2.value;
  var input = dependencies2.input;
  var initWatcher = () => {
    watch(value, (n2, o2) => {
      if (dataEquals(n2, o2)) {
        return;
      }
      fire("change", n2, o2, el$.value);
      dirt();
      input.value.value = input.value && value.value && value.value[displayKey.value] !== void 0 ? value.value[displayKey.value] : "";
      if (validate && form$.value.shouldValidateOnChange) {
        validate();
      }
    }, {
      immediate: false,
      deep: true
    });
  };
  return {
    initWatcher
  };
};
var multifile$5 = list$2;
var group$4 = object$4;
var base$E = function base37(props, context, dependencies2) {
  var {
    provider: elementProvider,
    options,
    readonly
  } = toRefs(props);
  var {
    form$,
    input,
    model,
    nullValue,
    messageBag: messageBag2,
    validate,
    el$,
    invalid,
    isDisabled,
    resetValidators,
    resetting,
    initValidation
  } = dependencies2;
  var Provider = ref(null);
  var shouldVerify = computed(() => {
    return !isDisabled.value && !readonly.value;
  });
  var provider = computed(() => {
    return elementProvider.value || form$.value.options.useProviders.captcha;
  });
  var captchaOptions = computed(() => {
    return _objectSpread2$1(_objectSpread2$1({}, form$.value.options.providerOptions[provider.value]), options.value);
  });
  var initCaptcha = () => {
    model.value = nullValue.value;
    Provider.value = new form$.value.options.providers.captcha[provider.value](input.value, captchaOptions.value, el$.value);
  };
  var destroyCaptcha = () => {
    resetValidators();
    Provider.value.reset();
    model.value = nullValue.value;
    Provider.value = null;
  };
  onMounted(() => {
    if (shouldVerify.value) {
      initCaptcha();
    }
  });
  watch(shouldVerify, function() {
    var _ref = _asyncToGenerator(function* (n2, o2) {
      if (!n2) {
        destroyCaptcha();
      } else if (n2) {
        yield nextTick();
        initCaptcha();
        initValidation();
      }
    });
    return function(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }());
  return {
    Provider,
    captchaOptions,
    shouldVerify,
    initCaptcha,
    destroyCaptcha
  };
};
var base$D = function base38(props, context, dependencies2) {
  var {
    rules: rules2
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var path = dependencies2.path;
  var state = ref({
    dirty: false,
    validated: true
  });
  var Validators = ref([]);
  var messageBag2 = ref({});
  var validatorFactory = reactive({});
  var resetting = ref(false);
  var validationRules = computed(() => {
    return rules2.value;
  });
  var dirty = computed(() => {
    return state.value.dirty;
  });
  var validated = computed(() => {
    return state.value.validated;
  });
  var invalid = computed(() => {
    return some_1(Validators.value, {
      invalid: true
    });
  });
  var pending = computed(() => {
    return some_1(Validators.value, {
      pending: true
    });
  });
  var busy = computed(() => {
    return pending.value;
  });
  var validatorErrors = computed(() => {
    var errs = [];
    each(Validators.value, (Validator2) => {
      if (Validator2.failing) {
        errs.push(Validator2.message);
      }
    });
    return errs;
  });
  var errors = computed(() => {
    return messageBag2.value.errors;
  });
  var error = computed(() => {
    return messageBag2.value.error || null;
  });
  var isDanger = computed(() => {
    return error.value !== null;
  });
  var isSuccess = computed(() => {
    return validationRules.value && validationRules.value.length > 0 && state.value.validated && !invalid.value || (!validationRules.value || !validationRules.value.length) && dirty.value;
  });
  var validate = function() {
    var _ref = _asyncToGenerator(function* () {
      if (!validationRules.value) {
        return;
      }
      if (form$.value.validation === false) {
        return;
      }
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      yield asyncForEach(Validators.value, function() {
        var _ref2 = _asyncToGenerator(function* (Validator2) {
          yield Validator2.validate();
        });
        return function(_x) {
          return _ref2.apply(this, arguments);
        };
      }());
      state.value.validated = true;
    });
    return function validate2() {
      return _ref.apply(this, arguments);
    };
  }();
  var resetValidators = () => {
    each(Validators.value, (Validator2) => {
      Validator2.reset();
    });
    state.value.validated = !validationRules.value;
  };
  var dirt = () => {
    state.value.dirty = true;
  };
  var clean = () => {
    state.value.dirty = false;
  };
  var clearMessages = () => {
    if (messageBag2.value) {
      messageBag2.value.clear();
    }
  };
  var initMessageBag = () => {
    messageBag2.value = new form$.value.$vueform.services.messageBag(validatorErrors);
  };
  var initValidation = () => {
    if (!validationRules.value) {
      return;
    }
    state.value.validated = false;
    validatorFactory.value = new form$.value.$vueform.services.validation.factory(path.value, form$.value);
    Validators.value = [];
    each(validatorFactory.value.makeAll(validationRules.value), (Validator2) => {
      Validators.value.push(Validator2);
    });
  };
  var reinitValidation = () => {
    initValidation();
  };
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    busy,
    errors,
    error,
    validationRules,
    isDanger,
    isSuccess,
    validate,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var text$2 = function text(props, context, dependencies2) {
  var {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    errors,
    error,
    validationRules,
    isDanger,
    isSuccess,
    validate,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  } = base$D(props, context, dependencies2);
  var debouncing = computed(() => {
    return some_1(Validators.value, {
      debouncing: true
    });
  });
  var busy = computed(() => {
    return pending.value || debouncing.value;
  });
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    debouncing,
    busy,
    errors,
    error,
    validationRules,
    isDanger,
    isSuccess,
    validate,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var list$1 = function list5(props, context, dependencies2) {
  var {
    state,
    Validators,
    messageBag: messageBag2,
    validationRules,
    dirt,
    initValidation,
    resetting
  } = base$D(props, context, dependencies2);
  var form$ = dependencies2.form$;
  var children$ = dependencies2.children$;
  var dirty = computed(() => {
    return some_1(children$.value, {
      available: true,
      dirty: true
    }) || state.value.dirty;
  });
  var validated = computed(() => {
    return !some_1(children$.value, {
      available: true,
      validated: false
    }) && state.value.validated;
  });
  var invalid = computed(() => {
    return some_1(children$.value, {
      available: true,
      invalid: true
    }) || some_1(Validators.value, {
      invalid: true
    });
  });
  var pending = computed(() => {
    return some_1(children$.value, {
      available: true,
      pending: true
    }) || some_1(Validators.value, {
      pending: true
    });
  });
  var debouncing = computed(() => {
    return some_1(children$.value, {
      available: true,
      debouncing: true
    }) || some_1(Validators.value, {
      debouncing: true
    });
  });
  var busy = computed(() => {
    return some_1(children$.value, {
      available: true,
      busy: true
    }) || pending.value || debouncing.value;
  });
  var validatorErrors = computed(() => {
    var validatorErrors2 = [];
    each(Validators.value, (Validator2) => {
      if (Validator2.failing) {
        validatorErrors2.push(Validator2.message);
      }
    });
    return validatorErrors2;
  });
  var childrenErrors = computed(() => {
    var childrenErrors2 = [];
    each(children$.value, (element$) => {
      if (!element$.available || element$.isStatic) {
        return;
      }
      each(element$.errors, (error2) => {
        childrenErrors2.push(error2);
      });
    });
    return childrenErrors2;
  });
  var baseErrors = computed(() => {
    return validatorErrors.value.concat(childrenErrors.value);
  });
  var errors = computed(() => {
    return messageBag2.value.errors;
  });
  var error = computed(() => {
    return head_1(validatorErrors.value);
  });
  var validate = function() {
    var _ref3 = _asyncToGenerator(function* () {
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      yield validateValidators();
      yield validateChildren();
    });
    return function validate2() {
      return _ref3.apply(this, arguments);
    };
  }();
  var validateValidators = function() {
    var _ref4 = _asyncToGenerator(function* () {
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      if (form$.value.validation === false) {
        return;
      }
      yield asyncForEach(Validators.value, function() {
        var _ref5 = _asyncToGenerator(function* (Validator2) {
          yield Validator2.validate();
        });
        return function(_x2) {
          return _ref5.apply(this, arguments);
        };
      }());
      state.value.validated = true;
    });
    return function validateValidators2() {
      return _ref4.apply(this, arguments);
    };
  }();
  var validateChildren = function() {
    var _ref6 = _asyncToGenerator(function* () {
      if (form$.value.validation === false) {
        return;
      }
      yield asyncForEach(children$.value, function() {
        var _ref7 = _asyncToGenerator(function* (element$) {
          if (!element$.isStatic) {
            yield element$.validate();
          }
        });
        return function(_x3) {
          return _ref7.apply(this, arguments);
        };
      }());
    });
    return function validateChildren2() {
      return _ref6.apply(this, arguments);
    };
  }();
  var clean = () => {
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      element$.clean();
    });
    state.value.dirty = false;
  };
  var clearMessages = () => {
    if (messageBag2.value) {
      messageBag2.value.clear();
    }
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      element$.clearMessages();
    });
  };
  var resetValidators = () => {
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      element$.resetValidators();
    });
    each(Validators.value, (Validator2) => {
      Validator2.reset();
    });
    state.value.validated = !validationRules.value;
  };
  var initMessageBag = () => {
    messageBag2.value = new form$.value.$vueform.services.messageBag(baseErrors);
  };
  var reinitValidation = () => {
    initValidation();
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      element$.reinitValidation();
    });
  };
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    debouncing,
    busy,
    validatorErrors,
    childrenErrors,
    errors,
    error,
    validationRules,
    validate,
    validateValidators,
    validateChildren,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var multilingual$3 = function multilingual6(props, context, dependencies2) {
  var {
    rules: rules2
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var path = dependencies2.path;
  var languages = dependencies2.languages;
  var language = dependencies2.language;
  var value = dependencies2.value;
  var {
    messageBag: messageBag2,
    clearMessages,
    resetting
  } = text$2(props, context, dependencies2);
  var state = ref({
    dirty: {},
    validated: {}
  });
  var Validators = ref({});
  var validationRules = computed(() => {
    var ruleList = {};
    if (!rules2.value) {
      return ruleList;
    }
    each(languages.value, (lang2) => {
      ruleList[lang2] = isPlainObject_1(rules2.value) ? rules2.value[lang2] || null : rules2.value;
    });
    return ruleList;
  });
  var dirty = computed(() => {
    return some_1(state.value.dirty, (val) => {
      return val === true;
    });
  });
  var validated = computed(() => {
    return !some_1(state.value.validated, (val) => {
      return val === false;
    });
  });
  var invalid = computed(() => {
    var invalid2 = false;
    each(Validators.value, (Validators2) => {
      if (some_1(Validators2, {
        invalid: true
      })) {
        invalid2 = true;
      }
    });
    return invalid2;
  });
  var pending = computed(() => {
    var pending2 = false;
    each(Validators.value, (Validators2) => {
      if (some_1(Validators2, {
        pending: true
      })) {
        pending2 = true;
      }
    });
    return pending2;
  });
  var debouncing = computed(() => {
    var debouncing2 = false;
    each(Validators.value, (Validators2) => {
      if (some_1(Validators2, {
        debouncing: true
      })) {
        debouncing2 = true;
      }
    });
    return debouncing2;
  });
  var busy = computed(() => {
    return pending.value || debouncing.value;
  });
  var validatorErrors = computed(() => {
    var errors2 = [];
    each(Validators.value, (Validators2, language2) => {
      each(Validators2, (Validator2) => {
        if (Validator2.failing) {
          errors2.push(Validator2.message + " (" + language2 + ")");
        }
      });
    });
    return errors2;
  });
  var errors = computed(() => {
    return messageBag2.value.errors;
  });
  var error = computed(() => {
    var error2 = null;
    each(Validators.value[language.value], (Validator2) => {
      if (error2 !== null) {
        return false;
      }
      if (Validator2.failing) {
        error2 = Validator2.message;
      }
    });
    var errors2 = messageBag2.value.prepends ? messageBag2.value.prepends.errors : [];
    if (error2 !== null) {
      errors2 = concat_1(errors2, [error2]);
    }
    errors2 = concat_1(errors2, messageBag2.value.appends ? messageBag2.value.appends.errors : []);
    return head_1(errors2);
  });
  var isDanger = computed(() => {
    return error.value !== null && error.value !== void 0;
  });
  var isSuccess = computed(() => {
    return validationRules.value[language.value] && validationRules.value[language.value].length > 0 && state.value.validated[language.value] && !some_1(Validators.value[language.value], {
      invalid: true
    }) || (!validationRules.value[language.value] || !validationRules.value[language.value].length) && state.value.dirty[language.value];
  });
  var validate = function() {
    var _ref8 = _asyncToGenerator(function* () {
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      yield asyncForEach(languages.value, function() {
        var _ref9 = _asyncToGenerator(function* (lang2) {
          yield validateLanguage(lang2);
        });
        return function(_x4) {
          return _ref9.apply(this, arguments);
        };
      }());
    });
    return function validate2() {
      return _ref8.apply(this, arguments);
    };
  }();
  var validateLanguage = function() {
    var _ref10 = _asyncToGenerator(function* () {
      var lang2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : language.value;
      if (form$.value.validation === false) {
        return;
      }
      if (!Validators.value[lang2]) {
        return;
      }
      yield asyncForEach(Validators.value[lang2], function() {
        var _ref11 = _asyncToGenerator(function* (Validator2) {
          yield Validator2.validate(value.value[lang2]);
        });
        return function(_x5) {
          return _ref11.apply(this, arguments);
        };
      }());
      state.value.validated[lang2] = true;
    });
    return function validateLanguage2() {
      return _ref10.apply(this, arguments);
    };
  }();
  var resetValidators = () => {
    each(languages.value, (lang2) => {
      each(Validators.value[lang2], (Validator2) => {
        Validator2.reset();
      });
      each(validationRules.value, (r2, lang3) => {
        state.value.validated[lang3] = r2.length > 0 ? false : true;
      });
    });
  };
  var dirt = () => {
    state.value.dirty[language.value] = true;
  };
  var clean = () => {
    state.value.dirty[language.value] = false;
  };
  var initState = () => {
    var dirty2 = {};
    var validated2 = {};
    each(languages.value, (lang2) => {
      dirty2[lang2] = false;
    });
    each(languages.value, (lang2) => {
      validated2[lang2] = true;
    });
    state.value = {
      dirty: dirty2,
      validated: validated2
    };
  };
  var initMessageBag = () => {
    messageBag2.value = new form$.value.$vueform.services.messageBag(validatorErrors);
  };
  var initValidation = () => {
    if (!validationRules.value) {
      return;
    }
    each(validationRules.value, (r2, lang2) => {
      state.value.validated[lang2] = r2 !== null && r2.length > 0 ? false : true;
    });
    var factory = new form$.value.$vueform.services.validation.factory(path.value, form$.value);
    Validators.value = {};
    each(validationRules.value, (languageRules, lang2) => {
      if (languageRules === null) {
        return;
      }
      if (!Validators.value[lang2]) {
        Validators.value = Object.assign({}, Validators.value, {
          [lang2]: []
        });
      }
      each(factory.makeAll(languageRules), (Validator2) => {
        Validators.value[lang2].push(Validator2);
      });
    });
  };
  var reinitValidation = () => {
    initValidation();
  };
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    debouncing,
    busy,
    errors,
    error,
    validationRules,
    isDanger,
    isSuccess,
    validate,
    validateLanguage,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initState,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var slider$1 = function slider(props, context, dependencies2) {
  var value = dependencies2.value;
  var {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    busy,
    errors,
    error,
    validationRules,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  } = base$D(props, context, dependencies2);
  var validate = function() {
    var _ref12 = _asyncToGenerator(function* () {
      if (!validationRules.value) {
        return;
      }
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      if (isArray_1(value.value)) {
        yield asyncForEach(value.value, function() {
          var _ref13 = _asyncToGenerator(function* (val) {
            yield asyncForEach(Validators.value, function() {
              var _ref14 = _asyncToGenerator(function* (Validator2) {
                yield Validator2.validate(val);
              });
              return function(_x7) {
                return _ref14.apply(this, arguments);
              };
            }());
            if (invalid.value) {
              return false;
            }
          });
          return function(_x6) {
            return _ref13.apply(this, arguments);
          };
        }());
      } else {
        yield asyncForEach(Validators.value, function() {
          var _ref15 = _asyncToGenerator(function* (Validator2) {
            yield Validator2.validate(value.value);
          });
          return function(_x8) {
            return _ref15.apply(this, arguments);
          };
        }());
      }
      state.value.validated = true;
    });
    return function validate2() {
      return _ref12.apply(this, arguments);
    };
  }();
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    busy,
    errors,
    error,
    validationRules,
    validate,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var file$1 = function file3(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var uploading = dependencies2.uploading;
  var removing = dependencies2.removing;
  var {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    errors,
    error,
    validationRules,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  } = base$D(props, context, dependencies2);
  var busy = computed(() => {
    return pending.value || uploading.value || removing.value;
  });
  var validate = function() {
    var _ref16 = _asyncToGenerator(function* () {
      if (!validationRules.value) {
        return;
      }
      if (form$.value.validation === false) {
        return;
      }
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      var restricted = ["min", "max", "between", "size", "mimetypes", "mimes", "dimensions", "file", "image", "gt", "gte", "lt", "lte"];
      yield asyncForEach(Validators.value, function() {
        var _ref17 = _asyncToGenerator(function* (Validator2) {
          if (!(value.value instanceof File) && !!value.value && restricted.indexOf(Validator2.name) !== -1) {
            return;
          }
          yield Validator2.validate();
        });
        return function(_x9) {
          return _ref17.apply(this, arguments);
        };
      }());
      state.value.validated = true;
    });
    return function validate2() {
      return _ref16.apply(this, arguments);
    };
  }();
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    busy,
    errors,
    error,
    validationRules,
    validate,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var location4 = function location5(props, context, dependencies2) {
  var {
    displayKey
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    debouncing,
    busy,
    errors,
    error,
    validationRules,
    isSuccess,
    isDanger,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  } = text$2(props, context, dependencies2);
  var validate = function() {
    var _ref18 = _asyncToGenerator(function* () {
      if (!validationRules.value) {
        return;
      }
      if (form$.value.validation === false) {
        return;
      }
      if (resetting.value) {
        resetting.value = false;
        return;
      }
      yield asyncForEach(Validators.value, function() {
        var _ref19 = _asyncToGenerator(function* (Validator2) {
          yield Validator2.validate(value.value[displayKey.value]);
        });
        return function(_x10) {
          return _ref19.apply(this, arguments);
        };
      }());
      state.value.validated = true;
    });
    return function validate2() {
      return _ref18.apply(this, arguments);
    };
  }();
  return {
    state,
    Validators,
    messageBag: messageBag2,
    resetting,
    dirty,
    validated,
    invalid,
    pending,
    debouncing,
    busy,
    errors,
    error,
    validationRules,
    isSuccess,
    isDanger,
    validate,
    dirt,
    clean,
    clearMessages,
    resetValidators,
    initMessageBag,
    initValidation,
    reinitValidation
  };
};
var group$3 = list$1;
var object$3 = list$1;
var base$C = function base39(props, context, dependencies2) {
  var {
    default: default_,
    name: name2
  } = toRefs(props);
  var nullValue = dependencies2.nullValue;
  var form$ = dependencies2.form$;
  var parent2 = dependencies2.parent;
  var defaultValue = computed(() => {
    var parentDefaultValue;
    if (parent2 && parent2.value && !parent2.value.mounted) {
      parentDefaultValue = parent2.value.defaultValue[name2.value];
    } else if (!form$.value.mounted && form$.value.options.default[name2.value] !== void 0) {
      parentDefaultValue = form$.value.options.default[name2.value];
    }
    if (parentDefaultValue !== void 0) {
      return parentDefaultValue instanceof File ? new File([parentDefaultValue], parentDefaultValue.name, parentDefaultValue) : cloneDeep_1(parentDefaultValue);
    }
    if (default_.value !== void 0) {
      return default_.value instanceof File ? new File([default_.value], default_.value.name, default_.value) : cloneDeep_1(default_.value);
    }
    return cloneDeep_1(nullValue.value);
  });
  return {
    defaultValue
  };
};
var text$1 = function text2(props, context, dependencies2) {
  var {
    default: default_,
    name: name2
  } = toRefs(props);
  var nullValue = dependencies2.nullValue;
  var form$ = dependencies2.form$;
  var parent2 = dependencies2.parent;
  var config$ = inject("config$");
  var defaultValue = computed(() => {
    var parentDefaultValue;
    if (parent2 && parent2.value && !parent2.value.mounted) {
      parentDefaultValue = parent2.value.defaultValue[name2.value];
    } else if (!form$.value.mounted && typeof form$.value.options.default[name2.value] !== void 0) {
      parentDefaultValue = form$.value.options.default[name2.value];
    }
    if (parentDefaultValue !== void 0) {
      return parentDefaultValue instanceof File ? new File([parentDefaultValue], parentDefaultValue.name, parentDefaultValue) : isPlainObject_1(parentDefaultValue) ? localize(cloneDeep_1(parentDefaultValue), config$.value, form$.value) : cloneDeep_1(parentDefaultValue);
    }
    if (default_.value !== void 0) {
      return default_.value instanceof File ? new File([default_.value], default_.value.name, default_.value) : isPlainObject_1(default_.value) ? localize(cloneDeep_1(default_.value), config$.value, form$.value) : cloneDeep_1(default_.value);
    }
    return cloneDeep_1(nullValue.value);
  });
  return {
    defaultValue
  };
};
var object$2 = function object5(props, context, dependencies2) {
  var {
    default: default_,
    name: name2
  } = toRefs(props);
  var nullValue = dependencies2.nullValue;
  var form$ = dependencies2.form$;
  var parent2 = dependencies2.parent;
  var defaultValue = computed(() => {
    var parentDefaultValue;
    if (parent2 && parent2.value && !parent2.value.mounted) {
      parentDefaultValue = parent2.value.defaultValue[name2.value];
    } else if (!form$.value.mounted && form$.value.options.default[name2.value]) {
      parentDefaultValue = form$.value.options.default[name2.value];
    }
    if (parentDefaultValue !== void 0) {
      return cloneDeep_1(merge_1({}, default_.value || /* istanbul ignore next: `default_.value` will never be undefined, because it is a hardwired `{}` */
      nullValue.value, parentDefaultValue));
    }
    if (Object.keys(default_.value).length > 0) {
      return cloneDeep_1(default_.value);
    }
    return cloneDeep_1(nullValue.value);
  });
  return {
    defaultValue
  };
};
var group$2 = function group4(props, context, dependencies2) {
  var {
    default: default_
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var parent2 = dependencies2.parent;
  var defaultValue = computed(() => {
    var parentDefaultValue = {};
    if (parent2 && parent2.value && !parent2.value.mounted) {
      parentDefaultValue = parent2.value.defaultValue;
    } else if (!form$.value.mounted && form$.value.options.default) {
      parentDefaultValue = form$.value.options.default;
    }
    return cloneDeep_1(merge_1({}, default_.value, parentDefaultValue));
  });
  return {
    defaultValue
  };
};
var multilingual$2 = function multilingual7(props, context, dependencies2) {
  var {
    default: default_,
    name: name2
  } = toRefs(props);
  var nullValue = dependencies2.nullValue;
  var form$ = dependencies2.form$;
  var parent2 = dependencies2.parent;
  var defaultValue = computed(() => {
    var parentDefaultValue;
    if (parent2 && parent2.value && !parent2.value.mounted) {
      parentDefaultValue = parent2.value.defaultValue[name2.value];
    } else if (!form$.value.mounted && form$.value.options.default[name2.value]) {
      parentDefaultValue = form$.value.options.default[name2.value];
    }
    if (parentDefaultValue !== void 0) {
      return cloneDeep_1(Object.assign({}, clone_1(nullValue.value), parentDefaultValue));
    }
    if (default_.value === void 0) {
      return clone_1(nullValue.value);
    }
    var def = clone_1(default_.value);
    if (!isPlainObject_1(def)) {
      var tempDefault = {};
      each(nullValue.value, (v, language) => {
        tempDefault[language] = def;
      });
      def = tempDefault;
    }
    return Object.assign({}, clone_1(nullValue.value), def);
  });
  return {
    defaultValue
  };
};
function baseSortBy$1(array4, comparer) {
  var length = array4.length;
  array4.sort(comparer);
  while (length--) {
    array4[length] = array4[length].value;
  }
  return array4;
}
var _baseSortBy = baseSortBy$1;
var isSymbol = isSymbol_1;
function compareAscending$1(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var _compareAscending = compareAscending$1;
var compareAscending = _compareAscending;
function compareMultiple$1(object9, other, orders) {
  var index2 = -1, objCriteria = object9.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index2 < length) {
    var result = compareAscending(objCriteria[index2], othCriteria[index2]);
    if (result) {
      if (index2 >= ordersLength) {
        return result;
      }
      var order = orders[index2];
      return result * (order == "desc" ? -1 : 1);
    }
  }
  return object9.index - other.index;
}
var _compareMultiple = compareMultiple$1;
var arrayMap = _arrayMap;
var baseGet = _baseGet;
var baseIteratee = _baseIteratee;
var baseMap = _baseMap;
var baseSortBy = _baseSortBy;
var baseUnary = _baseUnary;
var compareMultiple = _compareMultiple;
var identity = identity_1;
var isArray3 = isArray_1;
function baseOrderBy$1(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray3(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }
      return iteratee;
    });
  } else {
    iteratees = [identity];
  }
  var index2 = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
  var result = baseMap(collection, function(value, key, collection2) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { "criteria": criteria, "index": ++index2, "value": value };
  });
  return baseSortBy(result, function(object9, other) {
    return compareMultiple(object9, other, orders);
  });
}
var _baseOrderBy = baseOrderBy$1;
var baseFlatten = _baseFlatten;
var baseOrderBy = _baseOrderBy;
var baseRest = _baseRest;
var isIterateeCall = _isIterateeCall;
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});
var sortBy_1 = sortBy;
var base$B = function base40(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    submit,
    formatData,
    formatLoad,
    name: name2
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var available = dependencies2.available;
  var value = dependencies2.value;
  var resetValidators = dependencies2.resetValidators;
  var defaultValue = dependencies2.defaultValue;
  var nullValue = dependencies2.nullValue;
  var resetting = dependencies2.resetting;
  var isDefault = dependencies2.isDefault;
  var setValue = (val) => {
    if (options.setValue) {
      return options.setValue(val);
    }
    value.value = val;
  };
  var data = computed(() => {
    return {
      [name2.value]: value.value
    };
  });
  var requestData = computed(() => {
    if (!available.value || !submit.value) {
      return {};
    }
    return formatData.value ? formatData.value(name2.value, value.value, form$.value) : {
      [name2.value]: value.value
    };
  });
  var load = function load2(val) {
    var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    setValue(format2 && formatLoad.value ? formatLoad.value(val, form$.value) : val);
  };
  var update = (val) => {
    setValue(val);
  };
  var clear = () => {
    setValue(cloneDeep_1(nullValue.value));
  };
  var reset = () => {
    if (!isDefault.value) {
      resetting.value = true;
    }
    setValue(cloneDeep_1(defaultValue.value));
    resetValidators();
  };
  var prepare = function() {
    var _ref = _asyncToGenerator(function* () {
    });
    return function prepare2() {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var text3 = function text4(props, context, dependencies2) {
  var {
    submit,
    formatData,
    name: name2,
    forceNumbers
  } = toRefs(props);
  var {
    load,
    update,
    clear,
    reset,
    prepare
  } = base$B(props, context, dependencies2);
  var form$ = dependencies2.form$;
  var available = dependencies2.available;
  var value = dependencies2.value;
  var config$ = inject("config$");
  var data = computed(() => {
    var v = value.value;
    if (shouldForceNumbers()) {
      v = stringToNumber(value.value);
    }
    return {
      [name2.value]: v
    };
  });
  var requestData = computed(() => {
    if (!available.value || !submit.value) {
      return {};
    }
    var v = value.value;
    if (shouldForceNumbers()) {
      v = stringToNumber(value.value);
    }
    return formatData.value ? formatData.value(name2.value, v, form$.value) : {
      [name2.value]: v
    };
  });
  var shouldForceNumbers = () => {
    return forceNumbers.value || config$.value.config.forceNumbers && form$.value.options.forceNumbers !== false && forceNumbers.value !== false || form$.value.options.forceNumbers && forceNumbers.value !== false;
  };
  var stringToNumber = (str) => {
    var v = str;
    if (typeof str === "string") {
      if (/^[-]?\d+([\.,]\d+)?$/.test(str)) {
        v = parseFloat(str.replace(",", "."));
      } else if (/^[-]?\d+$/.test(str)) {
        v = parseInt(str, 10);
      }
    }
    return v;
  };
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var select$3 = function select(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    resolveOnLoad,
    items
  } = toRefs(props);
  var {
    data,
    requestData,
    load,
    update,
    clear,
    prepare
  } = base$B(props, context, dependencies2);
  var value = dependencies2.value;
  var resetValidators = dependencies2.resetValidators;
  var defaultValue = dependencies2.defaultValue;
  var updateItems = dependencies2.updateItems;
  var resetting = dependencies2.resetting;
  var isDefault = dependencies2.isDefault;
  var setValue = (val) => {
    if (options.setValue) {
      return options.setValue(val);
    }
    value.value = val;
  };
  var reset = () => {
    if (!isDefault.value) {
      resetting.value = true;
    }
    setValue(cloneDeep_1(defaultValue.value));
    resetValidators();
    if (typeof items.value === "string" && resolveOnLoad.value !== false) {
      updateItems();
    }
  };
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var captcha2 = function captcha3(props, context, dependencies2) {
  var {
    data,
    requestData,
    load,
    update,
    clear: clearBase,
    reset: resetBase,
    prepare
  } = base$B(props, context, dependencies2);
  var {
    Provider
  } = dependencies2;
  var clear = () => {
    clearBase();
    if (!Provider.value) {
      return;
    }
    Provider.value.reset();
  };
  var reset = () => {
    resetBase();
    if (!Provider.value) {
      return;
    }
    Provider.value.reset();
  };
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var object$1 = function object6(props, context, dependencies2) {
  var {
    name: name2,
    formatLoad,
    formatData,
    submit
  } = toRefs(props);
  var {
    data
  } = base$B(props, context, dependencies2);
  var form$ = dependencies2.form$;
  var available = dependencies2.available;
  var children$ = dependencies2.children$;
  var children$Array = dependencies2.children$Array;
  var resetting = dependencies2.resetting;
  var isDefault = dependencies2.isDefault;
  var requestData = computed(() => {
    if (!available.value || !submit.value) {
      return {};
    }
    var requestData2 = {};
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      requestData2 = Object.assign({}, requestData2, element$.requestData);
    });
    return formatData.value ? formatData.value(name2.value, requestData2, form$.value) : {
      [name2.value]: requestData2
    };
  });
  var load = function load2(val) {
    var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var formatted = format2 && formatLoad.value ? formatLoad.value(val, form$.value) : val;
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      if (!element$.flat && formatted[element$.name] === void 0) {
        element$.clear();
        return;
      }
      element$.load(element$.flat ? formatted : formatted[element$.name], format2);
    });
  };
  var update = (val) => {
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      if (val[element$.name] === void 0 && !element$.flat) {
        return;
      }
      element$.update(element$.flat ? val : val[element$.name]);
    });
  };
  var clear = () => {
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      element$.clear();
    });
  };
  var reset = () => {
    if (!isDefault.value) {
      resetting.value = true;
    }
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      element$.reset();
    });
  };
  var prepare = function() {
    var _ref2 = _asyncToGenerator(function* () {
      yield asyncForEach(children$Array.value, function() {
        var _ref3 = _asyncToGenerator(function* (e$) {
          if (e$.prepare) {
            yield e$.prepare();
          }
        });
        return function(_x) {
          return _ref3.apply(this, arguments);
        };
      }());
    });
    return function prepare2() {
      return _ref2.apply(this, arguments);
    };
  }();
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var group$1 = function group5(props, context, dependencies2) {
  var {
    name: name2,
    formatData,
    submit
  } = toRefs(props);
  var {
    load,
    update,
    clear,
    reset,
    prepare
  } = object$1(props, context, dependencies2);
  var form$ = dependencies2.form$;
  var children$ = dependencies2.children$;
  var available = dependencies2.available;
  var value = dependencies2.value;
  var data = computed(() => {
    return value.value;
  });
  var requestData = computed(() => {
    if (!available.value || !submit.value) {
      return {};
    }
    var requestData2 = {};
    each(children$.value, (element$) => {
      if (element$.isStatic) {
        return;
      }
      requestData2 = Object.assign({}, requestData2, element$.requestData);
    });
    return formatData.value ? formatData.value(name2.value, requestData2, form$.value) : requestData2;
  });
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var list6 = function list7(props, context, dependencies2, options) {
  var {
    name: name2,
    storeOrder,
    formatLoad,
    formatData,
    order,
    submit,
    initial,
    default: default_
  } = toRefs(props);
  var {
    update,
    clear,
    data
  } = base$B(props, context, dependencies2);
  var form$ = dependencies2.form$;
  var children$ = dependencies2.children$;
  var children$Array = dependencies2.children$Array;
  var available = dependencies2.available;
  var isDisabled = dependencies2.isDisabled;
  var value = dependencies2.value;
  var orderByName = dependencies2.orderByName;
  var refreshOrderStore = dependencies2.refreshOrderStore;
  var dataPath = dependencies2.dataPath;
  var parent2 = dependencies2.parent;
  var nullValue = dependencies2.nullValue;
  var defaultValue = dependencies2.defaultValue;
  var fire = dependencies2.fire;
  var resetValidators = dependencies2.resetValidators;
  var resetting = dependencies2.resetting;
  var isDefault = dependencies2.isDefault;
  var initialValue = ref(get_1(form$.value.model, dataPath.value));
  var parentDefaultValue = computed(() => {
    return parent2 && parent2.value ? parent2.value.defaultValue[name2.value] : form$.value.options.default[name2.value];
  });
  var requestData = computed(() => {
    if (!available.value || !submit.value) {
      return {};
    }
    var requestData2 = [];
    each(children$.value, (element$) => {
      var val = element$.requestData[element$.name];
      if (val !== void 0) {
        requestData2.push(val);
      }
    });
    return formatData.value ? formatData.value(name2.value, requestData2, form$.value) : {
      [name2.value]: requestData2
    };
  });
  var length = computed(() => {
    return Object.keys(value.value || /* istanbul ignore next: failsafe only */
    {}).length;
  });
  var add2 = function add3() {
    var val = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
    var focus = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var newValue = storeOrder.value ? Object.assign({}, val || {}, {
      [storeOrder.value]: val ? val[storeOrder.value] : void 0
    }) : val;
    value.value = refreshOrderStore(value.value.concat([newValue]));
    var index2 = value.value.length - 1;
    fire("add", index2, newValue, value.value);
    if (focus) {
      nextTick(() => {
        children$Array.value[children$Array.value.length - 1].focus();
      });
    }
    return index2;
  };
  var remove = (index2) => {
    value.value = value.value.filter((v, i2) => i2 !== index2);
    refreshOrderStore(value.value);
    fire("remove", index2, value.value);
  };
  var load = function() {
    var _ref4 = _asyncToGenerator(function* (val) {
      var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var values2 = sortValue(format2 && formatLoad.value ? formatLoad.value(val, form$.value) : val);
      clear();
      yield nextTick();
      for (var i2 = 0; i2 < values2.length; i2++) {
        add2();
      }
      yield nextTick();
      each(children$.value, (child$, i3) => {
        child$.load(values2[i3], format2);
      });
    });
    return function load2(_x2) {
      return _ref4.apply(this, arguments);
    };
  }();
  var reset = () => {
    if (!isDefault.value) {
      resetting.value = true;
    }
    value.value = cloneDeep_1(defaultValue.value);
    resetValidators();
    if (!value.value.length && initial.value > 0) {
      for (var i2 = 0; i2 < initial.value; i2++) {
        add2();
      }
      children$Array.value.forEach((child$) => {
        child$.reset();
      });
    }
    nextTick(() => {
      refreshOrderStore(value.value);
    });
  };
  var prepare = function() {
    var _ref5 = _asyncToGenerator(function* () {
      yield asyncForEach(children$Array.value, function() {
        var _ref6 = _asyncToGenerator(function* (e$) {
          if (e$.prepare) {
            yield e$.prepare();
          }
        });
        return function(_x3) {
          return _ref6.apply(this, arguments);
        };
      }());
    });
    return function prepare2() {
      return _ref5.apply(this, arguments);
    };
  }();
  var sortValue = (val) => {
    if (!order.value && !orderByName.value || !val) {
      return val;
    }
    var desc = order.value && typeof order.value === "string" && order.value.toUpperCase() == "DESC";
    if (orderByName.value) {
      val = desc ? sortBy_1(val, orderByName.value).reverse() : sortBy_1(val, orderByName.value);
    } else if (order.value) {
      val = desc ? val.sort().reverse() : val.sort();
    }
    return val;
  };
  var handleAdd = () => {
    if (isDisabled.value) {
      return;
    }
    add2(void 0, true);
  };
  var handleRemove = (index2) => {
    if (isDisabled.value) {
      return;
    }
    remove(index2);
  };
  if (initialValue.value === void 0 && parentDefaultValue.value === void 0 && default_.value === void 0) {
    if (initial.value > 0) {
      for (var i = 0; i < initial.value; i++) {
        add2();
      }
    } else {
      value.value = nullValue.value;
    }
  } else if (initialValue.value === void 0) {
    value.value = defaultValue.value;
  }
  return {
    requestData,
    data,
    length,
    add: add2,
    remove,
    load,
    update,
    clear,
    reset,
    handleAdd,
    handleRemove,
    prepare
  };
};
var date$2 = function date2(props, context, dependencies2) {
  var {
    formatLoad
  } = toRefs(props);
  var {
    data,
    requestData,
    update,
    clear,
    reset,
    prepare
  } = base$B(props, context, dependencies2);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var loadDateFormat = dependencies2.loadDateFormat;
  var load = function load2(val) {
    var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var formatted = format2 && formatLoad.value ? formatLoad.value(val, form$.value) : val;
    checkDateFormat(loadDateFormat.value, formatted);
    value.value = formatted instanceof Date || !formatted ? formatted : moment_default(formatted, loadDateFormat.value).toDate();
  };
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var dates$3 = function dates2(props, context, dependencies2) {
  var {
    formatLoad
  } = toRefs(props);
  var {
    data,
    requestData,
    update,
    clear,
    reset,
    prepare
  } = base$B(props, context, dependencies2);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var loadDateFormat = dependencies2.loadDateFormat;
  var load = function load2(val) {
    var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var formatted = format2 && formatLoad.value ? formatLoad.value(val, form$.value) : val;
    value.value = map_1(formatted, (v) => {
      checkDateFormat(loadDateFormat.value, v);
      return v instanceof Date ? v : moment_default(v, loadDateFormat.value).toDate();
    });
  };
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var multilingual$1 = function multilingual8(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    formatLoad
  } = toRefs(props);
  var {
    data,
    requestData,
    clear,
    reset,
    prepare
  } = base$B(props, context, dependencies2, options);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var language = dependencies2.language;
  var nullValue = dependencies2.nullValue;
  var setValue = (val) => {
    if (options.setValue) {
      return options.setValue(val);
    }
    value.value = val;
  };
  var load = function load2(val) {
    var format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var formatted = format2 && formatLoad.value ? formatLoad.value(val, form$.value) : val;
    if (!isPlainObject_1(formatted)) {
      throw new Error("Multilingual element requires an object to load");
    }
    setValue(Object.assign({}, clone_1(nullValue.value), formatted));
  };
  var update = (val) => {
    var updateValue = val;
    if (!isPlainObject_1(updateValue)) {
      updateValue = {
        [language.value]: val
      };
    }
    setValue(Object.assign({}, value.value, updateValue));
  };
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var editor2 = function editor3(props, context, dependencies2) {
  var {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  } = base$B(props, context, dependencies2, {
    setValue: (val) => {
      value.value = val;
      nextTick(() => {
        input.value.update(val);
      });
    }
  });
  var input = dependencies2.input;
  var value = dependencies2.value;
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var teditor = function teditor2(props, context, dependencies2) {
  var {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  } = multilingual$1(props, context, dependencies2, {
    setValue: (val) => {
      value.value = val;
      nextTick(() => {
        input.value.update(val[language.value]);
      });
    }
  });
  var input = dependencies2.input;
  var model = dependencies2.model;
  var value = dependencies2.value;
  var language = dependencies2.language;
  watch(language, () => {
    input.value.update(model.value);
  });
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var file4 = function file5(props, context, dependencies2) {
  var {
    load,
    update,
    clear,
    reset,
    prepare
  } = base$B(props, context, dependencies2);
  var {
    submit,
    formatData,
    name: name2
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var available = dependencies2.available;
  var value = dependencies2.value;
  var data = computed(() => {
    var _v;
    var v = value.value;
    if (typeof v === "object" && (_v = v) !== null && _v !== void 0 && _v.__file__) {
      v = v instanceof File ? v : _objectSpread2$1({}, v);
      delete v.__file__;
    }
    return {
      [name2.value]: v
    };
  });
  var requestData = computed(() => {
    var _v2;
    if (!available.value || !submit.value) {
      return {};
    }
    var v = value.value;
    if (typeof v === "object" && (_v2 = v) !== null && _v2 !== void 0 && _v2.__file__) {
      v = v instanceof File ? v : _objectSpread2$1({}, v);
      delete v.__file__;
    }
    return formatData.value ? formatData.value(name2.value, v, form$.value) : {
      [name2.value]: v
    };
  });
  return {
    data,
    requestData,
    load,
    update,
    clear,
    reset,
    prepare
  };
};
var multifile$4 = function multifile(props, context, dependencies2) {
  var {
    length,
    add: add2,
    remove,
    load,
    update,
    clear,
    reset,
    handleAdd,
    handleRemove,
    prepare
  } = list6(props, context, dependencies2);
  var {
    submit,
    formatData,
    name: name2
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var available = dependencies2.available;
  var value = dependencies2.value;
  var children$ = dependencies2.children$;
  var data = computed(() => {
    var val = value.value;
    val = val.map((file6) => {
      if (typeof file6 === "object" && file6 !== null && file6 !== void 0 && file6.__file__) {
        var v = file6 instanceof File ? file6 : _objectSpread2$1({}, file6);
        delete v.__file__;
        return v;
      }
      return file6;
    });
    return {
      [name2.value]: val
    };
  });
  var requestData = computed(() => {
    if (!available.value || !submit.value) {
      return {};
    }
    var requestData2 = [];
    each(children$.value, (element$) => {
      var val = element$.requestData[element$.name];
      if (val !== void 0) {
        var _val;
        if (typeof val === "object" && (_val = val) !== null && _val !== void 0 && _val.__file__) {
          var v = file4 instanceof File ? file4 : _objectSpread2$1({}, file4);
          delete v.__file__;
          val = v;
        }
        requestData2.push(val);
      }
    });
    return formatData.value ? formatData.value(name2.value, requestData2, form$.value) : {
      [name2.value]: requestData2
    };
  });
  return {
    requestData,
    data,
    length,
    add: add2,
    remove,
    load,
    update,
    clear,
    reset,
    handleAdd,
    handleRemove,
    prepare
  };
};
var multiselect$3 = select$3;
var tags$3 = select$3;
var HasChange = {
  props: {
    onChange: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  }
};
var HasData = {
  props: {
    formatData: {
      required: false,
      type: [Function],
      default: null
    },
    formatLoad: {
      required: false,
      type: [Function],
      default: null
    },
    submit: {
      required: false,
      type: [Boolean],
      default: true
    }
  }
};
var HasValidation = {
  props: {
    rules: {
      required: false,
      type: [Array, String, Object],
      default: null
    },
    messages: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    fieldName: {
      required: false,
      type: [String],
      "@default": "name|label"
    }
  }
};
var CaptchaElement = {
  name: "CaptchaElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "captcha",
      private: true
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    default: {
      required: false,
      type: [String],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    readonly: {
      required: false,
      type: [Boolean],
      default: false
    },
    rules: {
      required: false,
      type: [Array, String, Object],
      default: ["captcha"]
    },
    size: {
      required: false,
      type: [String],
      default: void 0,
      private: true
    },
    fieldName: {
      required: false,
      type: [String],
      "@default": "name|label",
      private: true
    },
    provider: {
      required: false,
      type: [String],
      default: null,
      "@default": "config.useProviders.captcha"
    },
    options: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$G, base$1c, base$P, base$C, base$14, base$D, base$H, base$L, base$E, base$I, captcha2, base$$, base$J, captcha$1, base$Y, base$1a, base$_, base$X, base$F, base$T];
    context.slots = ["label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$A = function base41(props, context, dependencies2) {
  var {
    text: text5
  } = toRefs(props);
  var config$ = inject("config$");
  var form$ = inject("form$");
  var Text = computed(() => {
    return localize(text5.value, config$.value, form$.value) || "";
  });
  return {
    Text
  };
};
var base$z = function base42(props, context, dependencies2) {
  var {
    trueValue,
    falseValue
  } = toRefs(props);
  var update = dependencies2.update;
  var check2 = () => {
    update(trueValue.value);
  };
  var uncheck = () => {
    update(falseValue.value);
  };
  return {
    check: check2,
    uncheck
  };
};
var checkbox2 = function checkbox3(props, context, dependencies2) {
  var {
    trueValue,
    falseValue
  } = toRefs(props);
  var update = dependencies2.update;
  var check2 = () => {
    update(trueValue.value);
  };
  var uncheck = () => {
    update(falseValue.value);
  };
  return {
    check: check2,
    uncheck
  };
};
var CheckboxElement = {
  name: "CheckboxElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "checkbox",
      private: true
    },
    default: {
      required: false,
      type: [String, Boolean, Number],
      default: void 0
      // falseValue
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    text: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    trueValue: {
      required: false,
      type: [Boolean, String, Number],
      default: true
    },
    falseValue: {
      required: false,
      type: [Boolean, String, Number],
      default: false
    },
    align: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, boolean, base$U, base$1c, base$P, base$C, base$14, base$D, base$L, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, checkbox2, checkbox$1, base$F, base$T, base$A];
    context.slots = ["default", "label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$y = function base43(props, context, dependencies2) {
  var value = dependencies2.value;
  var resolvedOptions = dependencies2.resolvedOptions;
  var toggle3 = (val) => {
    if (value.value.indexOf(String(val)) === -1 && value.value.indexOf(Number(val)) === -1) {
      check2(val);
    } else {
      uncheck(val);
    }
  };
  var check2 = (values2) => {
    if (!isArray_1(values2)) {
      values2 = [values2];
    }
    var items = clone_1(value.value);
    each(values2, (item) => {
      if (items.indexOf(String(item)) === -1 && items.indexOf(Number(item)) === -1) {
        items.push(item);
      }
    });
    value.value = items;
  };
  var uncheck = (values2) => {
    if (!isArray_1(values2)) {
      values2 = [values2];
    }
    var items = clone_1(value.value);
    each(values2, (item) => {
      var index2 = items.indexOf(String(item));
      if (index2 === -1) {
        index2 = items.indexOf(Number(item));
      }
      if (index2 !== -1) {
        items.splice(index2, 1);
      }
    });
    value.value = items;
  };
  var checkAll = () => {
    check2(resolvedOptions.value.map((o2) => o2.value));
  };
  var uncheckAll = () => {
    uncheck(resolvedOptions.value.map((o2) => o2.value));
  };
  return {
    toggle: toggle3,
    check: check2,
    uncheck,
    checkAll,
    uncheckAll
  };
};
var base$x = function base44(props, context, dependencies2) {
  var {
    items,
    valueProp,
    labelProp,
    dataKey,
    searchParam,
    clearOnRefetch
  } = toRefs(props);
  var isNative = dependencies2.isNative;
  var disable = dependencies2.disable;
  var enable = dependencies2.enable;
  var input = dependencies2.input;
  var value = dependencies2.value;
  var nullValue = dependencies2.nullValue;
  var path = dependencies2.path;
  var el$ = dependencies2.el$;
  var form$ = dependencies2.form$;
  var config$ = inject("config$");
  var options = ref(null);
  var watchers = ref([]);
  var resolvedOptions = computed(() => {
    if (!isNative.value) {
      return options.value;
    }
    var nativeItems = [];
    each(options.value, (item, key) => {
      if ([null, void 0].indexOf(item) !== -1) {
        return;
      }
      if (Array.isArray(options.value) && typeof item === "object") {
        if (item[valueProp.value] === void 0) {
          console.warn("You must define `value` property for each option when using an array of objects options for select element");
        }
        nativeItems.push({
          value: item[valueProp.value],
          label: item[labelProp.value]
        });
      } else if (Array.isArray(options.value)) {
        nativeItems.push({
          value: item,
          label: item
        });
      } else {
        nativeItems.push({
          value: key,
          label: item
        });
      }
    });
    return nativeItems.map((o2) => {
      return _objectSpread2$1(_objectSpread2$1({}, o2), {}, {
        label: localize(o2.label, config$.value, form$.value)
      });
    });
  });
  var updateItems = function() {
    var _ref = _asyncToGenerator(function* () {
      var shouldDisable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!isNative.value) {
        var _input$value;
        if (typeof items.value === "string") {
          options.value = createAsyncOptionsFromUrl();
        }
        yield (_input$value = input.value) === null || _input$value === void 0 ? void 0 : _input$value.resolveOptions();
        return;
      }
      if (shouldDisable) {
        disable();
      }
      if (typeof items.value === "string") {
        yield resolveOptionsFromUrl();
      } else if (typeof items.value === "function") {
        yield resolveOptionsFromFunction();
      } else {
        options.value = items.value;
      }
      if (shouldDisable) {
        enable();
      }
    });
    return function updateItems2() {
      return _ref.apply(this, arguments);
    };
  }();
  var resolveOptionsFromUrl = function() {
    var _ref2 = _asyncToGenerator(function* () {
      try {
        var _yield$form$$value$$v;
        var url2 = yield resolveUrlAndSetWatchers(items.value, updateItems);
        var optionList = ((_yield$form$$value$$v = yield form$.value.$vueform.services.axios.get(url2)) === null || _yield$form$$value$$v === void 0 ? void 0 : _yield$form$$value$$v.data) || [];
        if (dataKey && dataKey.value && Object.keys(optionList).length) {
          optionList = get_1(optionList, dataKey.value) || [];
        }
        options.value = optionList;
      } catch (e2) {
        options.value = [];
        console.warn("Couldn't resolve items from ".concat(items.value), e2);
      } finally {
        var _resolvedOptions$valu;
        cleanupValue(((_resolvedOptions$valu = resolvedOptions.value) === null || _resolvedOptions$valu === void 0 ? void 0 : _resolvedOptions$valu.map((o2) => o2.value)) || []);
      }
    });
    return function resolveOptionsFromUrl2() {
      return _ref2.apply(this, arguments);
    };
  }();
  var createAsyncOptionsFromUrl = () => {
    return function() {
      var _ref3 = _asyncToGenerator(function* (query) {
        var url2 = yield resolveUrlAndSetWatchers(items.value, updateItems);
        var optionList;
        try {
          var _yield$form$$value$$v2;
          optionList = ((_yield$form$$value$$v2 = yield form$.value.$vueform.services.axios.get("".concat(url2).concat(url2.match(/\?/) ? "&" : "?").concat(searchParam.value, "=").concat(query || ""))) === null || _yield$form$$value$$v2 === void 0 ? void 0 : _yield$form$$value$$v2.data) || [];
          if (dataKey && dataKey.value && Object.keys(optionList).length) {
            optionList = get_1(optionList, dataKey.value) || [];
          }
        } catch (e2) {
          console.error(e2);
        } finally {
          setTimeout(() => {
            var _input$value2;
            cleanupValue(((_input$value2 = input.value) === null || _input$value2 === void 0 || (_input$value2 = _input$value2.eo) === null || _input$value2 === void 0 ? void 0 : _input$value2.map((o2) => o2[valueProp.value])) || []);
          }, 0);
        }
        return optionList;
      });
      return function(_x) {
        return _ref3.apply(this, arguments);
      };
    }();
  };
  var resolveOptionsFromFunction = function() {
    var _ref4 = _asyncToGenerator(function* () {
      try {
        options.value = (yield items.value(el$.value)) || [];
      } catch (e2) {
        options.value = [];
        console.warn("Couldn't resolve items from async function", e2);
      }
    });
    return function resolveOptionsFromFunction2() {
      return _ref4.apply(this, arguments);
    };
  }();
  var resolveOptions = function() {
    var _ref5 = _asyncToGenerator(function* (n2, o2) {
      if (typeof items.value === "function" && isNative.value) {
        yield resolveOptionsFromFunction();
      } else if (!isEqual_1(n2, o2) || n2 === void 0 && o2 === void 0) {
        if (typeof items.value === "string" && isNative.value) {
          yield resolveOptionsFromUrl();
        } else if (typeof items.value === "string" && !isNative.value) {
          options.value = createAsyncOptionsFromUrl();
        } else {
          options.value = items.value;
        }
      }
    });
    return function resolveOptions2(_x2, _x3) {
      return _ref5.apply(this, arguments);
    };
  }();
  var cleanupValue = (values2) => {
    if (clearOnRefetch.value) {
      value.value = cloneDeep_1(nullValue.value);
      return;
    }
    if (!Array.isArray(nullValue.value) && value.value && values2.indexOf(value.value) === -1) {
      value.value = cloneDeep_1(nullValue.value);
    } else if (Array.isArray(nullValue.value) && value.value.length) {
      value.value = value.value.filter((v) => {
        return values2.indexOf(v) !== -1;
      });
    }
  };
  var resolveUrlAndSetWatchers = function() {
    var _ref6 = _asyncToGenerator(function* (url2, updateItems2) {
      var regex2 = /{([^}]+)}/g;
      var resolvedUrl = url2;
      if (url2.match(regex2)) {
        yield nextTick();
        watchers.value.forEach((unwatch) => unwatch());
        var match;
        var _loop = function* _loop2() {
          var _match$1$match;
          var defaultValue = ((_match$1$match = match[1].match(/\|'([^']+)/)) === null || _match$1$match === void 0 ? void 0 : _match$1$match[1]) || "";
          var elPath = replaceWildcards(match[1].match(/^([^|]+)/)[1], path.value);
          var el$2 = form$.value.el$(elPath);
          var elValue = typeof (el$2 === null || el$2 === void 0 ? void 0 : el$2.value) !== "undefined" && el$2.value !== null && typeof el$2.value === "object" ? JSON.stringify(el$2.value) : typeof (el$2 === null || el$2 === void 0 ? void 0 : el$2.value) !== "undefined" && el$2.value !== null ? el$2.value : defaultValue;
          resolvedUrl = resolvedUrl.replace(match[0], encodeURIComponent(elValue));
          watchers.value.push(watch(computed(() => el$2 === null || el$2 === void 0 ? void 0 : el$2.value), () => {
            updateItems2();
          }));
        };
        while ((match = regex2.exec(url2)) !== null) {
          yield* _loop();
        }
      }
      return resolvedUrl;
    });
    return function resolveUrlAndSetWatchers2(_x4, _x5) {
      return _ref6.apply(this, arguments);
    };
  }();
  return {
    resolveOptions,
    resolvedOptions,
    updateItems,
    watchers,
    cleanupValue,
    resolveUrlAndSetWatchers
  };
};
var select$2 = function select2(props, context, dependencies2) {
  var {
    items
  } = toRefs(props);
  var {
    resolveOptions,
    resolvedOptions,
    updateItems,
    watchers,
    cleanupValue,
    resolveUrlAndSetWatchers
  } = base$x(props, context, dependencies2);
  resolveOptions();
  watch(items, resolveOptions);
  return {
    resolveOptions,
    resolvedOptions,
    updateItems,
    watchers,
    cleanupValue,
    resolveUrlAndSetWatchers
  };
};
var checkboxgroup3 = function checkboxgroup4(props, context, dependencies2) {
  var {
    items
  } = toRefs(props);
  var {
    watchers,
    cleanupValue,
    resolveUrlAndSetWatchers
  } = base$x(props, context, dependencies2);
  var disableAll = dependencies2.disableAll;
  var enableAll = dependencies2.enableAll;
  var el$ = dependencies2.el$;
  var form$ = dependencies2.form$;
  var config$ = inject("config$");
  var options = ref(null);
  var resolvedOptions = computed(() => {
    var resolvedOptions2 = [];
    each(options.value, (item, key) => {
      if ([null, void 0].indexOf(item) !== -1) {
        return;
      }
      if (Array.isArray(options.value) && typeof item === "object") {
        if (item.value === void 0) {
          console.warn("You must define `value` property for each item when using an array of objects options");
        }
        resolvedOptions2.push(item);
      } else if (Array.isArray(options.value)) {
        resolvedOptions2.push({
          value: item,
          label: item
        });
      } else if (typeof item === "object") {
        resolvedOptions2.push(_objectSpread2$1(_objectSpread2$1({}, item), {}, {
          value: key
        }));
      } else {
        resolvedOptions2.push({
          label: item,
          value: key
        });
      }
    });
    return resolvedOptions2.map((o2) => {
      return _objectSpread2$1(_objectSpread2$1({}, o2), {}, {
        label: localize(o2.label, config$.value, form$.value)
      });
    });
  });
  var updateItems = function() {
    var _ref7 = _asyncToGenerator(function* () {
      var shouldDisable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (shouldDisable) {
        disableAll();
      }
      if (typeof items.value === "string") {
        yield resolveOptionsFromUrl();
      } else {
        yield resolveOptionsFromFunction();
      }
      if (shouldDisable) {
        enableAll();
      }
    });
    return function updateItems2() {
      return _ref7.apply(this, arguments);
    };
  }();
  var resolveOptionsFromUrl = function() {
    var _ref8 = _asyncToGenerator(function* () {
      try {
        var _yield$form$$value$$v3, _resolvedOptions$valu2;
        var url2 = yield resolveUrlAndSetWatchers(items.value, updateItems);
        options.value = ((_yield$form$$value$$v3 = yield form$.value.$vueform.services.axios.get(url2)) === null || _yield$form$$value$$v3 === void 0 ? void 0 : _yield$form$$value$$v3.data) || [];
        cleanupValue(((_resolvedOptions$valu2 = resolvedOptions.value) === null || _resolvedOptions$valu2 === void 0 ? void 0 : _resolvedOptions$valu2.map((o2) => o2.value)) || []);
      } catch (e2) {
        options.value = [];
        console.warn("Couldn't resolve items from ".concat(items.value), e2);
      }
    });
    return function resolveOptionsFromUrl2() {
      return _ref8.apply(this, arguments);
    };
  }();
  var resolveOptionsFromFunction = function() {
    var _ref9 = _asyncToGenerator(function* () {
      try {
        options.value = (yield items.value(el$.value)) || [];
      } catch (e2) {
        options.value = [];
        console.warn("Couldn't resolve items from async function", e2);
      }
    });
    return function resolveOptionsFromFunction2() {
      return _ref9.apply(this, arguments);
    };
  }();
  var resolveOptions = function() {
    var _ref10 = _asyncToGenerator(function* () {
      if (typeof items.value === "function") {
        yield resolveOptionsFromFunction();
      } else if (typeof items.value === "string") {
        yield resolveOptionsFromUrl();
      } else {
        options.value = items.value;
      }
    });
    return function resolveOptions2() {
      return _ref10.apply(this, arguments);
    };
  }();
  resolveOptions();
  watch(items, resolveOptions);
  return {
    resolveOptions,
    resolvedOptions,
    updateItems,
    watchers,
    cleanupValue,
    resolveUrlAndSetWatchers
  };
};
var radiogroup = checkboxgroup3;
var multiselect$2 = select$2;
var tags$2 = select$2;
var CheckboxgroupElement = {
  name: "CheckboxgroupElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "checkboxgroup",
      private: true
    },
    default: {
      required: false,
      type: [Array],
      default: () => []
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    items: {
      required: false,
      type: [Object, Array, Function, String],
      localized: true,
      default: () => ({})
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    disables: {
      required: false,
      type: [Array],
      default: () => []
    },
    clearOnRefetch: {
      type: [Boolean],
      required: false,
      default: true
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$O, array$1, base$U, base$1c, checkboxgroup$1, checkboxgroup$3, base$C, base$L, checkboxgroup3, base$14, base$D, base$y, base$B, base$$, base$J, base$_, base$Z, base$Y, base$1a, base$X, checkboxgroup$2, base$F, base$T];
    context.slots = ["checkbox", "label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$w = function base45(props, context, dependencies2) {
  var {
    addons,
    slots
  } = toRefs(props);
  var el$ = dependencies2.el$;
  var form$ = dependencies2.form$;
  var hasAddonBefore = computed(() => {
    var _el$$value$$slots, _el$$value$$scopedSlo;
    return !!(addons.value.before || (_el$$value$$slots = el$.value.$slots) !== null && _el$$value$$slots !== void 0 && _el$$value$$slots["addon-before"] || /* istanbul ignore next */
    form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo !== void 0 && _el$$value$$scopedSlo["addon-before"] || slots.value["addon-before"]);
  });
  var hasAddonAfter = computed(() => {
    var _el$$value$$slots2, _el$$value$$scopedSlo2;
    return !!(addons.value.after || (_el$$value$$slots2 = el$.value.$slots) !== null && _el$$value$$slots2 !== void 0 && _el$$value$$slots2["addon-after"] || /* istanbul ignore next */
    form$.value.$vueform.vueVersion === 2 && (_el$$value$$scopedSlo2 = el$.value.$scopedSlots) !== null && _el$$value$$scopedSlo2 !== void 0 && _el$$value$$scopedSlo2["addon-after"] || slots.value["addon-after"]);
  });
  return {
    hasAddonBefore,
    hasAddonAfter
  };
};
var base$v = function base46(props, context, dependencies2) {
  var {
    displayFormat,
    valueFormat,
    loadFormat,
    date: date6,
    time: time2,
    seconds: seconds2,
    hour24
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var defaultFormat = computed(() => {
    var format2;
    if (date6.value && time2.value && seconds2.value && hour24.value) {
      format2 = "datetimeSeconds24";
    } else if (date6.value && time2.value && seconds2.value && !hour24.value) {
      format2 = "datetimeSeconds12";
    } else if (date6.value && time2.value && !seconds2.value && hour24.value) {
      format2 = "datetime24";
    } else if (date6.value && time2.value && !seconds2.value && !hour24.value) {
      format2 = "datetime12";
    } else if (!date6.value && time2.value && seconds2.value && hour24.value) {
      format2 = "timeSeconds24";
    } else if (!date6.value && time2.value && seconds2.value && !hour24.value) {
      format2 = "timeSeconds12";
    } else if (!date6.value && time2.value && !seconds2.value && hour24.value) {
      format2 = "time24";
    } else if (!date6.value && time2.value && !seconds2.value && !hour24.value) {
      format2 = "time12";
    } else {
      format2 = "date";
    }
    return format2;
  });
  var defaultDisplayFormat = computed(() => {
    return form$.value.translations.vueform.dateFormats[defaultFormat.value];
  });
  var defaultDataFormat = computed(() => {
    var dataDateFormats = {
      datetimeSeconds24: "YYYY-MM-DD HH:mm:ss",
      datetimeSeconds12: "YYYY-MM-DD hh:mm:ss a",
      datetime24: "YYYY-MM-DD HH:mm",
      datetime12: "YYYY-MM-DD hh:mm a",
      timeSeconds24: "HH:mm:ss",
      timeSeconds12: "hh:mm:ss a",
      time24: "HH:mm",
      time12: "hh:mm a",
      date: "YYYY-MM-DD"
    };
    return dataDateFormats[defaultFormat.value];
  });
  var displayDateFormat = computed(() => {
    return displayFormat.value !== null ? displayFormat.value : defaultDisplayFormat.value;
  });
  var valueDateFormat = computed(() => {
    return valueFormat.value !== null || valueFormat.value === false ? valueFormat.value : defaultDataFormat.value;
  });
  var loadDateFormat = computed(() => {
    return loadFormat.value !== null ? loadFormat.value : defaultDataFormat.value;
  });
  return {
    displayDateFormat,
    valueDateFormat,
    loadDateFormat
  };
};
var dates$2 = function dates3(props, context, dependencies2) {
  var {
    displayFormat,
    valueFormat,
    loadFormat
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var defaultFormat = computed(() => {
    return form$.value.translations.vueform.dateFormats.date;
  });
  var displayDateFormat = computed(() => {
    return displayFormat.value !== null ? displayFormat.value : defaultFormat.value;
  });
  var valueDateFormat = computed(() => {
    return valueFormat.value !== null || valueFormat.value === false ? valueFormat.value : defaultFormat.value;
  });
  var loadDateFormat = computed(() => {
    return loadFormat.value !== null ? loadFormat.value : defaultFormat.value;
  });
  return {
    displayDateFormat,
    valueDateFormat,
    loadDateFormat
  };
};
var base$u = function base47(props, context, dependencies2) {
  var value = dependencies2.value;
  var handleChange = (val) => {
    value.value = val;
  };
  return {
    handleChange
  };
};
var base$t = function base48(props, context, dependencies2) {
  var {
    placeholder
  } = toRefs(props);
  var config$ = inject("config$");
  var form$ = inject("form$");
  var Placeholder = computed(() => {
    return localize(placeholder.value, config$.value, form$.value);
  });
  return {
    Placeholder
  };
};
var date$1 = function date3(props, context, dependencies2) {
  var {
    disables,
    min: min4,
    max: max3,
    extendOptions,
    readonly,
    hour24,
    seconds: seconds2,
    date: date6,
    time: time2
  } = toRefs(props);
  var isDisabled = dependencies2.isDisabled;
  var displayDateFormat = dependencies2.displayDateFormat;
  var valueDateFormat = dependencies2.valueDateFormat;
  var disabledDates = computed(() => {
    if (disables.value === void 0) {
      return [];
    }
    return map_1(disables.value, (disabledDate) => {
      checkDateFormat(valueDateFormat.value, disabledDate);
      return disabledDate instanceof Date ? disabledDate : moment_default(disabledDate, valueDateFormat.value, true).toDate();
    });
  });
  var minDate = computed(() => {
    if (!min4.value) {
      return null;
    }
    checkDateFormat(valueDateFormat.value, min4.value);
    return min4.value instanceof Date ? min4.value : moment_default(min4.value, valueDateFormat.value, true).toDate();
  });
  var maxDate = computed(() => {
    if (!max3.value) {
      return null;
    }
    checkDateFormat(valueDateFormat.value, max3.value);
    return max3.value instanceof Date ? max3.value : moment_default(max3.value, valueDateFormat.value, true).toDate();
  });
  var defaultOptions = computed(() => {
    return {
      dateFormat: displayDateFormat.value,
      minDate: minDate.value,
      maxDate: maxDate.value,
      disable: disabledDates.value,
      clickOpens: !isDisabled.value && !readonly.value,
      time_24hr: hour24.value,
      enableTime: time2.value,
      enableSeconds: seconds2.value,
      noCalendar: !date6.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  var hasDate = computed(() => {
    return true;
  });
  var hasTime = computed(() => {
    return false;
  });
  return {
    minDate,
    maxDate,
    disabledDates,
    fieldOptions,
    hasDate,
    hasTime
  };
};
var dates$1 = function dates4(props, context, dependencies2) {
  var {
    mode,
    extendOptions,
    readonly
  } = toRefs(props);
  var {
    minDate,
    maxDate,
    disabledDates
  } = date$1(props, context, dependencies2);
  var isDisabled = dependencies2.isDisabled;
  var displayDateFormat = dependencies2.displayDateFormat;
  var defaultOptions = computed(() => {
    return {
      mode: mode.value,
      dateFormat: displayDateFormat.value,
      minDate: minDate.value,
      maxDate: maxDate.value,
      disable: disabledDates.value,
      clickOpens: !isDisabled.value && !readonly.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  var hasDate = computed(() => {
    return true;
  });
  var hasTime = computed(() => {
    return false;
  });
  return {
    minDate,
    maxDate,
    disabledDates,
    fieldOptions,
    hasDate,
    hasTime
  };
};
var select$1 = function select3(props, context, dependencies2) {
  var {
    native,
    extendOptions,
    labelProp,
    trackBy,
    valueProp,
    search,
    limit,
    noOptionsText,
    noResultsText,
    caret,
    object: object9,
    delay,
    minChars,
    resolveOnLoad,
    filterResults,
    clearOnSearch,
    canDeselect,
    canClear,
    openDirection,
    strict,
    closeOnSelect,
    closeOnDeselect,
    autocomplete,
    groups,
    groupLabel,
    groupOptions,
    groupHideEmpty,
    inputType,
    create,
    appendNewOption,
    addOptionOn,
    appendTo,
    appendToBody
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var isLoading = dependencies2.isLoading;
  var config$ = inject("config$");
  var isNative = computed(() => {
    return native.value && !search.value;
  });
  var defaultOptions = computed(() => {
    return {
      mode: "single",
      searchable: search.value || create.value,
      noOptionsText: noOptionsText.value || form$.value.translations.vueform.multiselect.noOptions,
      noResultsText: noResultsText.value || form$.value.translations.vueform.multiselect.noResults,
      locale: Object.keys(config$.value.i18n.locales).length > 1 ? config$.value.i18n.locale : null,
      //@todo:adam can not be localized on form level
      fallbackLocale: config$.value.i18n.fallbackLocale,
      label: labelProp.value,
      trackBy: trackBy.value,
      valueProp: valueProp.value,
      limit: limit.value,
      caret: caret.value,
      loading: isLoading.value,
      object: object9.value,
      delay: delay.value,
      minChars: minChars.value,
      resolveOnLoad: resolveOnLoad.value,
      filterResults: filterResults.value,
      clearOnSearch: clearOnSearch.value,
      canDeselect: canDeselect.value,
      canClear: canClear.value,
      openDirection: openDirection.value,
      strict: strict.value,
      closeOnSelect: closeOnSelect.value,
      closeOnDeselect: closeOnDeselect.value,
      autocomplete: autocomplete.value,
      groups: groups.value,
      groupLabel: groupLabel.value,
      groupOptions: groupOptions.value,
      groupHideEmpty: groupHideEmpty.value,
      inputType: inputType.value,
      createOption: create.value,
      appendNewOption: appendNewOption.value,
      addOptionOn: addOptionOn.value,
      appendTo: appendTo.value,
      appendToBody: appendToBody.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  return {
    fieldOptions,
    isNative
  };
};
var multiselect$1 = function multiselect(props, context, dependencies2) {
  var {
    native,
    extendOptions,
    labelProp,
    trackBy,
    valueProp,
    search,
    limit,
    noOptionsText,
    noResultsText,
    caret,
    object: object9,
    delay,
    minChars,
    resolveOnLoad,
    filterResults,
    clearOnSearch,
    clearOnSelect,
    canClear,
    max: max3,
    openDirection,
    strict,
    closeOnSelect,
    closeOnDeselect,
    autocomplete,
    groups,
    groupLabel,
    groupOptions,
    groupHideEmpty,
    groupSelect,
    inputType,
    hideSelected,
    multipleLabel,
    multipleLabelMultiple,
    multipleLabelSingle,
    create,
    appendNewOption,
    addOptionOn,
    appendTo,
    appendToBody
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var isLoading = dependencies2.isLoading;
  var config$ = inject("config$");
  var isNative = computed(() => {
    return native.value && !search.value;
  });
  var defaultOptions = computed(() => {
    return {
      mode: "multiple",
      searchable: search.value || create.value,
      noOptionsText: noOptionsText.value || form$.value.translations.vueform.multiselect.noOptions,
      noResultsText: noResultsText.value || form$.value.translations.vueform.multiselect.noResults,
      multipleLabel: multipleLabel.value || ((val, select$) => {
        return val && val.length > 1 ? multipleLabelMultiple.value ? multipleLabelMultiple.value.replace(":x:", val.length) : form$.value.__(form$.value.translations.vueform.multiselect.multipleLabelMore, {
          options: val.length
        }) : multipleLabelSingle.value || form$.value.translations.vueform.multiselect.multipleLabelOne;
      }),
      locale: Object.keys(config$.value.i18n.locales).length > 1 ? config$.value.i18n.locale : null,
      //@todo:adam can not be localized on form level
      fallbackLocale: config$.value.i18n.fallbackLocale,
      label: labelProp.value,
      trackBy: trackBy.value,
      valueProp: valueProp.value,
      limit: limit.value,
      caret: caret.value,
      loading: isLoading.value,
      object: object9.value,
      delay: delay.value,
      minChars: minChars.value,
      resolveOnLoad: resolveOnLoad.value,
      filterResults: filterResults.value,
      clearOnSearch: clearOnSearch.value,
      clearOnSelect: clearOnSelect.value,
      canClear: canClear.value,
      max: max3.value,
      openDirection: openDirection.value,
      strict: strict.value,
      closeOnSelect: closeOnSelect.value,
      closeOnDeselect: closeOnDeselect.value,
      autocomplete: autocomplete.value,
      groups: groups.value,
      groupLabel: groupLabel.value,
      groupOptions: groupOptions.value,
      groupHideEmpty: groupHideEmpty.value,
      groupSelect: groupSelect.value,
      inputType: inputType.value,
      hideSelected: hideSelected.value,
      createOption: create.value,
      appendNewOption: appendNewOption.value,
      addOptionOn: addOptionOn.value,
      appendTo: appendTo.value,
      appendToBody: appendToBody.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  return {
    fieldOptions,
    isNative
  };
};
var tags$1 = function tags(props, context, dependencies2) {
  var {
    extendOptions,
    labelProp,
    trackBy,
    valueProp,
    search,
    limit,
    noOptionsText,
    noResultsText,
    caret,
    object: object9,
    delay,
    minChars,
    resolveOnLoad,
    filterResults,
    clearOnSearch,
    clearOnSelect,
    canClear,
    max: max3,
    showOptions,
    openDirection,
    strict,
    closeOnSelect,
    closeOnDeselect,
    autocomplete,
    groups,
    groupLabel,
    groupOptions,
    groupHideEmpty,
    groupSelect,
    inputType,
    hideSelected,
    create,
    appendNewOption,
    addOptionOn,
    breakTags,
    appendTo,
    appendToBody
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var isLoading = dependencies2.isLoading;
  var config$ = inject("config$");
  var native = ref(false);
  var isNative = computed(() => {
    return false;
  });
  var defaultOptions = computed(() => {
    return {
      mode: "tags",
      searchable: search.value || create.value,
      noOptionsText: noOptionsText.value || form$.value.translations.vueform.multiselect.noOptions,
      noResultsText: noResultsText.value || form$.value.translations.vueform.multiselect.noResults,
      locale: Object.keys(config$.value.i18n.locales).length > 1 ? config$.value.i18n.locale : null,
      //@todo:adam can not be localized on form level
      fallbackLocale: config$.value.i18n.fallbackLocale,
      label: labelProp.value,
      trackBy: trackBy.value,
      valueProp: valueProp.value,
      limit: limit.value,
      caret: caret.value,
      loading: isLoading.value,
      object: object9.value,
      delay: delay.value,
      minChars: minChars.value,
      resolveOnLoad: resolveOnLoad.value,
      filterResults: filterResults.value,
      clearOnSearch: clearOnSearch.value,
      clearOnSelect: clearOnSelect.value,
      canClear: canClear.value,
      max: max3.value,
      showOptions: showOptions.value,
      openDirection: openDirection.value,
      strict: strict.value,
      closeOnSelect: closeOnSelect.value,
      closeOnDeselect: closeOnDeselect.value,
      autocomplete: autocomplete.value,
      groups: groups.value,
      groupLabel: groupLabel.value,
      groupOptions: groupOptions.value,
      groupHideEmpty: groupHideEmpty.value,
      groupSelect: groupSelect.value,
      inputType: inputType.value,
      hideSelected: hideSelected.value,
      createOption: create.value,
      appendNewOption: appendNewOption.value,
      addOptionOn: addOptionOn.value,
      breakTags: breakTags.value,
      appendTo: appendTo.value,
      appendToBody: appendToBody.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  return {
    native,
    fieldOptions,
    isNative
  };
};
var slider2 = function slider3(props, context, dependencies2) {
  var {
    min: min4,
    max: max3,
    step,
    tooltips,
    merge: merge3,
    format: format2,
    orientation,
    direction,
    extendOptions,
    showTooltip,
    tooltipPosition,
    lazy
  } = toRefs(props);
  var isDisabled = dependencies2.isDisabled;
  dependencies2.labelId;
  var defaultOptions = computed(() => {
    return {
      min: min4.value,
      max: max3.value,
      step: step.value,
      tooltips: tooltips.value,
      merge: merge3.value,
      format: format2.value,
      orientation: orientation.value,
      direction: direction.value,
      disabled: isDisabled.value,
      showTooltip: showTooltip.value,
      tooltipPosition: tooltipPosition.value,
      lazy: lazy.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  return {
    fieldOptions
  };
};
var toggle = function toggle2(props, context, dependencies2) {
  var {
    labels,
    extendOptions,
    trueValue,
    falseValue
  } = toRefs(props);
  var isDisabled = dependencies2.isDisabled;
  var form$ = dependencies2.form$;
  var config$ = inject("config$");
  var defaultOptions = computed(() => {
    return {
      disabled: isDisabled.value,
      offLabel: labels.value ? localize(labels.value.off, config$.value, form$.value) || "" : (
        /* istanbul ignore next: default is hardcoded {}, will never fall there */
        ""
      ),
      onLabel: labels.value ? localize(labels.value.on, config$.value, form$.value) || "" : (
        /* istanbul ignore next: default is hardcoded {}, will never fall there */
        ""
      ),
      trueValue: trueValue.value,
      falseValue: falseValue.value
    };
  });
  var fieldOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next */
    {});
  });
  return {
    fieldOptions
  };
};
var base$s = function base49(props, context, dependencies2) {
  var input = dependencies2.input;
  var focused = ref(false);
  onMounted(() => {
    if (input && input.value && input.value.addEventListener) {
      input.value.addEventListener("focus", () => {
        focused.value = true;
      });
      input.value.addEventListener("blur", () => {
        focused.value = false;
      });
    }
  });
  return {
    focused
  };
};
var date4 = function date5(props, context, dependencies2) {
  var input = dependencies2.input;
  var focused = ref(false);
  onMounted(() => {
    input.value.input.addEventListener("focus", () => {
      focused.value = true;
    });
    input.value.input.addEventListener("blur", () => {
      focused.value = false;
    });
  });
  return {
    focused
  };
};
var select4 = function select5(props, context, dependencies2) {
  var input = dependencies2.input;
  var isNative = dependencies2.isNative;
  var focused = ref(false);
  onMounted(() => {
    if (isNative.value) {
      input.value.addEventListener("focus", () => {
        focused.value = true;
      });
      input.value.addEventListener("blur", () => {
        focused.value = false;
      });
    } else {
      watch(computed(() => {
        var _input$value;
        return (_input$value = input.value) === null || _input$value === void 0 ? void 0 : _input$value.isActive;
      }), (active) => {
        focused.value = active;
      });
    }
  });
  return {
    focused
  };
};
var dates5 = date4;
var multiselect2 = select4;
var tags2 = select4;
var DateElement = {
  name: "DateElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "date",
      private: true
    },
    default: {
      required: false,
      type: [String, Date],
      default: null
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    displayFormat: {
      required: false,
      type: [String],
      default: null,
      "@default": "locale.vueform.dateFormats.*"
    },
    valueFormat: {
      required: false,
      type: [String, Boolean],
      default: null,
      "@default": "locale.vueform.dateFormats.*"
    },
    loadFormat: {
      required: false,
      type: [String],
      default: null,
      "@default": "locale.vueform.dateFormats.*"
    },
    date: {
      required: false,
      type: [Boolean],
      default: true
    },
    time: {
      required: false,
      type: [Boolean],
      default: false
    },
    seconds: {
      required: false,
      type: [Boolean],
      default: false
    },
    hour24: {
      required: false,
      type: [Boolean],
      default: true
    },
    min: {
      required: false,
      type: [String, Date],
      default: null
    },
    max: {
      required: false,
      type: [String, Date],
      default: null
    },
    disables: {
      required: false,
      type: [Array],
      default: () => []
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean],
      default: false
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$G, base$1c, base$P, base$w, base$v, date$1, base$C, base$14, base$D, date$3, base$I, date$2, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$u, date4, base$R, base$F, base$T, base$t];
    context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var DatesElement = {
  name: "DatesElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "dates",
      private: true
    },
    default: {
      required: false,
      type: [Array],
      default: () => []
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    displayFormat: {
      required: false,
      type: [String],
      default: null
    },
    valueFormat: {
      required: false,
      type: [String, Boolean],
      default: null
    },
    loadFormat: {
      required: false,
      type: [String, Boolean],
      default: null
    },
    mode: {
      required: false,
      type: [String],
      default: "multiple"
    },
    min: {
      required: false,
      type: [String, Date],
      default: null
    },
    max: {
      required: false,
      type: [String, Date],
      default: null
    },
    disables: {
      required: false,
      type: [Array],
      default: () => []
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean],
      default: false
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, array$1, base$U, base$G, base$1c, dates$5, base$w, dates$2, dates$1, base$C, dates$4, base$14, base$D, base$I, dates$3, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$u, dates5, base$R, base$F, base$T, base$t];
    context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$r = function base50(props, context, dependencies2) {
  var {
    embed,
    auto,
    methods,
    urls,
    uploadTempEndpoint,
    removeTempEndpoint,
    removeEndpoint,
    url: url2,
    previewUrl,
    params,
    softRemove,
    view
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var isDisabled = dependencies2.isDisabled;
  var validate = dependencies2.validate;
  var invalid = dependencies2.invalid;
  var path = dependencies2.path;
  var axios2 = dependencies2.axios;
  var request = dependencies2.request;
  var uploading = dependencies2.uploading;
  var input = dependencies2.input;
  var update = dependencies2.update;
  var fire = dependencies2.fire;
  dependencies2.isImageType;
  var removing = dependencies2.removing;
  var handleError = dependencies2.handleError;
  var el$ = dependencies2.el$;
  var hasUploadError = ref(false);
  var progress = ref(0);
  var preparing = ref(false);
  var endpoints = computed(() => {
    var configEndpoints = form$.value.$vueform.config.endpoints;
    var propEndpoints = {
      uploadTempFile: uploadTempEndpoint.value,
      removeTempFile: removeTempEndpoint.value,
      removeFile: removeEndpoint.value
    };
    var endpoints2 = {};
    Object.keys(propEndpoints).forEach((name2) => {
      var endpoint = configEndpoints[name2];
      if (urls.value[name2]) {
        endpoint = {
          url: urls.value[name2],
          method: "POST"
        };
      }
      if (methods.value[name2] && typeof endpoint === "object") {
        endpoint.method = methods.value[name2];
      }
      if (typeof propEndpoints[name2] === "string") {
        if (configEndpoints[propEndpoints[name2]] !== void 0) {
          endpoint = configEndpoints[propEndpoints[name2]];
        } else {
          endpoint.url = propEndpoints[name2];
        }
      }
      if (propEndpoints[name2] === false) {
        endpoint = (f) => f;
      }
      if (typeof propEndpoints[name2] === "function") {
        endpoint = propEndpoints[name2];
      }
      if (typeof propEndpoints[name2] === "object") {
        endpoint = {
          url: propEndpoints[name2].url || propEndpoints[name2].endpoint || configEndpoints[name2].url,
          method: propEndpoints[name2].method || configEndpoints[name2].method
        };
      }
      endpoints2[name2] = endpoint;
    });
    return endpoints2;
  });
  var fileUrl = computed(() => {
    if (url2.value === void 0) {
      return "/";
    }
    if (url2.value === false) {
      return "";
    }
    var fileUrl2 = url2.value;
    if (!fileUrl2.match(/\/$/)) {
      fileUrl2 += "/";
    }
    if (!fileUrl2.match(/^http/) && !fileUrl2.match(/^\//)) {
      fileUrl2 = "/" + fileUrl2;
    }
    return fileUrl2;
  });
  var filePreviewUrl = computed(() => {
    if (previewUrl.value === void 0) {
      return fileUrl.value;
    }
    var filePreviewUrl2 = previewUrl.value;
    if (!filePreviewUrl2.match(/\/$/)) {
      filePreviewUrl2 += "/";
    }
    if (!filePreviewUrl2.match(/^http/) && !filePreviewUrl2.match(/^\//)) {
      filePreviewUrl2 = "/" + filePreviewUrl2;
    }
    return filePreviewUrl2;
  });
  var stage = computed(() => {
    if (value.value === null) {
      return 0;
    }
    if (value.value instanceof File) {
      return 1;
    }
    if (isObject_1(value.value) && value.value.tmp !== void 0) {
      return 2;
    }
    if (isString_1(value.value)) {
      return 3;
    }
    return -1;
  });
  var filename = computed(() => {
    switch (stage.value) {
      case 1:
        return value.value.name;
      case 2:
        return value.value.originalName;
      case 3:
        return value.value;
      default:
        return null;
    }
  });
  var link = computed(() => {
    if (!uploaded.value) {
      return;
    }
    return fileUrl.value + filename.value;
  });
  var previewLink = computed(() => {
    if (!uploaded.value) {
      return;
    }
    return filePreviewUrl.value + filename.value;
  });
  var preview = computed(() => {
    var _value$value;
    if (view.value === "file") {
      return null;
    }
    return uploaded.value ? previewLink.value : value.value instanceof File ? URL.createObjectURL(value.value) : ((_value$value = value.value) === null || _value$value === void 0 ? void 0 : _value$value.__file__) instanceof File ? URL.createObjectURL(value.value.__file__) : null;
  });
  var uploaded = computed(() => {
    return stage.value === 3;
  });
  var canRemove = computed(() => {
    return stage.value > 0 && !uploading.value && !isDisabled.value && !preparing.value && !removing.value;
  });
  var canUploadTemp = computed(() => {
    return stage.value === 1 && !auto.value && !uploading.value && !isDisabled.value;
  });
  var canSelect = computed(() => {
    return !embed.value && stage.value == 0;
  });
  var uploadTemp = function() {
    var _ref = _asyncToGenerator(function* () {
      if (stage.value !== 1) {
        throw new Error("No file is selected");
      }
      yield validate();
      if (invalid.value) {
        return;
      }
      request.value = axios2.value.CancelToken.source();
      try {
        var data = getFormData(Object.assign({}, params.value, {
          file: value.value,
          formKey: form$.value.options.formKey,
          path: path.value
        }));
        hasUploadError.value = false;
        var response;
        if (typeof endpoints.value.uploadTempFile === "function") {
          response = yield endpoints.value.uploadTempFile(value.value, el$.value);
        } else {
          var method = endpoints.value.uploadTempFile.method.toLowerCase();
          response = yield axios2.value.request({
            url: endpoints.value.uploadTempFile.url,
            method,
            [method === "get" ? "params" : "data"]: data,
            onUploadProgress: (e2) => {
              progress.value = Math.round(e2.loaded * 100 / e2.total);
            },
            cancelToken: request.value.token
          });
          response = response.data;
        }
        if (response && typeof response === "object") {
          response.__file__ = value.value;
        }
        update(response);
      } catch (error) {
        progress.value = 0;
        if (!axios2.value.isCancel(error)) {
          hasUploadError.value = true;
          handleError(error);
        }
        throw new Error(error);
      } finally {
        request.value = null;
      }
    });
    return function uploadTemp2() {
      return _ref.apply(this, arguments);
    };
  }();
  var remove = function() {
    var _ref2 = _asyncToGenerator(function* () {
      removing.value = true;
      hasUploadError.value = false;
      try {
        if (stage.value === 3 && !softRemove.value) {
          if (!confirm(form$.value.translations.vueform.elements.file.removeConfirm)) {
            return false;
          }
          if (typeof endpoints.value.removeFile === "function") {
            yield endpoints.value.removeFile(value.value, el$.value);
          } else {
            var method = endpoints.value.removeFile.method.toLowerCase();
            yield axios2.value.request({
              method,
              url: endpoints.value.removeFile.url,
              [method === "get" ? "params" : "data"]: Object.assign({}, params.value, {
                file: value.value,
                formKey: form$.value.options.formKey,
                path: path.value
              })
            });
          }
        } else if (stage.value === 2 && !softRemove.value) {
          if (typeof endpoints.value.removeTempFile === "function") {
            yield endpoints.value.removeTempFile(value.value, el$.value);
          } else {
            var _method = endpoints.value.removeTempFile.method.toLowerCase();
            yield axios2.value.request({
              method: _method,
              url: endpoints.value.removeTempFile.url,
              [_method === "get" ? "params" : "data"]: Object.assign({}, params.value, {
                file: value.value.tmp,
                formKey: form$.value.options.formKey,
                path: path.value
              })
            });
          }
        }
      } catch (error) {
        handleError(error);
        return;
      } finally {
        removing.value = false;
      }
      update(null);
      progress.value = 0;
      fire("remove");
    });
    return function remove2() {
      return _ref2.apply(this, arguments);
    };
  }();
  var prepare = function() {
    var _ref3 = _asyncToGenerator(function* () {
      if (stage.value === 1) {
        preparing.value = true;
        try {
          yield uploadTemp();
        } finally {
          preparing.value = false;
        }
      }
    });
    return function prepare2() {
      return _ref3.apply(this, arguments);
    };
  }();
  var handleChange = function() {
    var _ref4 = _asyncToGenerator(function* (e2) {
      var file6 = e2.target.files[0];
      input.value.value = "";
      update(file6 || null);
      if (auto.value) {
        yield uploadTemp();
      }
      if (form$.value.shouldValidateOnChange) {
        validate();
      }
    });
    return function handleChange2(_x) {
      return _ref4.apply(this, arguments);
    };
  }();
  var handleClick = () => {
    if (isDisabled.value) {
      return;
    }
    input.value.click();
  };
  var handleUploadTemp = () => {
    uploadTemp();
  };
  var handleRemove = () => {
    remove();
  };
  var handleAbort = () => {
    if (request.value === null) {
      return;
    }
    request.value.cancel();
  };
  if (value.value instanceof File && auto.value) {
    nextTick(() => {
      uploadTemp();
    });
  }
  return {
    hasUploadError,
    progress,
    preparing,
    endpoints,
    fileUrl,
    stage,
    filename,
    link,
    preview,
    uploaded,
    canRemove,
    canUploadTemp,
    canSelect,
    uploadTemp,
    remove,
    prepare,
    handleChange,
    handleClick,
    handleUploadTemp,
    handleRemove,
    handleAbort
  };
};
var base$q = function base51(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var request = ref(null);
  var axios2 = ref(null);
  var uploading = computed(() => {
    return request.value !== null;
  });
  onMounted(() => {
    axios2.value = form$.value.$vueform.services.axios;
  });
  return {
    request,
    axios: axios2,
    uploading
  };
};
function checkFileType(file6, accept) {
  if (!accept) {
    return true;
  }
  if (!isArray_1(accept)) {
    accept = accept.split(",");
    each(accept, (one, i) => {
      accept[i] = one.trim();
    });
  }
  return some_1(accept, (a) => {
    var universal = a.match(/^([^\/]+)\/\*$/);
    if (universal) {
      return !!new RegExp("^".concat(universal[1], "/")).exec(file6.type);
    } else if (a == file6.type) {
      return true;
    } else if (a == ".".concat(file6.name.split(".").pop())) {
      return true;
    }
    return false;
  });
}
var base$p = function base52(props, context, dependencies2) {
  var {
    accept,
    auto
  } = toRefs(props);
  var update = dependencies2.update;
  var isDisabled = dependencies2.isDisabled;
  var uploadTemp = dependencies2.uploadTemp;
  var canDrop = computed(() => {
    var div = document.createElement("div");
    return ("draggable" in div || /* istanbul ignore next: failsafe only, can not influence div from outside */
    "ondragstart" in div && "ondrop" in div) && "FormData" in window && "FileReader" in window;
  });
  var handleDrop = (e2) => {
    if (isDisabled.value) {
      return;
    }
    var file6 = e2.dataTransfer.files[0];
    if (!checkFileType(file6, accept.value)) {
      return;
    }
    update(file6 || /* istanbul ignore next: failsafe only */
    null);
    if (auto.value) {
      uploadTemp();
    }
    file6.value = null;
  };
  return {
    canDrop,
    handleDrop
  };
};
var multifile$3 = function multifile2(props, context, dependencies2) {
  var {
    accept
  } = toRefs(props);
  var {
    canDrop
  } = base$p(props, context, dependencies2);
  var add2 = dependencies2.add;
  var isDisabled = dependencies2.isDisabled;
  var isObject4 = dependencies2.isObject;
  var storeFileName = dependencies2.storeFileName;
  var handleDrop = (e2) => {
    if (!e2.dataTransfer || !e2.dataTransfer.files || e2.dataTransfer.files.length == 0 || isDisabled.value) {
      return;
    }
    each(e2.dataTransfer.files, (file6) => {
      if (!checkFileType(file6, accept.value)) {
        return;
      }
      add2(isObject4.value ? {
        [storeFileName.value]: file6
      } : file6);
    });
  };
  return {
    canDrop,
    handleDrop
  };
};
var base$o = function base53(props, context, dependencies2) {
  var removing = ref(false);
  return {
    removing
  };
};
var base$n = function base54(props, context, dependencies2) {
  var fire = dependencies2.fire;
  dependencies2.listeners;
  var handleError = (error) => {
    fire("error", error);
  };
  return {
    handleError
  };
};
var FileElement = {
  name: "FileElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "remove", "error", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "file",
      private: true
    },
    default: {
      required: false,
      type: [String, Object],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    onRemove: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onError: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    view: {
      type: [String],
      required: false,
      default: "file"
    },
    drop: {
      required: false,
      type: [Boolean],
      default: false
    },
    accept: {
      required: false,
      type: [String, Array],
      default: null
    },
    clickable: {
      required: false,
      type: [Boolean],
      default: true
    },
    url: {
      required: false,
      type: [String, Boolean],
      default: "/"
    },
    previewUrl: {
      required: false,
      type: [String],
      default: void 0
    },
    auto: {
      required: false,
      type: [Boolean],
      default: true
    },
    urls: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    methods: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    uploadTempEndpoint: {
      required: false,
      type: [Object, String, Function, Boolean, Promise],
      default: void 0,
      "@default": "config.endpoints.uploadTempFile"
    },
    removeTempEndpoint: {
      required: false,
      type: [Object, String, Function, Boolean, Promise],
      default: void 0,
      "@default": "config.endpoints.removeTempFile"
    },
    removeEndpoint: {
      required: false,
      type: [Object, String, Function, Boolean, Promise],
      default: void 0,
      "@default": "config.endpoints.removeFile"
    },
    params: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    softRemove: {
      required: false,
      type: [Boolean],
      default: false
    },
    embed: {
      type: [Boolean],
      required: false,
      default: false,
      private: true
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$o, base$U, base$1c, file$3, base$q, base$C, base$14, base$L, file$1, base$I, file4, base$n, base$r, base$p, base$$, file$2, base$Z, base$Y, base$1a, base$_, base$X, file$4, base$F, base$T];
    context.slots = ["label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$m = function base55(props, context, dependencies2) {
  var model = dependencies2.model;
  var handleInput = (e2) => {
    model.value = e2.target.value;
  };
  return {
    handleInput
  };
};
var phone$1 = function phone(props, context, dependencies2) {
  var {
    model,
    input,
    el$
  } = dependencies2;
  var handleInput = (e2) => {
    if (el$.value.maskPluginInstalled) {
      model.value = e2.target.value;
      return;
    }
    var startsWithPlus = e2.target.value.startsWith("+");
    var value = e2.target.value.substr(startsWithPlus ? 1 : 0);
    var numbers = value.match(/\d+/g) || [];
    if (numbers.length || startsWithPlus) {
      value = "+";
    }
    value += numbers.join("");
    input.value.value = value;
    model.value = value;
  };
  return {
    handleInput
  };
};
var GenericElement = {
  register: false,
  name: "GenericElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "",
      private: true
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    default: {
      required: false,
      type: [String, Number, Object],
      default: void 0
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, generic, base$U, base$1c, base$P, text$1, base$14, text$2, base$L, base$I, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$m, base$s, base$R, base$F, base$T];
    context.slots = ["label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$l = function base56(props, context, dependencies2) {
  var children$Array = ref([]);
  var children$ = computed(() => {
    var children$2 = {};
    children$Array.value.forEach((e$) => {
      children$2[e$.name] = e$;
    });
    return children$2;
  });
  return {
    children$Array,
    children$
  };
};
var object7 = function object8(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var schemaName = options.schemaName || "schema";
  var {
    [schemaName]: schema
  } = toRefs(props);
  var {
    children$Array,
    children$
  } = base$l();
  var children = computed(() => {
    return schema.value;
  });
  if (schema) {
    watch(schema, (newValue) => {
      var newChildren$Array = [];
      each(newValue, (child, name2) => {
        newChildren$Array.push(children$Array.value[children$Array.value.map((e$) => normalize(e$.name)).indexOf(normalize(name2))]);
      });
      children$Array.value = newChildren$Array;
    }, {
      flush: "post",
      deep: true
    });
  }
  return {
    children,
    children$Array,
    children$
  };
};
var group6 = object7;
var GroupElement = {
  name: "GroupElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "group",
      private: true
    },
    default: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    schema: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, group$6, base$U, object$5, base$1c, group$7, group6, group$2, base$$, group$3, group$5, base$12, group$8, base$Z, base$Y, base$1a, base$_, base$X, group$1, base$R, group$4, base$T];
    context.slots = ["label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var HiddenElement = {
  name: "HiddenElement",
  mixins: [BaseElement, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "hidden",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Object],
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    meta: {
      required: false,
      type: [Boolean],
      default: false
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$M, base$O, base$K, base$J, base$U, base$Y, base$1c, base$P, base$C, base$14, base$D, base$L, base$I, base$B, base$F, base$T];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
function ownKeys(object9, enumerableOnly) {
  var keys3 = Object.keys(object9);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object9);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object9, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.2";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name2, state) {
  if (el && name2) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name2);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name2 + " ", " ");
      el.className = (className + (state ? " " + name2 : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list8 = ctx.getElementsByTagName(tagName), i = 0, n2 = list8.length;
    if (iterator) {
      for (; i < n2; i++) {
        iterator(list8[i], i);
      }
    }
    return list8;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent2 = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent2) {
    var parentSideVal = getRect(parent2)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent2;
    if (parent2 === getWindowScrollingElement())
      break;
    parent2 = getParentAutoScrollElement(parent2, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i = 0, children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el, selector) {
  var last2 = el.lastElementChild;
  while (last2 && (last2 === Sortable.ghost || css(last2, "display") === "none" || selector && !matches(last2, selector))) {
    last2 = last2.previousElementSibling;
  }
  return last2 || null;
}
function index$1(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key])
        return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend3(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle2(callback57, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback57.call(_this, args[0]);
      } else {
        callback57.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone2(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function getChildContainingRectFromElement(container, options, ghostEl2) {
  var rect = {};
  Array.from(container.children).forEach(function(child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl2)
      return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback57) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback57 === "function")
          callback57();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time2 = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time2 = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time2) {
            time2 = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time2);
        }
        if (time2) {
          animating = true;
          animationTime = Math.max(animationTime, time2);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time2);
          target.thisAnimationDuration = time2;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback57 === "function")
          callback57();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback57 === "function")
            callback57();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration2) {
      if (duration2) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration2 + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration2);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults3 = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults3) {
      if (defaults3.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults3[option2];
      }
    }
    plugins.forEach(function(p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults4, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault)
        return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults4, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name2, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name2));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name2, value) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name2] === "function") {
        modifiedValue = plugin.optionListeners[name2].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name2 = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name2.charAt(0).toUpperCase() + name2.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name2, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name2, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name2, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name2) {
      _dispatchEvent({
        sortable,
        name: name2,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl;
var parentEl;
var ghostEl;
var rootEl;
var nextEl;
var lastDownEl;
var cloneEl;
var cloneHidden;
var oldIndex;
var newIndex;
var oldDraggableIndex;
var newDraggableIndex;
var activeGroup;
var putSortable;
var awaitingDragStarted = false;
var ignoreNextClick = false;
var sortables = [];
var tapEvt;
var touchEvt;
var lastDx;
var lastDy;
var tapDistanceLeft;
var tapDistanceTop;
var moved;
var lastTarget;
var lastDirection;
var pastFirstInvertThresh = false;
var isCircumstantialInvert = false;
var targetMoveDistance;
var ghostRelativeParent;
var ghostRelativeParentInitialScroll = [];
var _silent = false;
var savedInputChecked = [];
var documentExists = typeof document !== "undefined";
var PositionGhostAbsolutely = IOS;
var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
var supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}();
var _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
};
var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
};
var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
};
var _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to2, from2, dragEl2, evt) {
      var sameGroup = to2.options.group.name && from2.options.group.name && to2.options.group.name === from2.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to2, from2, dragEl2, evt), pull)(to2, from2, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to2 : from2).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group7 = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group7.name = originalGroup.name;
  group7.checkPull = toFn(originalGroup.pull, true);
  group7.checkPut = toFn(originalGroup.put);
  group7.revertClone = originalGroup.revertClone;
  options.group = group7;
};
var _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
};
var _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults4 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults4);
  for (var name2 in defaults4) {
    !(name2 in options) && (options[name2] = defaults4[name2]);
  }
  _prepareGroup(options);
  for (var fn in this) {
    if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
      this[fn] = this[fn].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el, "pointerdown", this._onTapStart);
  } else {
    on(el, "mousedown", this._onTapStart);
    on(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, "dragover", this);
    on(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter3 = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index$1(target);
    oldDraggableIndex = index$1(target, options.draggable);
    if (typeof filter3 === "function") {
      if (filter3.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter3) {
      filter3 = filter3.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter3) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mouseup", _this._onDrop);
      on(ownerDocument, "touchend", _this._onDrop);
      on(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on(ownerDocument, "touchend", _this._disableDelayedDrag);
        on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e2) {
    var touch = e2.touches ? e2.touches[0] : e2;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent2 = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent2)
          break;
        parent2 = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent2) {
        do {
          if (parent2[expando]) {
            var inserted = void 0;
            inserted = parent2[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent2
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent2;
        } while (parent2 = parent2.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone2(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group7 = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group7, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name2, extra) {
      pluginEvent2(name2, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed: completed2,
        onMove: function onMove(target2, after3) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after3);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed2(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed2(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group7.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed2(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed2(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el;
          changed();
          return completed2(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed2(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed2(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index$1(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed2(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after2 = false;
        after2 = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after2);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after2 = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after2 && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after2 ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed2(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed2(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray3() {
    var order = [], el, children = this.el.children, i = 0, n2 = children.length, options = this.options;
    for (; i < n2; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i) {
      var el = rootEl2.children[i];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name2, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name2];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name2, value);
      if (typeof modifiedValue !== "undefined") {
        options[name2] = modifiedValue;
      } else {
        options[name2] = value;
      }
      if (name2 === "group") {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index$1(dragEl) < index$1(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root2) {
  savedInputChecked.length = 0;
  var inputs = root2.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend3,
  throttle: throttle2,
  closest,
  toggleClass,
  clone: clone2,
  index: index$1,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element2) {
  return element2[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [];
var scrollEl;
var scrollRootEl;
var scrolling = false;
var lastAutoScrollX;
var lastAutoScrollY;
var touchEvt$1;
var pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle2(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval((function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }).bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
var base$k = function base57(props, context, dependencies2, options) {
  var {
    sort: sort2
  } = toRefs(props);
  var isDisabled = dependencies2.isDisabled;
  var fire = dependencies2.fire;
  var refreshOrderStore = dependencies2.refreshOrderStore;
  var value = dependencies2.value;
  var sorting = dependencies2.sorting;
  var length = dependencies2.length;
  var path = dependencies2.path;
  var children$Array = dependencies2.children$Array;
  var list8 = ref(null);
  var sortable = ref(null);
  var isSortable = computed(() => {
    return sort2.value && !isDisabled.value && length.value && value.value[0] !== void 0;
  });
  var initSortable = () => {
    sortable.value = new Sortable(list8.value, {
      handle: "[data-handle]",
      onStart: (
        /* istanbul ignore next: can not imitate dragging */
        () => {
          sorting.value = true;
        }
      ),
      onEnd: handleSort
    });
  };
  var destroySortable = () => {
    var _sortable$value;
    (_sortable$value = sortable.value) === null || _sortable$value === void 0 || _sortable$value.destroy();
    sortable.value = null;
  };
  var handleSort = (_ref) => {
    var {
      oldIndex: oldIndex2,
      newIndex: newIndex2,
      item
    } = _ref;
    sorting.value = false;
    if (oldIndex2 === newIndex2 || isDisabled.value) {
      return;
    }
    list8.value.children[newIndex2].remove();
    list8.value.insertBefore(item, list8.value.children[oldIndex2]);
    var valueClone = cloneDeep_1(value.value);
    valueClone.splice(newIndex2, 0, valueClone.splice(oldIndex2, 1)[0]);
    value.value = valueClone;
    refreshOrderStore(value.value);
    fire("sort", value.value, oldIndex2, newIndex2, children$Array.value[newIndex2]);
  };
  watch(isSortable, (n2, o2) => {
    if (n2 === true && o2 === false) {
      initSortable();
    } else if (n2 === false && o2 === true) {
      destroySortable();
    }
  }, {
    immediate: false,
    flush: "post"
  });
  onMounted(() => {
    if (isSortable.value) {
      initSortable();
    }
  });
  watch(length, (n2) => {
    var _sortable$value2;
    if (!isSortable.value) {
      return;
    }
    destroySortable();
    initSortable();
    (_sortable$value2 = sortable.value) === null || _sortable$value2 === void 0 || _sortable$value2.sort(Array.from(Array(n2).keys()).reduce((a, b, i) => {
      a.push("".concat(path.value, "-").concat(i));
      return a;
    }, []));
  }, {
    flush: "post"
  });
  return {
    list: list8,
    sortable,
    isSortable,
    handleSort,
    initSortable,
    destroySortable
  };
};
var base$j = function base58(props, context, dependencies2) {
  var sorting = ref(false);
  return {
    sorting
  };
};
var base$i = function base59(props, context, dependencies2, options) {
  var {
    storeOrder,
    orderBy,
    order
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var orderFrom = ref(form$.value.$vueform.config.orderFrom);
  var refreshOrderStore = (value2) => {
    if (storeOrder.value) {
      each(value2, (val, index2) => {
        val[storeOrder.value] = order.value && order.value.toUpperCase() === "DESC" ? value2.length - index2 - (orderFrom.value == 0 ? 1 : 0) : parseInt(index2) + orderFrom.value;
      });
    }
    return value2;
  };
  var orderByName = computed(() => {
    return orderBy.value || storeOrder.value;
  });
  watch(storeOrder, (n2, o2) => {
    if (n2) {
      refreshOrderStore(value.value);
    } else {
      each(value.value, (val, index2) => {
        val[o2] = null;
      });
    }
  }, {
    immediate: false
  });
  return {
    refreshOrderStore,
    orderByName
  };
};
var multifile$2 = function multifile3(props, context, dependencies2, options) {
  var {
    storeOrder,
    orderBy
  } = toRefs(props);
  var {
    refreshOrderStore
  } = base$i(props, context, dependencies2);
  var orderByName = computed(() => {
    return orderBy.value || storeOrder.value;
  });
  return {
    refreshOrderStore,
    orderByName
  };
};
var base$h = function base60(props, context, dependencies2) {
  var {
    object: object9,
    element: element2
  } = toRefs(props);
  var prototype3 = computed(() => {
    return isObject4.value ? Object.assign({}, object9.value, {
      type: "object"
    }) : element2.value || {};
  });
  var isObject4 = computed(() => {
    return !!object9.value;
  });
  return {
    prototype: prototype3,
    isObject: isObject4
  };
};
var multifile$1 = function multifile4(props, context, dependencies2) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    auto,
    object: object9,
    file: file6,
    fields,
    storeFile,
    storeOrder,
    view,
    clickable,
    url: url2,
    previewUrl,
    uploadTempEndpoint,
    removeTempEndpoint,
    removeEndpoint,
    params,
    softRemove
  } = toRefs(props);
  var isDisabled = dependencies2.isDisabled;
  var type = computed(() => {
    return options.type || "file";
  });
  var storeFileName = computed(() => {
    if (storeFile.value) {
      return storeFile.value;
    }
    return object9.value || keys_1(fields.value).length || storeOrder.value ? "file" : null;
  });
  var isObject4 = computed(() => {
    return !!object9.value || !!storeOrder.value || !!keys_1(fields.value).length;
  });
  var prototype3 = computed(() => {
    var fileSchema = {
      type: type.value,
      auto: auto.value,
      view: view.value,
      layout: view.value === "gallery" ? "ElementLayoutInline" : "ElementLayout",
      disabled: isDisabled.value,
      clickable: clickable.value,
      url: url2.value,
      previewUrl: previewUrl.value,
      uploadTempEndpoint: uploadTempEndpoint.value,
      removeTempEndpoint: removeTempEndpoint.value,
      removeEndpoint: removeEndpoint.value,
      params: params.value,
      softRemove: softRemove.value
    };
    if (!isObject4.value) {
      return Object.assign({}, fileSchema, file6.value);
    }
    return {
      type: "object",
      schema: Object.assign(
        {},
        // File
        {
          [storeFileName.value]: Object.assign({}, fileSchema, {
            embed: true
          }, file6.value)
        },
        // Order
        storeOrder.value ? {
          [storeOrder.value]: {
            type: "hidden",
            meta: true
          }
        } : {},
        // Other fields
        fields.value
      )
    };
  });
  return {
    storeFileName,
    isObject: isObject4,
    prototype: prototype3
  };
};
var base$g = function base61(props, context, dependencies2) {
  var {
    controls,
    sort: sort2,
    min: min4,
    max: max3,
    addText
  } = toRefs(props);
  var isDisabled = dependencies2.isDisabled;
  var value = dependencies2.value;
  var form$ = dependencies2.form$;
  var hasAdd = computed(() => {
    return !isDisabled.value && (controls.value.add || controls.value.add === void 0) && (max3.value === -1 || max3.value > value.value.length);
  });
  var hasRemove = computed(() => {
    return !isDisabled.value && (controls.value.remove || controls.value.remove === void 0) && (min4.value === -1 || min4.value < value.value.length);
  });
  var hasSort = computed(() => {
    return !isDisabled.value && (controls.value.sort || controls.value.sort === void 0) && sort2.value;
  });
  var addLabel = computed(() => {
    return addText.value || form$.value.translations.vueform.elements.list.add;
  });
  return {
    hasAdd,
    hasRemove,
    hasSort,
    addLabel
  };
};
var multifile5 = function multifile6(props, context, dependencies2) {
  var {
    controls,
    sort: sort2
  } = toRefs(props);
  var isDisabled = dependencies2.isDisabled;
  var hasUploading = dependencies2.hasUploading;
  var hasAdd = computed(() => {
    return controls.value.add || controls.value.add === void 0;
  });
  var hasRemove = computed(() => {
    return !isDisabled.value && (controls.value.remove || controls.value.remove === void 0) && !hasUploading.value;
  });
  var hasSort = computed(() => {
    return !isDisabled.value && (controls.value.sort || controls.value.sort === void 0) && sort2.value && !hasUploading.value;
  });
  return {
    hasAdd,
    hasRemove,
    hasSort
  };
};
var ListElement = {
  name: "ListElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "add", "remove", "sort", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "list",
      private: true
    },
    default: {
      required: false,
      type: [Array],
      default: void 0
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    onAdd: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onRemove: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSort: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    element: {
      required: false,
      type: [Object],
      default: null
    },
    object: {
      required: false,
      type: [Object],
      default: null
    },
    initial: {
      required: false,
      type: [Number],
      default: 1
    },
    min: {
      required: false,
      type: [Number],
      default: -1
    },
    max: {
      required: false,
      type: [Number],
      default: -1
    },
    addText: {
      required: false,
      type: [String],
      default: null,
      "@default": "locale.elements.list.add"
    },
    sort: {
      required: false,
      type: [Boolean],
      default: false
    },
    controls: {
      required: false,
      type: [Object],
      default: () => ({
        add: true,
        remove: true,
        sort: true
      })
    },
    storeOrder: {
      required: false,
      type: [String],
      default: null
    },
    order: {
      required: false,
      type: [String],
      default: null
    },
    orderBy: {
      required: false,
      type: [String],
      default: null
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$O, base$U, base$S, array$1, base$h, base$l, base$j, base$i, base$1c, list$4, base$C, base$$, base$J, base$12, list$5, list$1, list$3, base$g, array2, base$_, base$Z, base$Y, base$1a, base$X, list6, base$k, base$R, list$2, base$T];
    context.slots = ["label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$f = function base62(props, context, dependencies2) {
  var options_ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  var {
    provider,
    extendOptions
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var value = dependencies2.value;
  var clear = dependencies2.clear;
  var input = dependencies2.input;
  var inputElement = () => {
    return options_.input ? options_.input.value : input.value;
  };
  var locationService = ref(null);
  var location6 = ref({});
  var locationProvider = computed(() => {
    return provider.value || form$.value.$vueform.config.locationProvider;
  });
  var defaultOptions = computed(() => {
    var providers = {
      google: {
        fields: ["geometry", "formatted_address", "address_components"]
      },
      algolia: {
        type: "address",
        appId: form$.value.$vueform.config.services.algolia.app_id,
        apiKey: form$.value.$vueform.config.services.algolia.api_key,
        templates: options_.templates || {}
      }
    };
    return providers[locationProvider.value];
  });
  var providerOptions = computed(() => {
    return Object.assign({}, defaultOptions.value, extendOptions.value || /* istanbul ignore next: failsafe only */
    {});
  });
  var handleAddressChange = (data, raw) => {
    if (options_.handleAddressChange) {
      options_.handleAddressChange(data, raw);
      return;
    }
    location6.value = raw;
    value.value = data;
  };
  var handleLocationBlur = () => {
    if (inputElement().value.length) {
      inputElement().value = value.value.formatted_address;
    } else {
      clear();
    }
  };
  var initLocationService = () => {
    if (locationService.value) {
      locationService.value.destroy();
    }
    locationService.value = new form$.value.$vueform.services.location[locationProvider.value]();
    locationService.value.init(inputElement(), handleAddressChange, providerOptions.value);
  };
  watch([locationProvider, providerOptions], () => {
    initLocationService();
  }, {
    deep: true,
    immediate: false
  });
  onMounted(() => {
    initLocationService();
  });
  return {
    locationService,
    location: location6,
    defaultOptions,
    providerOptions,
    handleAddressChange,
    handleLocationBlur,
    initLocationService
  };
};
var LocationElement = {
  name: "LocationElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "location",
      private: true
    },
    default: {
      required: false,
      type: [Object],
      default: () => ({
        country: null,
        country_code: null,
        state: null,
        state_code: null,
        city: null,
        zip: null,
        address: null,
        formatted_address: null,
        lat: null,
        lng: null
      })
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean],
      default: false
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    provider: {
      required: false,
      type: [String],
      default: "google"
    },
    displayKey: {
      required: false,
      type: [String],
      default: "formatted_address"
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, location$2, base$U, base$G, base$1c, base$P, base$w, base$C, base$L, location4, base$14, base$I, base$B, base$f, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$s, base$R, location$1, base$T, base$t];
    context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, location$3(props, context));
  }
};
var base$e = function base63(props, context, dependencies2) {
  var isDisabled = dependencies2.isDisabled;
  var add2 = dependencies2.add;
  var input = dependencies2.input;
  var isObject4 = dependencies2.isObject;
  var storeFileName = dependencies2.storeFileName;
  var children$ = dependencies2.children$;
  var preparing = computed(() => {
    return some_1(children$.value, {
      available: true,
      preparing: true
    });
  });
  var hasUploading = computed(() => {
    return some_1(children$.value, {
      uploading: true
    });
  });
  var handleChange = (e2) => {
    if (!e2.target || !e2.target.files || e2.target.files.length == 0 || isDisabled.value) {
      return;
    }
    each(e2.target.files, (file6) => {
      add2(isObject4.value ? {
        [storeFileName.value]: file6
      } : file6);
    });
    input.value.value = "";
  };
  var handleClick = () => {
    if (isDisabled.value) {
      return;
    }
    input.value.click();
  };
  return {
    preparing,
    hasUploading,
    handleChange,
    handleClick
  };
};
var MultifileElement = {
  name: "MultifileElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "add", "remove", "sort", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "multifile",
      private: true
    },
    default: {
      required: false,
      type: [Array],
      default: () => []
    },
    initial: {
      required: false,
      type: [Number],
      default: 0,
      private: true
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    onAdd: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onRemove: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSort: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    view: {
      type: [String],
      required: false,
      default: "file"
    },
    drop: {
      required: false,
      type: [Boolean],
      default: false
    },
    sort: {
      required: false,
      type: [Boolean],
      default: false
    },
    controls: {
      required: false,
      type: [Object],
      default: () => ({
        add: true,
        remove: true,
        sort: true
      })
    },
    object: {
      required: false,
      type: [Boolean],
      default: null
    },
    storeFile: {
      required: false,
      type: [String],
      default: "file"
    },
    fields: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    storeOrder: {
      required: false,
      type: [String],
      default: null
    },
    order: {
      required: false,
      type: [String],
      default: null
    },
    orderBy: {
      required: false,
      type: [String],
      default: null
    },
    file: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    accept: {
      required: false,
      type: [String, Array],
      default: null
    },
    clickable: {
      required: false,
      type: [Boolean],
      default: true
    },
    url: {
      required: false,
      type: [String, Boolean],
      default: "/"
    },
    previewUrl: {
      required: false,
      type: [String],
      default: void 0
    },
    auto: {
      required: false,
      type: [Boolean],
      default: true
    },
    uploadTempEndpoint: {
      required: false,
      type: [Object, String, Function, Boolean, Promise],
      default: void 0,
      "@default": "config.endpoints.uploadTempFile"
    },
    removeTempEndpoint: {
      required: false,
      type: [Object, String, Function, Boolean, Promise],
      default: void 0,
      "@default": "config.endpoints.removeTempFile"
    },
    removeEndpoint: {
      required: false,
      type: [Object, String, Function, Boolean, Promise],
      default: void 0,
      "@default": "config.endpoints.removeFile"
    },
    params: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    softRemove: {
      required: false,
      type: [Boolean],
      default: false
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$O, base$S, array$1, base$l, base$M, base$j, multifile$1, base$U, base$1c, list$4, base$C, base$$, base$J, list$1, base$L, array2, base$12, base$14, base$_, base$Z, base$Y, base$X, multifile$2, multifile$4, base$e, multifile5, multifile$3, base$1a, base$k, base$R, multifile$5, base$T];
    context.slots = ["label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$d = function base64(props, context, dependencies2) {
  var fire = dependencies2.fire;
  var el$ = dependencies2.el$;
  var handleSelect = (option2) => {
    fire("select", option2, el$.value);
  };
  var handleDeselect = (option2) => {
    fire("deselect", option2, el$.value);
  };
  var handleSearchChange = (searchQuery) => {
    fire("search-change", searchQuery, el$.value);
  };
  var handleOpen = () => {
    fire("open", el$.value);
  };
  var handleClose = () => {
    fire("close", el$.value);
  };
  var handleClear = () => {
    fire("clear", el$.value);
  };
  var handlePaste = (e2) => {
    fire("paste", e2, el$.value);
  };
  var handleTag = (searchQuery) => {
  };
  return {
    handleSelect,
    handleDeselect,
    handleSearchChange,
    handleOpen,
    handleClose,
    handleClear,
    handlePaste,
    handleTag
  };
};
function spliceMultiple(array4, indexes) {
  indexes.sort();
  for (var i = indexes.length - 1; i >= 0; i--) {
    array4.splice(indexes[i], 1);
  }
  return array4;
}
var base$c = function base65(props, context, dependencies2) {
  var value = dependencies2.value;
  var inValue = (option2) => {
    return value.value.indexOf(option2) !== -1;
  };
  var select6 = (options) => {
    if (!isArray_1(options)) {
      options = [options];
    }
    var val = clone_1(value.value);
    each(options, (option2) => {
      if (inValue(normalize(option2))) {
        return;
      }
      val.push(option2);
    });
    value.value = val;
  };
  var deselect = (options) => {
    if (!isArray_1(options)) {
      options = [options];
    }
    var val = clone_1(value.value);
    var indexes = [];
    each(options, (option2) => {
      var i = value.value.indexOf(option2);
      if (i === -1 || indexes.indexOf(i) !== -1) {
        return;
      }
      indexes.push(i);
    });
    value.value = spliceMultiple(val, indexes);
  };
  return {
    select: select6,
    deselect
  };
};
var MultiselectElement = {
  name: "MultiselectElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "select", "deselect", "search-change", "open", "close", "clear", "paste", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "multiselect",
      private: true
    },
    default: {
      required: false,
      type: [Array],
      default: () => []
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null,
      native: false
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    onSelect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onDeselect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSearchChange: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onOpen: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClose: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClear: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onPaste: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    native: {
      required: false,
      type: [Boolean],
      default: true
    },
    items: {
      required: false,
      type: [Object, Array, Function, String],
      localized: true,
      default: () => ({})
    },
    labelProp: {
      type: [String],
      required: false,
      default: "label",
      native: false
    },
    valueProp: {
      type: [String],
      required: false,
      default: "value",
      native: false
    },
    dataKey: {
      type: [String],
      required: false,
      default: void 0
    },
    searchParam: {
      type: [String],
      required: false,
      default: "query"
    },
    search: {
      required: false,
      type: [Boolean],
      default: false,
      native: false
    },
    trackBy: {
      type: [String, Array],
      required: false,
      default: "label",
      native: false
    },
    strict: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    multipleLabel: {
      type: [Function],
      required: false,
      native: false
    },
    multipleLabelSingle: {
      type: [String],
      required: false,
      native: false,
      "@default": "locale.vueform.multiselect.multipleLabelOne"
    },
    multipleLabelMultiple: {
      type: [String],
      required: false,
      native: false,
      "@default": "locale.vueform.multiselect.multipleLabelMore"
    },
    create: {
      required: false,
      type: [Boolean],
      default: false,
      native: false
    },
    appendNewOption: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    addOptionOn: {
      type: [Array],
      required: false,
      default: () => ["enter"],
      native: false
    },
    object: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    limit: {
      type: [Number],
      required: false,
      default: -1,
      native: false
    },
    max: {
      type: [Number],
      required: false,
      default: -1,
      native: false
    },
    groups: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    groupLabel: {
      type: [String],
      required: false,
      default: "label",
      native: false
    },
    groupOptions: {
      type: [String],
      required: false,
      default: "items",
      native: false
    },
    groupHideEmpty: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    groupSelect: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    openDirection: {
      type: [String],
      required: false,
      default: "bottom",
      native: false
    },
    appendToBody: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    appendTo: {
      type: [String],
      required: false,
      default: void 0,
      native: false
    },
    canClear: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    clearOnSelect: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    closeOnSelect: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    closeOnDeselect: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    clearOnRefetch: {
      type: [Boolean],
      required: false,
      default: true
    },
    delay: {
      type: [Number],
      required: false,
      default: -1,
      native: false
    },
    minChars: {
      type: [Number],
      required: false,
      default: 0,
      native: false
    },
    resolveOnLoad: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    filterResults: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    clearOnSearch: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    hideSelected: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    caret: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    loading: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    noOptionsText: {
      type: [String, Object],
      required: false,
      default: void 0,
      "@default": "locale.multiselect.noOptions",
      localized: true,
      native: false
    },
    noResultsText: {
      type: [String, Object],
      required: false,
      default: void 0,
      "@default": "locale.multiselect.noResults",
      localized: true,
      native: false
    },
    autocomplete: {
      type: [String],
      required: false,
      native: false
    },
    inputType: {
      type: [String],
      required: false,
      default: "text",
      native: false
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, array$1, base$U, base$G, base$1c, multiselect$4, base$C, base$D, base$H, multiselect$1, base$L, multiselect$2, base$14, array2, multiselect$3, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$d, base$c, multiselect2, base$R, base$F, base$T, base$t];
    context.slots = ["option", "multiple-label", "placeholder", "group-label", "before-list", "after-list", "no-results", "no-options", "caret", "spinner", "clear", "label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var ObjectElement = {
  name: "ObjectElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "remove", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "object",
      private: true
    },
    default: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    schema: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    embed: {
      required: false,
      type: [Boolean],
      default: false
    },
    onRemove: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$O, base$U, object$5, base$1c, object$7, object$2, object$6, base$$, object7, base$12, object$8, object$3, base$Z, base$Y, base$1a, base$_, base$X, object$1, base$R, object$4, base$T];
    context.slots = ["label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$b = function base66(props, context, dependencies2) {
  var fire = dependencies2.fire;
  var el$ = dependencies2.el$;
  var handleBlur = () => {
    fire("blur", el$.value);
  };
  return {
    handleBlur
  };
};
var us = "{+}0 (000) 000-0000";
var countryPhones = [
  {
    // "country": "Afghanistan",
    "c": "AF",
    "n": "+93",
    "p": 0,
    "m": [
      ["93", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "Albania",
    "c": "AL",
    "n": "+355",
    "p": 1,
    "m": [
      ["3554", "{+}000 0 000 0000"],
      ["355", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Algeria",
    "c": "DZ",
    "n": "+213",
    "p": 2,
    "m": [
      ["2131", "{+}000 0 000 0000"],
      ["2132", "{+}000 0 000 0000"],
      ["2133", "{+}000 0 000 0000"],
      ["2134", "{+}000 0 000 0000"],
      ["213", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "American Samoa",
    "c": "AS",
    "n": "+1",
    "p": 3,
    "m": [
      ["1684", us]
    ]
  },
  {
    // "country": "Andorra",
    "c": "AD",
    "n": "+376",
    "p": 4,
    "m": [
      ["376", "{+}000 000 000"]
    ]
  },
  {
    // "country": "Angola",
    "c": "AO",
    "n": "+244",
    "p": 5,
    "m": [
      ["2449", "{+}000 000 000 0000"],
      ["244", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Anguilla",
    "c": "AI",
    "n": "+1",
    "p": 6,
    "m": [
      ["1264", us]
    ]
  },
  {
    // "country": "Antigua & Barbuda",
    "c": "AG",
    "n": "+1",
    "p": 7,
    "m": [
      ["1268", us]
    ]
  },
  {
    // "country": "Argentina",
    "c": "AR",
    "n": "+54",
    "p": 8,
    "m": [
      ["549", "{+}00 0 000 000 0000"],
      ["54", "{+}00 000 000 0000"]
    ]
  },
  {
    // "country": "Armenia",
    "c": "AM",
    "n": "+374",
    "p": 9,
    "m": [
      ["37493", "{+}000 00 000 000"],
      ["37494", "{+}000 00 000 000"],
      ["37498", "{+}000 00 000 000"],
      ["37477", "{+}000 00 000 000"],
      ["37491", "{+}000 00 000 000"],
      ["37496", "{+}000 00 000 000"],
      ["37499", "{+}000 00 000 000"],
      ["37455", "{+}000 00 000 000"],
      ["37495", "{+}000 00 000 000"],
      ["37441", "{+}000 00 000 000"],
      ["374", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Aruba",
    "c": "AW",
    "n": "+297",
    "p": 10,
    "m": [
      ["297", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Ascension Island",
    "c": "AC",
    "n": "+247",
    "p": 11,
    "m": [
      ["247", "{+}000 0000"]
    ]
  },
  {
    // "country": "Australia",
    "c": "AU",
    "n": "+61",
    "p": 12,
    "m": [
      ["61", "{+}00 0 0000 0000"],
      ["614", "{+}00 000 000 000"]
    ]
  },
  {
    // "country": "Austria",
    "c": "AT",
    "n": "+43",
    "p": 13,
    "m": [
      ["43", "{+}00 0000000[0000]"]
    ]
  },
  {
    // "country": "Azerbaijan",
    "c": "AZ",
    "n": "+994",
    "p": 14,
    "m": [
      ["9944", "{+}000 00 000 000"],
      ["9945", "{+}000 00 000 000"],
      ["9946", "{+}000 00 000 000"],
      ["9947", "{+}000 00 000 000"],
      ["994", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Bahamas",
    "c": "BS",
    "n": "+1",
    "p": 15,
    "m": [
      ["1242", us]
    ]
  },
  {
    // "country": "Bahrain",
    "c": "BH",
    "n": "+973",
    "p": 16,
    "m": [
      ["973", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Bangladesh",
    "c": "BD",
    "n": "+880",
    "p": 17,
    "m": [
      ["8801", "{+}000 00 0000 0000"],
      ["880", "{+}000 00 0000 0000[00]"]
    ]
  },
  {
    // "country": "Barbados",
    "c": "BB",
    "n": "+1",
    "p": 18,
    "m": [
      ["1246", us]
    ]
  },
  {
    // "country": "Belarus",
    "c": "BY",
    "n": "+375",
    "p": 19,
    "m": [
      ["375", "{+}000 000000000[0]"]
    ]
  },
  {
    // "country": "Belgium",
    "c": "BE",
    "n": "+32",
    "p": 20,
    "m": [
      ["324", "{+}00 000 00 00 00"],
      ["32", "{+}00 0 000 00 00"]
    ]
  },
  {
    // "country": "Belize",
    "c": "BZ",
    "n": "+501",
    "p": 21,
    "m": [
      ["501", "{+}000 000-0000"]
    ]
  },
  {
    // "country": "Benin",
    "c": "BJ",
    "n": "+229",
    "p": 22,
    "m": [
      ["229", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Bermuda",
    "c": "BM",
    "n": "+1",
    "p": 23,
    "m": [
      ["1441", us]
    ]
  },
  {
    // "country": "Bhutan",
    "c": "BT",
    "n": "+975",
    "p": 24,
    "m": [
      ["97517", "{+}000 00 000000"],
      ["975", "{+}000 0 00000[0]"]
    ]
  },
  {
    // "country": "Bolivia",
    "c": "BO",
    "n": "+591",
    "p": 25,
    "m": [
      ["5916", "{+}000 000 000 0000"],
      ["5917", "{+}000 000 000 0000"],
      ["591", "{+}000 0 000 0000[0]"]
    ]
  },
  {
    // "country": "Bosnia & Herzegovina",
    "c": "BA",
    "n": "+387",
    "p": 26,
    "m": [
      ["3876", "{+}000 00 000 000"],
      ["387", "{+}000 00 000 000[0]"]
    ]
  },
  {
    // "country": "Botswana",
    "c": "BW",
    "n": "+267",
    "p": 27,
    "m": [
      ["2677", "{+}000 00 000 0000"],
      ["267", "{+}000 000 000000"]
    ]
  },
  {
    // "country": "Brazil",
    "c": "BR",
    "n": "+55",
    "p": 28,
    "m": [
      ["55", "{+}00 00 0000 0000[0]"]
    ]
  },
  {
    // "country": "British Indian Ocean Territory",
    "c": "IO",
    "n": "+246",
    "p": 29,
    "m": [
      ["246", "{+}000 0000"]
    ]
  },
  {
    // "country": "British Virgin Islands",
    "c": "VG",
    "n": "+1",
    "p": 30,
    "m": [
      ["1284", us]
    ]
  },
  {
    // "country": "Brunei",
    "c": "BN",
    "n": "+673",
    "p": 31,
    "m": [
      ["673", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Bulgaria",
    "c": "BG",
    "n": "+359",
    "p": 32,
    "m": [
      ["3598", "{+}000 00 000 0000"],
      ["3599", "{+}000 00 000 0000"],
      ["359", "{+}000 0000000[000]"]
    ]
  },
  {
    // "country": "Burkina Faso",
    "c": "BF",
    "n": "+226",
    "p": 33,
    "m": [
      ["226", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Burundi",
    "c": "BI",
    "n": "+257",
    "p": 34,
    "m": [
      ["257", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Cambodia",
    "c": "KH",
    "n": "+855",
    "p": 35,
    "m": [
      ["855", "{+}000 000000000"]
    ]
  },
  {
    // "country": "Cameroon",
    "c": "CM",
    "n": "+237",
    "p": 36,
    "m": [
      ["237", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Canada",
    "c": "CA",
    "n": "+1",
    "p": 37,
    "m": [
      ["1204", us],
      ["1226", us],
      ["1236", us],
      ["1249", us],
      ["1250", us],
      ["1263", us],
      ["1289", us],
      ["1306", us],
      ["1343", us],
      ["1354", us],
      ["1365", us],
      ["1367", us],
      ["1368", us],
      ["1403", us],
      ["1416", us],
      ["1418", us],
      ["1431", us],
      ["1437", us],
      ["1438", us],
      ["1450", us],
      ["1468", us],
      ["1474", us],
      ["1506", us],
      ["1514", us],
      ["1519", us],
      ["1548", us],
      ["1579", us],
      ["1581", us],
      ["1584", us],
      ["1587", us],
      ["1604", us],
      ["1613", us],
      ["1639", us],
      ["1647", us],
      ["1672", us],
      ["1683", us],
      ["1705", us],
      ["1709", us],
      ["1742", us],
      ["1753", us],
      ["1778", us],
      ["1780", us],
      ["1782", us],
      ["1807", us],
      ["1819", us],
      ["1825", us],
      ["1867", us],
      ["1873", us],
      ["1902", us],
      ["1905", us]
    ]
  },
  {
    // "country": "Cape Verde",
    "c": "CV",
    "n": "+238",
    "p": 38,
    "m": [
      ["238", "{+}000 0000 000"]
    ]
  },
  {
    // "country": "Caribbean Netherlands",
    "c": "BQ",
    "n": "+599",
    "p": 39,
    "m": [
      ["599", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Cayman Islands",
    "c": "KY",
    "n": "+1",
    "p": 40,
    "m": [
      ["1345", us]
    ]
  },
  {
    // "country": "Central African Republic",
    "c": "CF",
    "n": "+236",
    "p": 41,
    "m": [
      ["236", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Chad",
    "c": "TD",
    "n": "+235",
    "p": 42,
    "m": [
      ["235", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Chile",
    "c": "CL",
    "n": "+56",
    "p": 43,
    "m": [
      ["562", "{+}00 0 0000 0000"],
      ["569", "{+}00 0 0000 0000"],
      ["56", "{+}00 00 0000 000[0]"]
    ]
  },
  {
    // "country": "China",
    "c": "CN",
    "n": "+86",
    "p": 44,
    "m": [
      ["8613", "{+}00 000 0000 0000"],
      ["8615", "{+}00 000 0000 0000"],
      ["8618", "{+}00 000 0000 0000"],
      ["86", "{+}00 00 0000 0000"]
    ]
  },
  {
    // "country": "Colombia",
    "c": "CO",
    "n": "+57",
    "p": 45,
    "m": [
      ["573", "{+}00 000 000 0000"],
      ["57", "{+}00 0 000 0000"]
    ]
  },
  {
    // "country": "Comoros",
    "c": "KM",
    "n": "+269",
    "p": 46,
    "m": [
      ["269", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Congo - Brazzaville",
    "c": "CG",
    "n": "+242",
    "p": 47,
    "m": [
      ["242", "{+}000 00 000 000[0]"]
    ]
  },
  {
    // "country": "Congo - Kinshasa",
    "c": "CD",
    "n": "+243",
    "p": 48,
    "m": [
      ["243", "{+}000 00 000 000[0]"]
    ]
  },
  {
    // "country": "Cook Islands",
    "c": "CK",
    "n": "+682",
    "p": 49,
    "m": [
      ["682", "{+}000 00 000"]
    ]
  },
  {
    // "country": "Costa Rica",
    "c": "CR",
    "n": "+506",
    "p": 50,
    "m": [
      ["506", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Cte dIvoire",
    "c": "CI",
    "n": "+225",
    "p": 51,
    "m": [
      ["225", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Croatia",
    "c": "HR",
    "n": "+385",
    "p": 52,
    "m": [
      ["385", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Cuba",
    "c": "CU",
    "n": "+53",
    "p": 53,
    "m": [
      ["535", "{+}00 0 000 0000"],
      ["53", "{+}00 000000[0000]"]
    ]
  },
  {
    // "country": "Curaao",
    "c": "CW",
    "n": "+599",
    "p": 54,
    "m": [
      ["5999", "{+}000 0 000 0000"]
    ]
  },
  {
    // "country": "Cyprus",
    "c": "CY",
    "n": "+357",
    "p": 55,
    "m": [
      ["357", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Czechia",
    "c": "CZ",
    "n": "+420",
    "p": 56,
    "m": [
      ["4206", "{+}000 000 000 000"],
      ["4207", "{+}000 000 000 000"],
      ["420", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Denmark",
    "c": "DK",
    "n": "+45",
    "p": 57,
    "m": [
      ["45", "{+}00 00 00 00 00"]
    ]
  },
  {
    // "country": "Djibouti",
    "c": "DJ",
    "n": "+253",
    "p": 58,
    "m": [
      ["253", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Dominica",
    "c": "DM",
    "n": "+1",
    "p": 59,
    "m": [
      ["1767", us]
    ]
  },
  {
    // "country": "Dominican Republic",
    "c": "DO",
    "n": "+1",
    "p": 60,
    "m": [
      ["1809", us],
      ["1829", us],
      ["1849", us]
    ]
  },
  {
    // "country": "Ecuador",
    "c": "EC",
    "n": "+593",
    "p": 61,
    "m": [
      ["593", "{+}000 00 0000 000"]
    ]
  },
  {
    // "country": "Egypt",
    "c": "EG",
    "n": "+20",
    "p": 62,
    "m": [
      ["2010", "{+}00 000 0000 000"],
      ["2011", "{+}00 000 0000 000"],
      ["2012", "{+}00 000 0000 000"],
      ["2014", "{+}00 000 0000 000"],
      ["2016", "{+}00 000 0000 000"],
      ["202", "{+}00 0 0000 0000"],
      ["203", "{+}00 0 0000 0000"],
      ["20", "{+}00 000 0000 000"]
    ]
  },
  {
    // "country": "El Salvador",
    "c": "SV",
    "n": "+503",
    "p": 63,
    "m": [
      ["503", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Equatorial Guinea",
    "c": "GQ",
    "n": "+240",
    "p": 64,
    "m": [
      ["240", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Eritrea",
    "c": "ER",
    "n": "+291",
    "p": 65,
    "m": [
      ["291", "{+}000 0 000 000"]
    ]
  },
  {
    // "country": "Estonia",
    "c": "EE",
    "n": "+372",
    "p": 66,
    "m": [
      ["372", "{+}000 0000 000[0]"]
    ]
  },
  {
    // "country": "Eswatini",
    "c": "SZ",
    "n": "+268",
    "p": 67,
    "m": [
      ["268", "{+}000 00 00 0000"]
    ]
  },
  {
    // "country": "Ethiopia",
    "c": "ET",
    "n": "+251",
    "p": 68,
    "m": [
      ["2519", "{+}000 000 000 000"],
      ["251", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Falkland Islands (Islas Malvinas)",
    "c": "FK",
    "n": "+500",
    "p": 69,
    "m": [
      ["500", "{+}000 00000"]
    ]
  },
  {
    // "country": "Faroe Islands",
    "c": "FO",
    "n": "+298",
    "p": 70,
    "m": [
      ["298", "{+}000 000 000"]
    ]
  },
  {
    // "country": "Fiji",
    "c": "FJ",
    "n": "+679",
    "p": 71,
    "m": [
      ["679", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Finland",
    "c": "FI",
    "n": "+358",
    "p": 72,
    "m": [
      ["358", "{+}000 0000[0000000]"]
    ]
  },
  {
    // "country": "France",
    "c": "FR",
    "n": "+33",
    "p": 73,
    "m": [
      ["33", "{+}00 000 000 000"]
    ]
  },
  {
    // "country": "French Guiana",
    "c": "GF",
    "n": "+594",
    "p": 74,
    "m": [
      ["594", "{+}000 000 00 00 00"]
    ]
  },
  {
    // "country": "French Polynesia",
    "c": "PF",
    "n": "+689",
    "p": 75,
    "m": [
      ["689", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Gabon",
    "c": "GA",
    "n": "+241",
    "p": 76,
    "m": [
      ["24106", "{+}000 000 00 00 00"],
      ["24107", "{+}000 000 00 00 00"],
      ["241", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Gambia",
    "c": "GM",
    "n": "+220",
    "p": 77,
    "m": [
      ["220", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Georgia",
    "c": "GE",
    "n": "+995",
    "p": 78,
    "m": [
      ["99532", "{+}000 00 000 0000"],
      ["995", "{+}000 000 000 000[0]"]
    ]
  },
  {
    // "country": "Germany",
    "c": "DE",
    "n": "+49",
    "p": 79,
    "m": [
      ["4930", "{+}00 00 0000 0000"],
      ["4989", "{+}00 00 0000 0000"],
      ["49", "{+}00 000 0000 000[0]"]
    ]
  },
  {
    // "country": "Ghana",
    "c": "GH",
    "n": "+233",
    "p": 80,
    "m": [
      ["233", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Gibraltar",
    "c": "GI",
    "n": "+350",
    "p": 81,
    "m": [
      ["350", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Greece",
    "c": "GR",
    "n": "+30",
    "p": 82,
    "m": [
      ["3069", "{+}00 000 0000 000"],
      ["30", "{+}00 000 0000 000[0]"]
    ]
  },
  {
    // "country": "Greenland",
    "c": "GL",
    "n": "+299",
    "p": 83,
    "m": [
      ["299", "{+}000 00 00 00"]
    ]
  },
  {
    // "country": "Grenada",
    "c": "GD",
    "n": "+1",
    "p": 84,
    "m": [
      ["1473", us]
    ]
  },
  {
    // "country": "Guadeloupe",
    "c": "GP",
    "n": "+590",
    "p": 85,
    "m": [
      ["590", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Guam",
    "c": "GU",
    "n": "+1",
    "p": 86,
    "m": [
      ["1671", us]
    ]
  },
  {
    // "country": "Guatemala",
    "c": "GT",
    "n": "+502",
    "p": 87,
    "m": [
      ["502", "{+}000 000 00000"]
    ]
  },
  {
    // "country": "Guinea",
    "c": "GN",
    "n": "+224",
    "p": 88,
    "m": [
      ["224", "{+}000 0000 000[0]"]
    ]
  },
  {
    // "country": "Guinea-Bissau",
    "c": "GW",
    "n": "+245",
    "p": 89,
    "m": [
      ["245", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Guyana",
    "c": "GY",
    "n": "+592",
    "p": 90,
    "m": [
      ["592", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Haiti",
    "c": "HT",
    "n": "+509",
    "p": 91,
    "m": [
      ["509", "{+}000 00 00 0000"]
    ]
  },
  {
    // "country": "Honduras",
    "c": "HN",
    "n": "+504",
    "p": 92,
    "m": [
      ["504", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Hong Kong",
    "c": "HK",
    "n": "+852",
    "p": 93,
    "m": [
      ["852", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Hungary",
    "c": "HU",
    "n": "+36",
    "p": 94,
    "m": [
      ["361", "{+}00 0 000 0000"],
      ["3620", "{+}00 00 000 0000"],
      ["3630", "{+}00 00 000 0000"],
      ["3670", "{+}00 00 000 0000"],
      ["36", "{+}00 00 000 000[0]"]
    ]
  },
  {
    // "country": "Iceland",
    "c": "IS",
    "n": "+354",
    "p": 95,
    "m": [
      ["354", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "India",
    "c": "IN",
    "n": "+91",
    "p": 96,
    "m": [
      ["916", "{+}00 000 000 0000"],
      ["917", "{+}00 000 000 0000"],
      ["918", "{+}00 000 000 0000"],
      ["919", "{+}00 000 000 0000"],
      ["91", "{+}00 00 0000 0000"]
    ]
  },
  {
    // "country": "Indonesia",
    "c": "ID",
    "n": "+62",
    "p": 97,
    "m": [
      ["62361", "{+}00 000 000 000"],
      ["6221", "{+}00 00 0000 0000"],
      ["628", "{+}00 000 0000 0000"],
      ["62", "{+}00 00000[000000]"]
    ]
  },
  {
    // "country": "Iran",
    "c": "IR",
    "n": "+98",
    "p": 98,
    "m": [
      ["98921", "{+}00 00 000 0000"],
      ["98951", "{+}00 00 000 0000"],
      ["989", "{+}00 000 000 0000"],
      ["98", "{+}00 00000000[00]"]
    ]
  },
  {
    // "country": "Iraq",
    "c": "IQ",
    "n": "+964",
    "p": 99,
    "m": [
      ["9641", "{+}000 0 000 0000[0]"],
      ["9647", "{+}000 000 000 0000"],
      ["964", "{+}000 000000[0000]"]
    ]
  },
  {
    // "country": "Ireland",
    "c": "IE",
    "n": "+353",
    "p": 100,
    "m": [
      ["3531", "{+}000 0 000 0000"],
      ["353", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Israel",
    "c": "IL",
    "n": "+972",
    "p": 101,
    "m": [
      ["9725", "{+}000 00 000 0000"],
      ["9727", "{+}000 00 000 0000"],
      ["972", "{+}000 0 000 0000"]
    ]
  },
  {
    // "country": "Italy",
    "c": "IT",
    "n": "+39",
    "p": 102,
    "m": [
      ["393", "{+}00 000 000 0000"],
      ["39", "{+}00 00 0000 0000"]
    ]
  },
  {
    // "country": "Jamaica",
    "c": "JM",
    "n": "+1",
    "p": 103,
    "m": [
      ["1876", us]
    ]
  },
  {
    // "country": "Japan",
    "c": "JP",
    "n": "+81",
    "p": 104,
    "m": [
      ["8170", "{+}00 00 0000 0000"],
      ["8180", "{+}00 00 0000 0000"],
      ["8190", "{+}00 00 0000 0000"],
      ["81", "{+}00 0 0000 0000"]
    ]
  },
  {
    // "country": "Jordan",
    "c": "JO",
    "n": "+962",
    "p": 105,
    "m": [
      ["9627", "{+}000 000 000 000"],
      ["962", "{+}000 0 000 0000"]
    ]
  },
  {
    // "country": "Kazakhstan",
    "c": "KZ",
    "n": "+7",
    "p": 106,
    "m": [
      ["77", "{+}0 000 000 0000"]
    ]
  },
  {
    // "country": "Kenya",
    "c": "KE",
    "n": "+254",
    "p": 107,
    "m": [
      ["2541", "{+}000 000 000 000"],
      ["2547", "{+}000 000 000 000"],
      ["254", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Kiribati",
    "c": "KI",
    "n": "+686",
    "p": 108,
    "m": [
      ["686", "{+}000 00 000"]
    ]
  },
  {
    // "country": "Kosovo",
    "c": "XK",
    "n": "+383",
    "p": 109,
    "m": [
      ["383", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Kuwait",
    "c": "KW",
    "n": "+965",
    "p": 110,
    "m": [
      ["9655", "{+}000 000 00000"],
      ["9656", "{+}000 000 00000"],
      ["9659", "{+}000 000 00000"],
      ["965", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Kyrgyzstan",
    "c": "KG",
    "n": "+996",
    "p": 111,
    "m": [
      ["996", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Laos",
    "c": "LA",
    "n": "+856",
    "p": 112,
    "m": [
      ["85620", "{+}000 00 0000 0000"],
      ["85630", "{+}000 00 0000 0000"],
      ["856", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Latvia",
    "c": "LV",
    "n": "+371",
    "p": 113,
    "m": [
      ["3715", "{+}000 0 00 00000"],
      ["3716", "{+}000 0 00 00000"],
      ["3717", "{+}000 0 00 00000"],
      ["371", "{+}000 000 00 000"]
    ]
  },
  {
    // "country": "Lebanon",
    "c": "LB",
    "n": "+961",
    "p": 114,
    "m": [
      ["96170", "{+}000 00 000 000"],
      ["96171", "{+}000 00 000 000"],
      ["96180", "{+}000 00 000 000"],
      ["96181", "{+}000 00 000 000"],
      ["96190", "{+}000 00 000 000"],
      ["96191", "{+}000 00 000 000"],
      ["961", "{+}000 0 000 000[0]"]
    ]
  },
  {
    // "country": "Lesotho",
    "c": "LS",
    "n": "+266",
    "p": 115,
    "m": [
      ["266", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Liberia",
    "c": "LR",
    "n": "+231",
    "p": 116,
    "m": [
      ["231", "{+}000 000000[0000]"]
    ]
  },
  {
    // "country": "Libya",
    "c": "LY",
    "n": "+218",
    "p": 117,
    "m": [
      ["218", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Liechtenstein",
    "c": "LI",
    "n": "+423",
    "p": 118,
    "m": [
      ["42323", "{+}000 00 00000"],
      ["42375", "{+}000 00 00000"],
      ["423", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Lithuania",
    "c": "LT",
    "n": "+370",
    "p": 119,
    "m": [
      ["370", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Luxembourg",
    "c": "LU",
    "n": "+352",
    "p": 120,
    "m": [
      ["352", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Macao",
    "c": "MO",
    "n": "+853",
    "p": 121,
    "m": [
      ["8536", "{+}000 000 0000[0]"],
      ["853", "{+}000 0000 000[0]"]
    ]
  },
  {
    // "country": "Madagascar",
    "c": "MG",
    "n": "+261",
    "p": 122,
    "m": [
      ["261", "{+}000 00 00 00000"]
    ]
  },
  {
    // "country": "Malawi",
    "c": "MW",
    "n": "+265",
    "p": 123,
    "m": [
      ["265", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Malaysia",
    "c": "MY",
    "n": "+60",
    "p": 124,
    "m": [
      ["60", "{+}00 0000000[000]"]
    ]
  },
  {
    // "country": "Maldives",
    "c": "MV",
    "n": "+960",
    "p": 125,
    "m": [
      ["960", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Mali",
    "c": "ML",
    "n": "+223",
    "p": 126,
    "m": [
      ["223", "{+}000 00 00 0000"]
    ]
  },
  {
    // "country": "Malta",
    "c": "MT",
    "n": "+356",
    "p": 127,
    "m": [
      ["356", "{+}000 0000 000[0]"]
    ]
  },
  {
    // "country": "Marshall Islands",
    "c": "MH",
    "n": "+692",
    "p": 128,
    "m": [
      ["692", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Martinique",
    "c": "MQ",
    "n": "+596",
    "p": 129,
    "m": [
      ["596", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Mauritania",
    "c": "MR",
    "n": "+222",
    "p": 130,
    "m": [
      ["222", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Mauritius",
    "c": "MU",
    "n": "+230",
    "p": 131,
    "m": [
      ["230", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Mexico",
    "c": "MX",
    "n": "+52",
    "p": 132,
    "m": [
      ["52", "{+}00 000 000 0000"]
    ]
  },
  {
    // "country": "Micronesia",
    "c": "FM",
    "n": "+691",
    "p": 133,
    "m": [
      ["691", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Moldova",
    "c": "MD",
    "n": "+373",
    "p": 134,
    "m": [
      ["373", "{+}000 000 00 000"]
    ]
  },
  {
    // "country": "Monaco",
    "c": "MC",
    "n": "+377",
    "p": 135,
    "m": [
      ["377", "{+}000 00 00 00 00"]
    ]
  },
  {
    // "country": "Mongolia",
    "c": "MN",
    "n": "+976",
    "p": 136,
    "m": [
      ["976", "{+}000 00 00 0000"]
    ]
  },
  {
    // "country": "Montenegro",
    "c": "ME",
    "n": "+382",
    "p": 137,
    "m": [
      ["382", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Montserrat",
    "c": "MS",
    "n": "+1",
    "p": 138,
    "m": [
      ["1664", us]
    ]
  },
  {
    // "country": "Morocco",
    "c": "MA",
    "n": "+212",
    "p": 139,
    "m": [
      ["212", "{+}000 00 000 0000[0]"]
    ]
  },
  {
    // "country": "Mozambique",
    "c": "MZ",
    "n": "+258",
    "p": 140,
    "m": [
      ["258", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Myanmar (Burma)",
    "c": "MM",
    "n": "+95",
    "p": 141,
    "m": [
      ["95", "{+}00 0000000[0000]"]
    ]
  },
  {
    // "country": "Namibia",
    "c": "NA",
    "n": "+264",
    "p": 142,
    "m": [
      ["264", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Nauru",
    "c": "NR",
    "n": "+674",
    "p": 143,
    "m": [
      ["674", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Nepal",
    "c": "NP",
    "n": "+977",
    "p": 144,
    "m": [
      ["977", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Netherlands",
    "c": "NL",
    "n": "+31",
    "p": 145,
    "m": [
      ["31", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "New Caledonia",
    "c": "NC",
    "n": "+687",
    "p": 146,
    "m": [
      ["687", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "New Zealand",
    "c": "NZ",
    "n": "+64",
    "p": 147,
    "m": [
      ["642", "{+}00 000 000 000"],
      ["64", "{+}00 0 000 0000"]
    ]
  },
  {
    // "country": "Nicaragua",
    "c": "NI",
    "n": "+505",
    "p": 148,
    "m": [
      ["505", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Niger",
    "c": "NE",
    "n": "+227",
    "p": 149,
    "m": [
      ["227", "{+}000 00000000[000]"]
    ]
  },
  {
    // "country": "Nigeria",
    "c": "NG",
    "n": "+234",
    "p": 150,
    "m": [
      ["234", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Niue",
    "c": "NU",
    "n": "+683",
    "p": 151,
    "m": [
      ["683", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Norfolk Island",
    "c": "NF",
    "n": "+672",
    "p": 152,
    "m": [
      ["672", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "North Korea",
    "c": "KP",
    "n": "+850",
    "p": 153,
    "m": [
      ["850", "{+}000 000000[0000000]"]
    ]
  },
  {
    // "country": "North Macedonia",
    "c": "MK",
    "n": "+389",
    "p": 154,
    "m": [
      ["389", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Northern Mariana Islands",
    "c": "MP",
    "n": "+1",
    "p": 155,
    "m": [
      ["1670", us]
    ]
  },
  {
    // "country": "Norway",
    "c": "NO",
    "n": "+47",
    "p": 156,
    "m": [
      ["47", "{+}00 00 00 00 00"]
    ]
  },
  {
    // "country": "Oman",
    "c": "OM",
    "n": "+968",
    "p": 157,
    "m": [
      ["968", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Pakistan",
    "c": "PK",
    "n": "+92",
    "p": 158,
    "m": [
      ["923", "{+}00 000 0000 000"],
      ["92", "{+}00 00 0000 0000"]
    ]
  },
  {
    // "country": "Palau",
    "c": "PW",
    "n": "+680",
    "p": 159,
    "m": [
      ["680", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Palestine",
    "c": "PS",
    "n": "+970",
    "p": 160,
    "m": [
      ["970", "{+}000 000000[000000]"]
    ]
  },
  {
    // "country": "Panama",
    "c": "PA",
    "n": "+507",
    "p": 161,
    "m": [
      ["507", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Papua New Guinea",
    "c": "PG",
    "n": "+675",
    "p": 162,
    "m": [
      ["675", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Paraguay",
    "c": "PY",
    "n": "+595",
    "p": 163,
    "m": [
      ["595", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Peru",
    "c": "PE",
    "n": "+51",
    "p": 164,
    "m": [
      ["51", "{+}00 00 000 000"]
    ]
  },
  {
    // "country": "Philippines",
    "c": "PH",
    "n": "+63",
    "p": 165,
    "m": [
      ["639", "{+}00 000 000 0000"],
      ["63", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "Poland",
    "c": "PL",
    "n": "+48",
    "p": 166,
    "m": [
      ["485", "{+}00 000 000 000"],
      ["48", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "Portugal",
    "c": "PT",
    "n": "+351",
    "p": 167,
    "m": [
      ["351", "{+}000 000 000 000"]
    ]
  },
  {
    // "country": "Puerto Rico",
    "c": "PR",
    "n": "+1",
    "p": 168,
    "m": [
      ["1787", us],
      ["1939", us]
    ]
  },
  {
    // "country": "Qatar",
    "c": "QA",
    "n": "+974",
    "p": 169,
    "m": [
      ["974", "{+}000 0000 0000"]
    ]
  },
  {
    // "country": "Runion",
    "c": "RE",
    "n": "+262",
    "p": 170,
    "m": [
      ["262", "{+}000 00000 0000"]
    ]
  },
  {
    // "country": "Romania",
    "c": "RO",
    "n": "+40",
    "p": 171,
    "m": [
      ["407", "{+}00 000 000 000"],
      ["40", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "Russia",
    "c": "RU",
    "n": "+7",
    "p": 172,
    "m": [
      ["7", "{+}0 000 000 00 00"]
    ]
  },
  {
    // "country": "Rwanda",
    "c": "RW",
    "n": "+250",
    "p": 173,
    "m": [
      ["250", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Samoa",
    "c": "WS",
    "n": "+685",
    "p": 174,
    "m": [
      ["685", "{+}000 00 0000"]
    ]
  },
  {
    // "country": "San Marino",
    "c": "SM",
    "n": "+378",
    "p": 175,
    "m": [
      ["378", "{+}000 0000 000000"]
    ]
  },
  {
    // "country": "So Tom & Prncipe",
    "c": "ST",
    "n": "+239",
    "p": 176,
    "m": [
      ["239", "{+}000 00 00 00"]
    ]
  },
  {
    // "country": "Saudi Arabia",
    "c": "SA",
    "n": "+966",
    "p": 177,
    "m": [
      ["96657", "{+}000 000 00 0000"],
      ["966", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Senegal",
    "c": "SN",
    "n": "+221",
    "p": 178,
    "m": [
      ["221", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Serbia",
    "c": "RS",
    "n": "+381",
    "p": 179,
    "m": [
      ["3816", "{+}000 000 000 000"],
      ["3817", "{+}000 000 000 000"],
      ["381", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Seychelles",
    "c": "SC",
    "n": "+248",
    "p": 180,
    "m": [
      ["248", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Sierra Leone",
    "c": "SL",
    "n": "+232",
    "p": 181,
    "m": [
      ["232", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Singapore",
    "c": "SG",
    "n": "+65",
    "p": 182,
    "m": [
      ["65", "{+}00 0000 0000"]
    ]
  },
  {
    // "country": "Sint Maarten",
    "c": "SX",
    "n": "+1",
    "p": 183,
    "m": [
      ["1721", us]
    ]
  },
  {
    // "country": "Slovakia",
    "c": "SK",
    "n": "+421",
    "p": 184,
    "m": [
      ["4219", "{+}000 000 000 0000"],
      ["421", "{+}000 00000000[00]"]
    ]
  },
  {
    // "country": "Slovenia",
    "c": "SI",
    "n": "+386",
    "p": 185,
    "m": [
      ["3863", "{+}000 00 000 000"],
      ["386", "{+}000 0000000[00]"]
    ]
  },
  {
    // "country": "Solomon Islands",
    "c": "SB",
    "n": "+677",
    "p": 186,
    "m": [
      ["677", "{+}000 00000"]
    ]
  },
  {
    // "country": "Somalia",
    "c": "SO",
    "n": "+252",
    "p": 187,
    "m": [
      ["252", "{+}000 0 000 000"]
    ]
  },
  {
    // "country": "South Africa",
    "c": "ZA",
    "n": "+27",
    "p": 188,
    "m": [
      ["276", "{+}00 000 000 000"],
      ["277", "{+}00 000 000 000"],
      ["278", "{+}00 000 000 000"],
      ["27", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "South Korea",
    "c": "KR",
    "n": "+82",
    "p": 189,
    "m": [
      ["82", "{+}00 00000000[00]"]
    ]
  },
  {
    // "country": "South Sudan",
    "c": "SS",
    "n": "+211",
    "p": 190,
    "m": [
      ["211", "{+}000 0000000[00]"]
    ]
  },
  {
    // "country": "Spain",
    "c": "ES",
    "n": "+34",
    "p": 191,
    "m": [
      ["346", "{+}00 000 000 000"],
      ["347", "{+}00 000 000 000"],
      ["34", "{+}00 00 000 000"]
    ]
  },
  {
    // "country": "Sri Lanka",
    "c": "LK",
    "n": "+94",
    "p": 192,
    "m": [
      ["947", "{+}00 000 000 0000"],
      ["948", "{+}00 000 000 0000"],
      ["949", "{+}00 000 000 0000"],
      ["94", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "St. Barthlemy",
    "c": "BL",
    "n": "+590",
    "p": 193,
    "m": [
      ["590", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "St. Helena",
    "c": "SH",
    "n": "+290",
    "p": 194,
    "m": [
      ["290", "{+}000 0000"]
    ]
  },
  {
    // "country": "St. Kitts & Nevis",
    "c": "KN",
    "n": "+1",
    "p": 195,
    "m": [
      ["1869", us]
    ]
  },
  {
    // "country": "St. Lucia",
    "c": "LC",
    "n": "+1",
    "p": 196,
    "m": [
      ["1758", us]
    ]
  },
  {
    // "country": "St. Martin",
    "c": "MF",
    "n": "+590",
    "p": 197,
    "m": [
      ["590", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "St. Pierre & Miquelon",
    "c": "PM",
    "n": "+508",
    "p": 198,
    "m": [
      ["508", "{+}000 00 00 00"]
    ]
  },
  {
    // "country": "St. Vincent & Grenadines",
    "c": "VC",
    "n": "+1",
    "p": 199,
    "m": [
      ["1784", us]
    ]
  },
  {
    // "country": "Sudan",
    "c": "SD",
    "n": "+249",
    "p": 200,
    "m": [
      ["249", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Suriname",
    "c": "SR",
    "n": "+597",
    "p": 201,
    "m": [
      ["597", "{+}000 000 000"]
    ]
  },
  {
    // "country": "Sweden",
    "c": "SE",
    "n": "+46",
    "p": 202,
    "m": [
      ["4613", "{+}00 00 00 00 00"],
      ["4618", "{+}00 00 00 00 00"],
      ["467", "{+}00 00 000 00 00"],
      ["468", "{+}00 00 000 00 00"],
      ["46", "{+}00 0000000[0000]"]
    ]
  },
  {
    // "country": "Switzerland",
    "c": "CH",
    "n": "+41",
    "p": 203,
    "m": [
      ["417", "{+}00 000 000 000"],
      ["41", "{+}00 00 000 0000"]
    ]
  },
  {
    // "country": "Syria",
    "c": "SY",
    "n": "+963",
    "p": 204,
    "m": [
      ["9639", "{+}000 000 000 000"],
      ["963", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Taiwan",
    "c": "TW",
    "n": "+886",
    "p": 205,
    "m": [
      ["8869", "{+}000 000 000 000"],
      ["886", "{+}000 0 0000 0000"]
    ]
  },
  {
    // "country": "Tajikistan",
    "c": "TJ",
    "n": "+992",
    "p": 206,
    "m": [
      ["992", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Tanzania",
    "c": "TZ",
    "n": "+255",
    "p": 207,
    "m": [
      ["255", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Thailand",
    "c": "TH",
    "n": "+66",
    "p": 208,
    "m": [
      ["6653", "{+}00 00 000 000"],
      ["6676", "{+}00 00 000 000"],
      ["662", "{+}00 0 000 0000"],
      ["666", "{+}00 000 000 000"],
      ["668", "{+}00 000 000 000"],
      ["669", "{+}00 000 000 000"],
      ["66", "{+}00 00 000 000"]
    ]
  },
  {
    // "country": "Timor-Leste",
    "c": "TL",
    "n": "+670",
    "p": 209,
    "m": [
      ["670", "{+}000 000 0000"]
    ]
  },
  {
    // "country": "Togo",
    "c": "TG",
    "n": "+228",
    "p": 210,
    "m": [
      ["228", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Tokelau",
    "c": "TK",
    "n": "+690",
    "p": 211,
    "m": [
      ["690", "{+}000 0000"]
    ]
  },
  {
    // "country": "Tonga",
    "c": "TO",
    "n": "+676",
    "p": 212,
    "m": [
      ["676", "{+}000 00 000"]
    ]
  },
  {
    // "country": "Trinidad & Tobago",
    "c": "TT",
    "n": "+1",
    "p": 213,
    "m": [
      ["1868", us]
    ]
  },
  {
    // "country": "Tunisia",
    "c": "TN",
    "n": "+216",
    "p": 214,
    "m": [
      ["216", "{+}000 00 000 000"]
    ]
  },
  {
    // "country": "Trkiye",
    "c": "TR",
    "n": "+90",
    "p": 215,
    "m": [
      ["90", "{+}00 000 000 0000"]
    ]
  },
  {
    // "country": "Turkmenistan",
    "c": "TM",
    "n": "+993",
    "p": 216,
    "m": [
      ["993", "{+}000 0 000 000"]
    ]
  },
  {
    // "country": "Turks & Caicos Islands",
    "c": "TC",
    "n": "+1",
    "p": 217,
    "m": [
      ["1649", us]
    ]
  },
  {
    // "country": "Tuvalu",
    "c": "TV",
    "n": "+688",
    "p": 218,
    "m": [
      ["688", "{+}000 00 000"]
    ]
  },
  {
    // "country": "U.S. Virgin Islands",
    "c": "VI",
    "n": "+1",
    "p": 219,
    "m": [
      ["1340", us]
    ]
  },
  {
    // "country": "Uganda",
    "c": "UG",
    "n": "+256",
    "p": 220,
    "m": [
      ["2567", "{+}000 000 000 000"],
      ["256", "{+}000 00 000 000[0]"]
    ]
  },
  {
    // "country": "Ukraine",
    "c": "UA",
    "n": "+380",
    "p": 221,
    "m": [
      ["380", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "United Arab Emirates",
    "c": "AE",
    "n": "+971",
    "p": 222,
    "m": [
      ["9715", "{+}000 00 000 0000"],
      ["971", "{+}000 0 000 0000"]
    ]
  },
  {
    // "country": "United Kingdom",
    "c": "GB",
    "n": "+44",
    "p": 223,
    "m": [
      ["4420", "{+}00 00 0000 0000"],
      ["447", "{+}00 0000 000 000"],
      ["44", "{+}00 000 000 0000"]
    ]
  },
  {
    // "country": "United States",
    "c": "US",
    "n": "+1",
    "p": 224,
    "m": [
      ["1", us]
    ]
  },
  {
    // "country": "Uruguay",
    "c": "UY",
    "n": "+598",
    "p": 225,
    "m": [
      ["598", "{+}000 0 000 00 00"]
    ]
  },
  {
    // "country": "Uzbekistan",
    "c": "UZ",
    "n": "+998",
    "p": 226,
    "m": [
      ["998", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Vanuatu",
    "c": "VU",
    "n": "+678",
    "p": 227,
    "m": [
      ["678", "{+}000 00 0000"]
    ]
  },
  {
    // "country": "Vatican City",
    "c": "VA",
    "n": "+39",
    "p": 228,
    "m": [
      ["3906698", "{+}00 00 000 00000"],
      ["379", "{+}000 00 0000 0000"]
    ]
  },
  {
    // "country": "Venezuela",
    "c": "VE",
    "n": "+58",
    "p": 229,
    "m": [
      ["58", "{+}00 000 000 0000"]
    ]
  },
  {
    // "country": "Vietnam",
    "c": "VN",
    "n": "+84",
    "p": 230,
    "m": [
      ["843", "{+}00 000 000 000"],
      ["845", "{+}00 000 000 000"],
      ["847", "{+}00 000 000 000"],
      ["849", "{+}00 000 000 000"],
      ["84", "{+}00 00 0000 0000"]
    ]
  },
  {
    // "country": "Wallis & Futuna",
    "c": "WF",
    "n": "+681",
    "p": 231,
    "m": [
      ["681", "{+}000 00 0000"]
    ]
  },
  {
    // "country": "Yemen",
    "c": "YE",
    "n": "+967",
    "p": 232,
    "m": [
      ["9677", "{+}000 000 000 000"],
      ["967", "{+}000 0 000 000"]
    ]
  },
  {
    // "country": "Zambia",
    "c": "ZM",
    "n": "+260",
    "p": 233,
    "m": [
      ["2609", "{+}000 000 000 000"],
      ["260", "{+}000 00 000 0000"]
    ]
  },
  {
    // "country": "Zimbabwe",
    "c": "ZW",
    "n": "+263",
    "p": 234,
    "m": [
      ["263", "{+}000 00 000 00[00]"]
    ]
  }
];
var base$a = function base67(props, context, dependencies2) {
  var {
    include,
    exclude,
    mask: maskProp
  } = toRefs(props);
  var {
    update,
    focus,
    value,
    input,
    form$,
    el$,
    classes
  } = dependencies2;
  var options$ = ref(null);
  var addonPlaceholder = ref(markRaw({
    props: ["option", "el$"],
    render() {
      return h("div", {
        class: classes.value.placeholder,
        style: {
          backgroundPosition: "0 -".concat(this.option.p * 20 + 20, "px")
        }
      });
    }
  }));
  var addonOptions = computed(() => {
    return countryPhones.filter((c) => {
      if (!include.value.length && !exclude.value.length) {
        return true;
      }
      if (include.value.length) {
        return include.value.map((c2) => c2.toUpperCase()).indexOf(c.c) !== -1;
      }
      return exclude.value.map((c2) => c2.toUpperCase()).indexOf(c.c) === -1;
    }).map((c) => {
      return _objectSpread2$1(_objectSpread2$1({}, c), {}, {
        value: c.c,
        label: form$.value.translations.vueform.countries[c.c],
        display: markRaw({
          props: ["option", "index", "selected", "pointed", "el$"],
          render() {
            return h("div", {
              class: classes.value.option(this.selected || this.pointed)
            }, [h("div", {
              class: classes.value.optionWrapper
            }, [h("div", {
              class: classes.value.flag,
              style: {
                backgroundPosition: "0 -".concat(this.option.p * 20 + 20, "px")
              }
            }), h("div", {
              class: classes.value.country
            }, [this.option.label, h("span", {
              class: classes.value.number
            }, [this.option.n])])])]);
          }
        }),
        valueDisplay: markRaw({
          props: ["option", "el$"],
          render() {
            return h("div", {
              class: classes.value.flag,
              style: {
                backgroundPosition: "0 -".concat(this.option.p * 20 + 20, "px")
              }
            });
          }
        })
      });
    }).sort((a, b) => a.label.localeCompare(b.label)).map((c, i) => _objectSpread2$1(_objectSpread2$1({}, c), {}, {
      index: i
    }));
  });
  var mask = computed(() => {
    if (!maskPluginInstalled.value) {
      return;
    }
    var masks2 = {};
    var maskLengths = [];
    addonOptions.value.forEach((c) => c.m.forEach((m) => {
      if (masks2[m[1]] === void 0) {
        masks2[m[1]] = [];
      }
      var length = m[0].toString().length;
      if (masks2[m[1]][length] === void 0) {
        masks2[m[1]][length] = [];
      }
      masks2[m[1]][length].push(parseInt(m[0]));
      if (maskLengths.indexOf(length) === -1) {
        maskLengths.push(length);
      }
    }));
    maskLengths.sort().reverse();
    var mask2 = [];
    maskLengths.forEach((length) => {
      Object.keys(masks2).forEach((m) => {
        if (masks2[m][length]) {
          mask2.push({
            mask: m,
            startsWith: masks2[m][length],
            placeholder: true
          });
        }
      });
    });
    mask2.push({
      mask: "{+}0000000[0000000]",
      startsWith: ""
    });
    return {
      mask: mask2
    };
  });
  var masks = computed(() => {
    return addonOptions.value.reduce((prev, curr) => {
      return curr.m.reduce((p, c) => {
        return _objectSpread2$1(_objectSpread2$1({}, p), {}, {
          [c[0]]: curr.c
        });
      }, _objectSpread2$1({}, prev));
    }, {});
  });
  var maskPluginInstalled = computed(() => {
    return !!maskProp;
  });
  var inputType = computed(() => {
    return maskPluginInstalled.value ? "text" : "tel";
  });
  var setFlag = () => {
    var _options$$value$selec;
    if (!value.value) {
      if (Object.keys(options$.value.selected).length) {
        options$.value.reset();
      }
      return;
    }
    if (!value.value.startsWith("+") || value.value === ((_options$$value$selec = options$.value.selected) === null || _options$$value$selec === void 0 ? void 0 : _options$$value$selec.n)) {
      return;
    }
    var number = value.value.replace("+", "");
    var lengths = [7, 5, 4, 3, 2, 1].filter((l) => number.length >= l);
    var country;
    lengths.forEach((l) => {
      if (country) {
        return;
      }
      country = masks.value[number.slice(0, l)] || void 0;
    });
    if (!country) {
      if (Object.keys(options$.value.selected).length) {
        options$.value.reset();
      }
      return;
    }
    if (country === "MF") {
      country = "GP";
    }
    var option2 = addonOptions.value.find((c) => c.c === country);
    if (options$.value.selected.index !== option2.index) {
      options$.value.selectOption(option2);
    }
  };
  var handleOptionSelect = (option2) => {
    if (document.activeElement === input.value) {
      context.emit("select", option2, el$.value);
      return;
    }
    if (option2.n === void 0) {
      el$.value.clear();
    } else {
      var valueMatchesMask = option2.m.map((m) => "+".concat(m[0])).find((m) => {
        return value.value.startsWith(m);
      });
      if (!valueMatchesMask) {
        el$.value.update(option2.m.length === 1 ? "+".concat(option2.m[0][0]) : option2.n);
      }
      if (document.activeElement.closest("[data-dropdown-for]")) {
        focus();
      }
    }
    context.emit("select", option2, el$.value);
  };
  var handleOpen = () => {
    context.emit("open", el$);
  };
  var handleClose = () => {
    context.emit("close", el$);
  };
  onMounted(() => {
    setFlag();
  });
  watch(value, (n2) => {
    setFlag();
  });
  return {
    options$,
    addonOptions,
    handleOptionSelect,
    addonPlaceholder,
    maskPluginInstalled,
    inputType,
    mask,
    handleOpen,
    handleClose
  };
};
var base$9 = function base68(props, context, dependencies2) {
  var {
    fire,
    el$
  } = dependencies2;
  var handleKeydown = (e2) => {
    fire("keydown", e2, el$.value);
  };
  var handleKeyup = (e2) => {
    fire("keyup", e2, el$.value);
  };
  var handleKeypress = (e2) => {
    fire("keypress", e2, el$.value);
  };
  return {
    handleKeydown,
    handleKeyup,
    handleKeypress
  };
};
var phone2 = function phone3(props, context, dependencies2) {
  var {
    fire,
    model,
    input,
    el$
  } = dependencies2;
  var handleKeydown = (e2) => {
    if (el$.value.maskPluginInstalled) {
      return;
    }
    if (["Backspace", "Delete", "Tab", "Escape", "Enter", "ArrowLeft", "ArrowRight"].indexOf(e2.key) !== -1 || e2.ctrlKey || e2.metaKey) {
      return;
    }
    if (/[0-9]/.test(e2.key) && (!model.value || model.value.length < 16)) {
      return;
    }
    if (e2.key === "+" && (!model.value || input.value.selectionStart === 0) && (!model.value || model.value.length < 16)) {
      return;
    }
    e2.preventDefault();
  };
  return {
    handleKeydown
  };
};
var PhoneElement = {
  name: "PhoneElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "select", "open", "close", "blur", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "text",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Object],
      localized: true,
      default: null
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean],
      default: false
    },
    include: {
      required: false,
      type: [Array],
      default: () => []
    },
    exclude: {
      required: false,
      type: [Array],
      default: () => []
    },
    unmask: {
      require: false,
      type: [Boolean],
      default: false
    },
    allowIncomplete: {
      require: false,
      type: [Boolean],
      default: false
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    autocomplete: {
      required: false,
      type: [String, Number],
      default: null
    },
    loading: {
      type: [Boolean],
      required: false,
      default: false
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSelect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$G, base$1c, base$P, text$1, base$14, text$2, base$H, base$L, base$I, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, phone$1, base$s, base$b, base$R, base$F, base$T, phone2, base$t, base$a];
    context.slots = ["label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$8 = function base69(props, context, dependencies2) {
  var {
    radioName,
    radioValue
  } = toRefs(props);
  var update = dependencies2.update;
  var nullValue = dependencies2.nullValue;
  var fieldId = dependencies2.fieldId;
  var path = dependencies2.path;
  var form$ = dependencies2.form$;
  var listeners = ref([]);
  var inputName = computed(() => {
    return radioName.value || path.value;
  });
  var check2 = () => {
    update(radioValue.value);
  };
  var uncheck = () => {
    update(nullValue.value);
  };
  var watchChange = (value, old) => {
    if (old) {
      form$.value.$el.querySelectorAll('input[name="'.concat(old, '"')).forEach((element2, i) => {
        if (listeners.value[i]) {
          element2.removeEventListener("change", listeners.value[i]);
        }
      });
    }
    form$.value.$el.querySelectorAll('input[name="'.concat(value, '"')).forEach((element2) => {
      var listener = () => {
        if (element2.id != fieldId.value) {
          update(nullValue.value);
        }
      };
      listeners.value.push(listener);
      element2.addEventListener("change", listener);
    });
  };
  onMounted(() => {
    watchChange(inputName.value);
  });
  watch(inputName, watchChange);
  return {
    inputName,
    check: check2,
    uncheck
  };
};
var RadioElement = {
  name: "RadioElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "radio",
      private: true
    },
    default: {
      required: false,
      type: [String, Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    radioName: {
      required: false,
      type: [String],
      default: null
    },
    radioValue: {
      required: false,
      type: [Boolean, String, Number],
      default: 1
    },
    text: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    align: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$U, base$1c, base$P, base$K, base$C, base$14, base$D, base$L, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$8, radio, base$F, base$T, base$A];
    context.slots = ["default", "label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var RadiogroupElement = {
  name: "RadiogroupElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "radiogroup",
      private: true
    },
    default: {
      required: false,
      type: [String, Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    items: {
      required: false,
      type: [Object, Array, Function, String],
      localized: true,
      default: () => ({})
    },
    disables: {
      required: false,
      type: [Array],
      default: () => []
    },
    clearOnRefetch: {
      type: [Boolean],
      required: false,
      default: true
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$O, base$K, base$U, base$1c, base$P, radiogroup$2, base$C, base$L, radiogroup, base$14, base$D, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, radiogroup$1, base$F, base$T];
    context.slots = ["radio", "label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var SelectElement = {
  name: "SelectElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "select", "deselect", "search-change", "open", "close", "clear", "paste", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "select",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Object],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    onSelect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onDeselect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSearchChange: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onOpen: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClose: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClear: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onPaste: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    native: {
      required: false,
      type: [Boolean],
      default: true
    },
    items: {
      required: false,
      type: [Object, Array, Function, String],
      localized: true,
      default: () => ({})
    },
    labelProp: {
      type: [String],
      required: false,
      default: "label"
    },
    valueProp: {
      type: [String],
      required: false,
      default: "value"
    },
    dataKey: {
      type: [String],
      required: false,
      default: void 0
    },
    searchParam: {
      type: [String],
      required: false,
      default: "query"
    },
    search: {
      required: false,
      type: [Boolean],
      default: false,
      native: false
    },
    trackBy: {
      type: [String, Array],
      required: false,
      default: void 0,
      native: false
    },
    strict: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    create: {
      required: false,
      type: [Boolean],
      default: false,
      native: false
    },
    appendNewOption: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    addOptionOn: {
      type: [Array],
      required: false,
      default: () => ["enter"],
      native: false
    },
    object: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    limit: {
      type: [Number],
      required: false,
      default: -1,
      native: false
    },
    groups: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    groupLabel: {
      type: [String],
      required: false,
      default: "label",
      native: false
    },
    groupOptions: {
      type: [String],
      required: false,
      default: "items",
      native: false
    },
    groupHideEmpty: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    openDirection: {
      type: [String],
      required: false,
      default: "bottom",
      native: false
    },
    appendToBody: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    appendTo: {
      type: [String],
      required: false,
      default: void 0,
      native: false
    },
    canDeselect: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    canClear: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    closeOnSelect: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    closeOnDeselect: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    clearOnRefetch: {
      type: [Boolean],
      required: false,
      default: false
    },
    delay: {
      type: [Number],
      required: false,
      default: -1,
      native: false
    },
    minChars: {
      type: [Number],
      required: false,
      default: 0,
      native: false
    },
    resolveOnLoad: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    filterResults: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    clearOnSearch: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    caret: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    truncate: {
      type: [Boolean],
      required: false,
      default: true,
      native: false
    },
    loading: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    noOptionsText: {
      type: [String, Object],
      required: false,
      default: void 0,
      "@default": "locale.multiselect.noOptions",
      localized: true,
      native: false
    },
    noResultsText: {
      type: [String, Object],
      required: false,
      default: void 0,
      "@default": "locale.multiselect.noResults",
      localized: true,
      native: false
    },
    autocomplete: {
      type: [String],
      required: false,
      native: false
    },
    inputType: {
      type: [String],
      required: false,
      default: "text",
      native: false
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$G, base$1c, base$P, base$C, base$D, base$H, select$1, base$L, select$2, base$14, base$I, select$3, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$d, select4, base$R, base$F, base$T, base$t];
    context.slots = ["option", "single-label", "placeholder", "group-label", "before-list", "after-list", "no-results", "no-options", "caret", "spinner", "clear", "label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$7 = function base70(props, context, dependencies2) {
  var {
    lazy
  } = toRefs(props);
  var value = dependencies2.value;
  var handleUpdate = (val) => {
    if (lazy.value) {
      return;
    }
    value.value = val;
  };
  return {
    handleUpdate
  };
};
var SliderElement = {
  name: "SliderElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "slider",
      private: true
    },
    default: {
      required: false,
      type: [Number, Array],
      default: 0
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    min: {
      required: false,
      type: [Number],
      default: 0
    },
    max: {
      required: false,
      type: [Number],
      default: 100
    },
    step: {
      required: false,
      type: [Number],
      default: 1
    },
    tooltips: {
      required: false,
      type: [Boolean],
      default: true
    },
    showTooltip: {
      required: false,
      type: [String],
      default: "always"
    },
    tooltipPosition: {
      required: false,
      type: [String],
      default: null
    },
    merge: {
      required: false,
      type: [Number],
      default: -1
    },
    format: {
      required: false,
      type: [Object, Function],
      default: null
    },
    orientation: {
      required: false,
      type: [String],
      default: "horizontal"
    },
    direction: {
      required: false,
      type: [String],
      default: "ltr"
    },
    lazy: {
      required: false,
      type: [Boolean],
      default: true,
      private: true
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, min2, base$U, base$1c, base$P, base$C, slider2, base$L, slider$1, base$14, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$u, base$7, base$R, base$F, base$T];
    context.slots = ["label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$6 = function base71(props, context, dependencies2) {
  var {
    content
  } = toRefs(props);
  var {
    fieldSlots,
    el$
  } = dependencies2;
  var isHtml = computed(() => {
    return typeof resolvedContent.value === "string";
  });
  var resolvedContent = computed(() => {
    return typeof content.value === "function" ? content.value(el$.value) : content.value;
  });
  var componentContent = computed(() => {
    var _content$value, _content$value2;
    if (!((_content$value = content.value) !== null && _content$value !== void 0 && _content$value.render) && !((_content$value2 = content.value) !== null && _content$value2 !== void 0 && _content$value2.template)) {
      return content.value;
    }
    return resolveComponent(content.value);
  });
  var slotContent = computed(() => {
    var _fieldSlots$value$def, _fieldSlots$value$def2;
    if (!((_fieldSlots$value$def = fieldSlots.value.default) !== null && _fieldSlots$value$def !== void 0 && _fieldSlots$value$def.render) && !((_fieldSlots$value$def2 = fieldSlots.value.default) !== null && _fieldSlots$value$def2 !== void 0 && _fieldSlots$value$def2.template)) {
      return fieldSlots.value.default;
    }
    return resolveComponent(fieldSlots.value.default);
  });
  var resolveComponent = (component) => {
    component = _objectSpread2$1({}, component);
    if (!component.props) {
      component.props = ["el$"];
    } else if (Array.isArray(component.props) && component.props.indexOf("el$") === -1) {
      component.props.push("el$");
    } else if (!Array.isArray(component.props) && !component.props.el$) {
      component.props["el$"] = {
        type: Object,
        required: false,
        default: () => ({})
      };
    }
    return component;
  };
  return {
    isHtml,
    componentContent,
    slotContent,
    resolvedContent
  };
};
var StaticElement = {
  name: "StaticElement",
  mixins: [BaseElement, HasView],
  emits: ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "static",
      private: true
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    content: {
      required: false,
      type: [String, Object, Function],
      default: ""
    },
    wrap: {
      required: false,
      type: [Boolean],
      default: true
    },
    tag: {
      required: false,
      type: [String],
      default: void 0
    },
    allowHtml: {
      required: false,
      type: [Boolean],
      default: true
    },
    href: {
      required: false,
      type: [String],
      default: void 0
    },
    target: {
      required: false,
      type: [String],
      default: void 0
    },
    src: {
      required: false,
      type: [String],
      default: void 0
    },
    alt: {
      required: false,
      type: [String],
      default: void 0
    },
    title: {
      required: false,
      type: [String],
      default: void 0
    },
    width: {
      required: false,
      type: [String],
      default: void 0
    },
    height: {
      required: false,
      type: [String],
      default: void 0
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    align: {
      required: false,
      type: [String],
      default: void 0
    },
    top: {
      required: false,
      type: [String, Number],
      default: 0
    },
    bottom: {
      required: false,
      type: [String, Number],
      default: 0
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, static_$1, base$1c, static_$2, base$14, base$$, base$Z, base$Y, base$1a, base$_, base$X, base$U, static_$3, base$T, base$6];
    context.slots = ["default", "label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, static_4(props, context));
  }
};
var base$5 = function base72(props, context, dependencies2) {
  var fire = dependencies2.fire;
  var el$ = dependencies2.el$;
  var handleTag = (searchQuery) => {
    fire("tag", searchQuery, el$.value);
  };
  return {
    handleTag
  };
};
var TagsElement = {
  name: "TagsElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "select", "deselect", "search-change", "open", "close", "tag", "clear", "paste", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "tags",
      private: true
    },
    default: {
      required: false,
      type: [Array],
      default: () => []
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    onSelect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onDeselect: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onSearchChange: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onOpen: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClose: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onTag: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onClear: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onPaste: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    items: {
      required: false,
      type: [Object, Array, Function, String],
      localized: true,
      default: () => ({})
    },
    labelProp: {
      type: [String],
      required: false,
      default: "label"
    },
    valueProp: {
      type: [String],
      required: false,
      default: "value"
    },
    dataKey: {
      type: [String],
      required: false,
      default: void 0
    },
    searchParam: {
      type: [String],
      required: false,
      default: "query"
    },
    search: {
      required: false,
      type: [Boolean],
      default: false
    },
    trackBy: {
      type: [String, Array],
      required: false,
      default: "label"
    },
    strict: {
      type: [Boolean],
      required: false,
      default: true
    },
    breakTags: {
      type: [Boolean],
      required: false,
      default: false
    },
    create: {
      required: false,
      type: [Boolean],
      default: false
    },
    appendNewOption: {
      type: [Boolean],
      required: false,
      default: true
    },
    addOptionOn: {
      type: [Array],
      required: false,
      default: () => ["enter"]
    },
    object: {
      type: [Boolean],
      required: false,
      default: false
    },
    limit: {
      type: [Number],
      required: false,
      default: -1
    },
    max: {
      type: [Number],
      required: false,
      default: -1
    },
    groups: {
      type: [Boolean],
      required: false,
      default: false
    },
    groupLabel: {
      type: [String],
      required: false,
      default: "label"
    },
    groupOptions: {
      type: [String],
      required: false,
      default: "items"
    },
    groupHideEmpty: {
      type: [Boolean],
      required: false,
      default: false
    },
    groupSelect: {
      type: [Boolean],
      required: false,
      default: true
    },
    openDirection: {
      type: [String],
      required: false,
      default: "bottom"
    },
    appendToBody: {
      type: [Boolean],
      required: false,
      default: false,
      native: false
    },
    appendTo: {
      type: [String],
      required: false,
      default: void 0,
      native: false
    },
    canClear: {
      type: [Boolean],
      required: false,
      default: true
    },
    clearOnSelect: {
      type: [Boolean],
      required: false,
      default: true
    },
    closeOnSelect: {
      type: [Boolean],
      required: false,
      default: true
    },
    closeOnDeselect: {
      type: [Boolean],
      required: false,
      default: false
    },
    clearOnRefetch: {
      type: [Boolean],
      required: false,
      default: false
    },
    delay: {
      type: [Number],
      required: false,
      default: -1
    },
    minChars: {
      type: [Number],
      required: false,
      default: 0
    },
    resolveOnLoad: {
      type: [Boolean],
      required: false,
      default: true
    },
    filterResults: {
      type: [Boolean],
      required: false,
      default: true
    },
    clearOnSearch: {
      type: [Boolean],
      required: false,
      default: false
    },
    hideSelected: {
      type: [Boolean],
      required: false,
      default: true
    },
    showOptions: {
      type: [Boolean],
      required: false,
      default: true
    },
    caret: {
      type: [Boolean],
      required: false,
      default: true
    },
    loading: {
      type: [Boolean],
      required: false,
      default: false
    },
    noOptionsText: {
      type: [String, Object],
      required: false,
      default: void 0,
      "@default": "locale.multiselect.noOptions",
      localized: true
    },
    noResultsText: {
      type: [String, Object],
      required: false,
      default: void 0,
      "@default": "locale.multiselect.noResults",
      localized: true
    },
    autocomplete: {
      type: [String],
      required: false
    },
    inputType: {
      type: [String],
      required: false,
      default: "text"
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, array$1, base$U, base$G, base$1c, tags$4, base$C, base$D, base$H, tags$1, base$L, tags$2, base$14, array2, tags$3, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$d, base$5, base$c, tags2, base$R, base$F, base$T, base$t];
    context.slots = ["tag", "option", "placeholder", "group-label", "before-list", "after-list", "no-results", "no-options", "caret", "spinner", "clear", "label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$4 = function base73(props, context, dependencies2) {
  var {
    autogrow
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var input = dependencies2.input;
  var value = dependencies2.value;
  var autosize = () => {
    if (!autogrow.value) {
      return;
    }
    form$.value.$vueform.services.autosize.update(input.value);
  };
  watch(autogrow, (newValue) => {
    if (newValue) {
      form$.value.$vueform.services.autosize(input.value);
    } else {
      form$.value.$vueform.services.autosize.destroy(input.value);
    }
  });
  watch(value, () => {
    autosize();
  });
  onMounted(() => {
    if (autogrow.value) {
      nextTick(() => {
        form$.value.$vueform.services.autosize(input.value);
      });
    }
  });
  return {
    autosize
  };
};
var multilingual9 = function multilingual10(props, context, dependencies2) {
  var {
    autosize
  } = base$4(props, context, dependencies2);
  var form$ = dependencies2.form$;
  onMounted(() => {
    form$.value.on("language", () => {
      autosize();
    });
  });
  return {
    autosize
  };
};
var TextareaElement = {
  name: "TextareaElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "blur", "keydown", "keyup", "keypress", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "textarea",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Object],
      localized: true,
      default: null
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    autogrow: {
      required: false,
      type: [Boolean],
      default: true
    },
    rows: {
      required: false,
      type: [Number],
      default: 3
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean],
      default: false
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeydown: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeyup: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeypress: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$G, base$1c, base$P, base$w, text$1, base$14, text$2, base$L, base$I, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$m, base$4, base$s, base$b, base$R, base$F, base$T, base$9, base$t];
    context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var TextElement = {
  name: "TextElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "blur", "keydown", "keyup", "keypress", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "text",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Object],
      localized: true,
      default: null
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean],
      default: false
    },
    inputType: {
      required: false,
      type: [String],
      default: "text"
    },
    forceNumbers: {
      required: false,
      type: [Boolean],
      default: null
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    autocomplete: {
      required: false,
      type: [String, Number],
      default: null
    },
    loading: {
      type: [Boolean],
      required: false,
      default: false
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeydown: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeyup: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeypress: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$G, base$1c, base$P, base$w, text$1, base$14, text$2, base$H, base$L, base$I, text3, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$m, base$s, base$b, base$R, base$F, base$T, base$9, base$t];
    context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var ToggleElement = {
  name: "ToggleElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "toggle",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Boolean],
      default: void 0
      // falseValue
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    text: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    labels: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    trueValue: {
      required: false,
      type: [Boolean, String, Number],
      default: true
    },
    falseValue: {
      required: false,
      type: [Boolean, String, Number],
      default: false
    },
    extendOptions: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    align: {
      required: false,
      type: [String],
      default: void 0
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, boolean, base$U, base$1c, base$P, toggle, base$C, base$14, base$D, base$L, base$B, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$u, base$z, toggle$1, base$F, base$T, base$A];
    context.slots = ["default", "label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$3 = function base74(props, context, dependencies2) {
  var {
    endpoint,
    method
  } = toRefs(props);
  var form$ = dependencies2.form$;
  var input = dependencies2.input;
  var focused = ref(false);
  var editorEndpoint = computed(() => {
    return endpoint.value || form$.value.$vueform.config.endpoints.attachment.url;
  });
  var editorMethod = computed(() => {
    return method.value || form$.value.$vueform.config.endpoints.attachment.method;
  });
  onMounted(() => {
    input.value.editor$.addEventListener("focus", () => {
      focused.value = true;
    });
    input.value.editor$.addEventListener("blur", () => {
      focused.value = false;
    });
  });
  return {
    editorEndpoint,
    editorMethod,
    focused
  };
};
var base$2 = function base75(props, context, dependencies2) {
  var fire = dependencies2.fire;
  var listeners = dependencies2.listeners;
  var handleAlert = (message) => {
    fire("alert", message);
    if (!listeners.value.alert) {
      alert(message);
    }
  };
  return {
    handleAlert
  };
};
var EditorElement = {
  name: "EditorElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "blur", "alert", "error", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "editor",
      private: true
    },
    default: {
      required: false,
      type: [String, Number, Object],
      localized: true,
      default: null
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    onError: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onAlert: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    accept: {
      required: false,
      type: [Array],
      default: () => []
    },
    acceptMimes: {
      required: false,
      type: [Array],
      default: () => []
    },
    endpoint: {
      required: false,
      type: [String, Function, Promise],
      default: null,
      "@default": "config.endpoints.attachment.url"
    },
    method: {
      required: false,
      type: [String],
      default: null,
      "@default": "config.endpoints.attachment.method"
    },
    hideTools: {
      required: false,
      type: [Array],
      default: () => []
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$K, base$U, base$1c, base$P, text$1, base$14, text$2, base$L, base$I, editor2, base$$, base$J, base$Z, base$Y, base$3, base$1a, base$_, base$X, base$m, base$2, base$n, base$b, base$R, base$F, editor$1, base$t];
    context.slots = ["label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, base$N(props, context));
  }
};
var base$1 = function base76(props, context, dependencies2) {
  var form$ = dependencies2.form$;
  var language = computed(() => {
    return form$.value.selectedLanguage;
  });
  var languages = computed(() => {
    return keys_1(form$.value.options.languages);
  });
  return {
    language,
    languages
  };
};
var TTextareaElement = {
  name: "TTextareaElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "blur", "keydown", "keyup", "keypress", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "t-textarea",
      private: true
    },
    default: {
      required: false,
      type: [Object, String, Number],
      localized: true,
      default: null
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    autogrow: {
      required: false,
      type: [Boolean],
      default: true
    },
    rows: {
      required: false,
      type: [Number],
      default: 3
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean],
      default: false
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeydown: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeyup: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeypress: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$U, base$G, base$1c, base$P, base$w, base$1, multilingual$6, multilingual$2, multilingual$7, base$14, multilingual$3, multilingual$5, multilingual$1, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$m, multilingual9, base$s, base$b, base$R, multilingual$4, base$T, base$9, base$t];
    context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, multilingual$8(props, context));
  }
};
var TTextElement = {
  name: "TTextElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "blur", "keydown", "keyup", "keypress", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "t-text",
      private: true
    },
    default: {
      required: false,
      type: [Object, String, Number],
      localized: true,
      default: void 0
    },
    addons: {
      required: false,
      type: [Object],
      localized: true,
      default: () => ({})
    },
    autocomplete: {
      required: false,
      type: [String, Number],
      default: null
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    floating: {
      required: false,
      type: [String, Boolean, Object],
      localized: true,
      default: null
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    inputType: {
      required: false,
      type: [String],
      default: "text"
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    readonly: {
      required: false,
      type: [Boolean],
      default: false
    },
    loading: {
      type: [Boolean],
      required: false,
      default: false
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeydown: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeyup: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onKeypress: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$U, base$G, base$1c, base$P, base$w, base$1, multilingual$6, multilingual$2, multilingual$7, base$14, multilingual$3, base$H, multilingual$5, multilingual$1, base$$, base$J, base$Z, base$Y, base$1a, base$_, base$X, base$m, base$s, base$b, base$R, multilingual$4, base$T, base$9, base$t];
    context.slots = ["label", "info", "description", "before", "between", "after", "addon-before", "addon-after"];
    return _objectSpread2$1({}, multilingual$8(props, context));
  }
};
var TEditorElement = {
  name: "TEditorElement",
  mixins: [BaseElement, HasView, HasChange, HasData, HasValidation],
  emits: ["change", "blur", "alert", "error", "beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeUnmount", "unmounted"],
  props: {
    type: {
      required: false,
      type: [String],
      default: "t-editor",
      private: true
    },
    default: {
      required: false,
      type: [Object, String, Number],
      localized: true,
      default: null
    },
    debounce: {
      required: false,
      type: [Number],
      default: null
    },
    disabled: {
      required: false,
      type: [Boolean],
      default: false
    },
    id: {
      required: false,
      type: [String],
      default: null
    },
    placeholder: {
      required: false,
      type: [String, Object],
      localized: true,
      default: null
    },
    onError: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    onAlert: {
      required: false,
      type: [Function],
      default: null,
      private: true
    },
    accept: {
      required: false,
      type: [Array],
      default: null
    },
    acceptMimes: {
      required: false,
      type: [Array],
      default: null
    },
    endpoint: {
      required: false,
      type: [String, Function, Promise],
      default: null,
      "@default": "config.endpoints.attachment.url"
    },
    method: {
      required: false,
      type: [String],
      default: null,
      "@default": "config.endpoints.attachment.method"
    },
    hideTools: {
      required: false,
      type: [Array],
      default: () => []
    },
    onBlur: {
      required: false,
      type: [Function],
      default: null,
      private: true
    }
  },
  setup(props, context) {
    context.features = [base$19, base$18, base$V, base$M, base$O, base$S, base$U, base$1c, base$P, base$1, multilingual$6, multilingual$2, multilingual$7, base$14, multilingual$3, multilingual$5, teditor, base$$, base$J, base$Z, base$Y, base$3, base$1a, base$_, base$X, base$m, base$2, base$n, base$b, base$R, multilingual$4, base$T, base$t];
    context.slots = ["label", "info", "description", "before", "between", "after"];
    return _objectSpread2$1({}, multilingual$8(props, context));
  }
};
var CheckboxgroupCheckbox = {
  name: "CheckboxgroupCheckbox",
  props: {
    item: {
      type: [Object, String, Number],
      required: true
    },
    value: {
      type: [String, Number],
      required: true
    },
    items: {
      type: [Object, Array],
      required: true
    },
    index: {
      type: [Number],
      required: true
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    var {
      value,
      item
    } = toRefs(props);
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var isDisabled = computed(() => {
      var _item$value;
      return el$.value.disabledItems.map((i) => String(i)).indexOf(String(value.value)) !== -1 || el$.value.isDisabled || !!((_item$value = item.value) !== null && _item$value !== void 0 && _item$value.disabled);
    });
    var checked = computed(() => {
      return el$.value.value.indexOf(String(value.value)) !== -1 || el$.value.value.indexOf(Number(value.value)) !== -1;
    });
    var id = computed(() => {
      return "".concat(el$.value.fieldId, "-").concat(value.value);
    });
    var name2 = computed(() => {
      return "".concat(el$.value.path, "-").concat(value.value);
    });
    var handleKeydown = (e2) => {
      if (["ArrowRight", "ArrowDown"].indexOf(e2.key) !== -1) {
        e2.preventDefault();
        var next = e2.target.nextElementSibling;
        if ((next === null || next === void 0 ? void 0 : next.getAttribute("role")) === "checkbox") {
          next.focus();
        }
      } else if (["ArrowLeft", "ArrowUp"].indexOf(e2.key) !== -1) {
        e2.preventDefault();
        var previous = e2.target.previousElementSibling;
        if ((previous === null || previous === void 0 ? void 0 : previous.getAttribute("role")) === "checkbox") {
          previous.focus();
        }
      }
    };
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme,
      isDisabled,
      id,
      name: name2,
      checked,
      handleKeydown
    };
  }
};
var base77 = function base78(props, context, dependencies2) {
  var el$ = dependencies2.el$;
  var form$ = dependencies2.form$;
  var visible = computed(() => {
    return el$.value.stage > 0;
  });
  var hasLink = computed(() => {
    return el$.value.link && el$.value.clickable;
  });
  var hasError = computed(() => {
    return el$.value.hasUploadError;
  });
  var link = computed(() => {
    return el$.value.link;
  });
  var filename = computed(() => {
    var filename2 = el$.value.filename && typeof el$.value.filename === "string" ? el$.value.filename.split("\\").pop().split("/").pop() : el$.value.filename;
    if (filename2) {
      filename2 = filename2.split("?")[0];
    }
    return filename2;
  });
  var clickable = computed(() => {
    return el$.value.clickable;
  });
  var uploaded = computed(() => {
    return el$.value.stage > 1;
  });
  var uploading = computed(() => {
    return el$.value.uploading;
  });
  var progress = computed(() => {
    return el$.value.progress;
  });
  var canRemove = computed(() => {
    return (el$.value.canRemove || el$.value.uploading) && !el$.value.isDisabled;
  });
  var canUploadTemp = computed(() => {
    return el$.value.canUploadTemp;
  });
  var uploadText = computed(() => {
    return form$.value.translations.vueform.elements.file.upload;
  });
  var ariaLabelledby = computed(() => {
    return el$.value.embed ? void 0 : el$.value.labelId;
  });
  var upload = () => {
    el$.value.uploadTemp();
  };
  var remove = () => {
    if (uploading.value) {
      el$.value.handleAbort();
    } else {
      el$.value.handleRemove();
    }
  };
  var handleKeyup = function() {
    var _ref = _asyncToGenerator(function* (e2) {
      switch (e2.key) {
        case "Backspace":
        case "Delete":
          remove();
          if (!el$.value.canSelect) {
            return;
          }
          yield nextTick();
          document.querySelector("#".concat(el$.value.fieldId)).focus();
          break;
        case "Enter":
          if (el$.value.auto) {
            return;
          }
          upload();
          break;
      }
    });
    return function handleKeyup2(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    visible,
    hasLink,
    hasError,
    link,
    filename,
    clickable,
    uploaded,
    uploading,
    progress,
    canRemove,
    canUploadTemp,
    uploadText,
    ariaLabelledby,
    upload,
    remove,
    handleKeyup
  };
};
var FilePreview = {
  name: "FilePreview",
  props: {
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var {
      visible,
      hasLink,
      hasError,
      link,
      filename,
      clickable,
      uploaded,
      uploading,
      progress,
      canRemove,
      canUploadTemp,
      uploadText,
      ariaLabelledby,
      upload,
      remove,
      handleKeyup
    } = base77(props, context, {
      el$,
      form$
    });
    var preview = computed(() => {
      return el$.value.preview;
    });
    var ariaPlaceholder = computed(() => {
      var text5 = el$.value.embed && el$.value.View !== "gallery" ? void 0 : filename.value;
      if (hasError.value) {
        if (text5) {
          text5 += ", error";
        } else {
          text5 = "error";
        }
      }
      return text5;
    });
    var ariaRoledescription = computed(() => {
      return el$.value.embed && el$.value.View !== "gallery" || uploaded.value || el$.value.auto ? void 0 : uploadText.value;
    });
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme,
      visible,
      hasLink,
      hasError,
      link,
      filename,
      clickable,
      uploaded,
      uploading,
      progress,
      canRemove,
      canUploadTemp,
      uploadText,
      preview,
      ariaLabelledby,
      ariaPlaceholder,
      ariaRoledescription,
      upload,
      remove,
      handleKeyup
    };
  }
};
var RadiogroupRadio = {
  name: "RadiogroupRadio",
  props: {
    item: {
      type: [Object, String, Number],
      required: true
    },
    value: {
      type: [String, Number],
      required: true
    },
    items: {
      type: [Object, Array],
      required: true
    },
    index: {
      type: [Number],
      required: true
    },
    attrs: {
      required: false,
      type: [Object],
      default: () => ({})
    }
  },
  setup(props, context) {
    var {
      value,
      item
    } = toRefs(props);
    var {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme
    } = base$10(props, context);
    var isDisabled = computed(() => {
      var _item$value;
      return el$.value.disabledItems.map((i) => String(i)).indexOf(String(value.value)) !== -1 || el$.value.isDisabled || !!((_item$value = item.value) !== null && _item$value !== void 0 && _item$value.disabled);
    });
    var checked = computed(() => {
      return el$.value.value === String(value.value) || el$.value.value === Number(value.value);
    });
    var id = computed(() => {
      return "".concat(el$.value.fieldId, "-").concat(value.value);
    });
    var name2 = computed(() => {
      return el$.value.path;
    });
    var handleKeydown = (e2) => {
      if (["ArrowRight", "ArrowDown"].indexOf(e2.key) !== -1) {
        e2.preventDefault();
        var next = e2.target.nextElementSibling;
        if ((next === null || next === void 0 ? void 0 : next.getAttribute("role")) === "radio") {
          next.focus();
        }
      } else if (["ArrowLeft", "ArrowUp"].indexOf(e2.key) !== -1) {
        e2.preventDefault();
        var previous = e2.target.previousElementSibling;
        if ((previous === null || previous === void 0 ? void 0 : previous.getAttribute("role")) === "radio") {
          previous.focus();
        }
      }
    };
    return {
      el$,
      form$,
      Size,
      View,
      classesInstance,
      classes,
      Templates,
      template,
      theme,
      isDisabled,
      id,
      name: name2,
      checked,
      handleKeydown
    };
  }
};
var index = {
  Vueform: VueformComponent,
  FormErrors,
  FormMessages,
  FormLanguages,
  FormLanguage,
  FormTabs,
  FormTab,
  FormSteps,
  FormStepsControls,
  FormStepsControl,
  FormStep,
  FormElements,
  ElementLayout,
  ElementLayoutInline,
  ElementLoader,
  ElementLabelFloating,
  ElementLabel,
  ElementInfo,
  ElementDescription,
  ElementError,
  ElementMessage,
  ElementText,
  DragAndDrop,
  ElementAddon,
  ElementAddonOptions,
  DatepickerWrapper,
  EditorWrapper,
  ButtonElement,
  CaptchaElement,
  CheckboxElement,
  CheckboxgroupElement,
  DateElement,
  DatesElement,
  FileElement,
  GenericElement,
  GroupElement,
  HiddenElement,
  ListElement,
  LocationElement,
  MultifileElement,
  MultiselectElement,
  ObjectElement,
  PhoneElement,
  RadioElement,
  RadiogroupElement,
  SelectElement,
  SliderElement,
  StaticElement,
  TagsElement,
  TextareaElement,
  TextElement,
  ToggleElement,
  EditorElement,
  TTextareaElement,
  TTextElement,
  TEditorElement,
  CheckboxgroupCheckbox,
  FilePreview,
  RadiogroupRadio
};
var components = Object.freeze({
  __proto__: null,
  "default": index,
  Vueform: VueformComponent,
  FormErrors,
  FormMessages,
  FormLanguages,
  FormLanguage,
  FormTabs,
  FormTab,
  FormSteps,
  FormStepsControls,
  FormStepsControl,
  FormStep,
  FormElements,
  ElementLayout,
  ElementLayoutInline,
  ElementLoader,
  ElementLabelFloating,
  ElementLabel,
  ElementInfo,
  ElementDescription,
  ElementError,
  ElementMessage,
  ElementText,
  DragAndDrop,
  ElementAddon,
  ElementAddonOptions,
  DatepickerWrapper,
  EditorWrapper,
  ButtonElement,
  CaptchaElement,
  CheckboxElement,
  CheckboxgroupElement,
  DateElement,
  DatesElement,
  FileElement,
  GenericElement,
  GroupElement,
  HiddenElement,
  ListElement,
  LocationElement,
  MultifileElement,
  MultiselectElement,
  ObjectElement,
  PhoneElement,
  RadioElement,
  RadiogroupElement,
  SelectElement,
  SliderElement,
  StaticElement,
  TagsElement,
  TextareaElement,
  TextElement,
  ToggleElement,
  EditorElement,
  TTextareaElement,
  TTextElement,
  TEditorElement,
  CheckboxgroupCheckbox,
  FilePreview,
  RadiogroupRadio
});
function element(options) {
  var component = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!options.name) {
    throw Error("The `name` attribute must be defined to create a new element");
  }
  options = _objectSpread2$1(_objectSpread2$1({}, options), component);
  var name2 = options.name;
  var ComponentName = "".concat(upperFirst_1(camelCase_1(name2)));
  var emits = [].concat(GenericElement.emits).concat(options.emits || []);
  return _objectSpread2$1({
    name: ComponentName,
    components: options.components || {},
    mixins: [].concat(GenericElement.mixins).concat(options.mixins || []),
    emits,
    props: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, GenericElement.props), options.props || {}), {}, {
      type: {
        required: false,
        type: [String],
        default: name2,
        private: true
      }
    }),
    setup(props, ctx) {
      var context = _objectSpread2$1(_objectSpread2$1({}, ctx), {}, {
        emits,
        name: ref(ComponentName),
        nullValue: options.nullValue !== void 0 ? options.nullValue : null
      });
      var element2 = GenericElement.setup(props, context);
      context.element = element2;
      var setup = options.setup ? options.setup(props, context) : {};
      return _objectSpread2$1(_objectSpread2$1({}, element2), setup);
    }
  }, omit_1(options, ["setup", "mixins", "emits", "props"]));
}
function defineConfig(config2) {
  return config2;
}
var VueformElement = element;
var defineElement = element;
installer(void 0, {
  Vueform: VueformComponent,
  FormElements
});
var vueform = installer(void 0, _objectSpread2$1({}, components), _objectSpread2$1({}, rules));
export {
  ButtonElement,
  CaptchaElement,
  CheckboxElement,
  CheckboxgroupCheckbox,
  CheckboxgroupElement,
  DateElement,
  DatepickerWrapper,
  DatesElement,
  DragAndDrop,
  EditorElement,
  EditorWrapper,
  ElementAddon,
  ElementAddonOptions,
  ElementDescription,
  ElementError,
  ElementInfo,
  ElementLabel,
  ElementLabelFloating,
  ElementLayout,
  ElementLayoutInline,
  ElementLoader,
  ElementMessage,
  ElementText,
  FileElement,
  FilePreview,
  FormElements,
  FormErrors,
  FormLanguage,
  FormLanguages,
  FormMessages,
  FormStep,
  FormSteps,
  FormStepsControl,
  FormStepsControls,
  FormTab,
  FormTabs,
  GenericElement,
  GroupElement,
  HiddenElement,
  ListElement,
  LocationElement,
  MultifileElement,
  MultiselectElement,
  ObjectElement,
  PhoneElement,
  RadioElement,
  RadiogroupElement,
  RadiogroupRadio,
  SelectElement,
  SliderElement,
  StaticElement,
  TEditorElement,
  TTextElement,
  TTextareaElement,
  TagsElement,
  TextElement,
  TextareaElement,
  ToggleElement,
  Validator,
  VueformComponent as Vueform,
  VueformElement,
  accepted,
  active_url,
  after,
  after_or_equal,
  alpha,
  alpha_dash,
  alpha_num,
  array$2 as array,
  before,
  before_or_equal,
  between,
  boolean$1 as boolean,
  captcha$2 as captcha,
  completed,
  confirmed,
  date$4 as date,
  date_equals,
  date_format,
  vueform as default,
  defineConfig,
  defineElement,
  different,
  digits,
  digits_between,
  dimensions,
  distinct,
  element,
  email,
  exists,
  file$5 as file,
  filled,
  gt,
  gte,
  image,
  in_,
  in_array,
  installer,
  integer,
  ip,
  ipv4,
  ipv6,
  json,
  lt,
  lte,
  max2 as max,
  mimes,
  mimetypes,
  min$1 as min,
  not_in,
  not_regex,
  nullable,
  numeric,
  regex,
  required,
  same,
  size,
  string,
  timezone,
  unique,
  url,
  base$1a as useClasses,
  base$1b as useVueform,
  uuid,
  vueform
};
/*! Bundled license information:

moment/dist/moment.js:
  (*! moment.js *)
  (*! version : 2.30.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

@vueform/vueform/dist/index.mjs:
  (*!
   * Vueform v1.9.9 (https://github.com/vueform/vueform)
   * Copyright (c) 2024 Adam Berecz <adam@vueform.com>
   * Licensed under the MIT License
   *)
  (**!
   * Sortable 1.15.2
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)
*/
//# sourceMappingURL=@vueform_vueform.js.map
